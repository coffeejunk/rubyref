---
English:
  English:
    main: |-
      Include the English library file in a Ruby script, and you can
      reference the global variables such as <tt>$_</tt> using less
      cryptic names, listed below.

      Without 'English':

          $\ = ' -- '
          "waterbuffalo" =~ /buff/
          print $', $$, "\n"

      With English:

          require "English"

          $OUTPUT_FIELD_SEPARATOR = ' -- '
          "waterbuffalo" =~ /buff/
          print $POSTMATCH, $PID, "\n"

      Below is a full list of descriptive aliases and their associated global
      variable:

      $ERROR_INFO::              $!
      $ERROR_POSITION::          $@
      $FS::                      $;
      $FIELD_SEPARATOR::         $;
      $OFS::                     $,
      $OUTPUT_FIELD_SEPARATOR::  $,
      $RS::                      $/
      $INPUT_RECORD_SEPARATOR::  $/
      $ORS::                     $\
      $OUTPUT_RECORD_SEPARATOR:: $\
      $INPUT_LINE_NUMBER::       $.
      $NR::                      $.
      $LAST_READ_LINE::          $_
      $DEFAULT_OUTPUT::          $>
      $DEFAULT_INPUT::           $<
      $PID::                     $$
      $PROCESS_ID::              $$
      $CHILD_STATUS::            $?
      $LAST_MATCH_INFO::         $~
      $IGNORECASE::              $=
      $ARGV::                    $*
      $MATCH::                   $&
      $PREMATCH::                $`
      $POSTMATCH::               $'
      $LAST_PAREN_MATCH::        $+
abbrev:
  Abbrev:
    main: |-
      Calculates the set of unambiguous abbreviations for a given set of strings.

        require 'abbrev'
        require 'pp'

        pp Abbrev.abbrev(['ruby'])
        #=>  {"ruby"=>"ruby", "rub"=>"ruby", "ru"=>"ruby", "r"=>"ruby"}

        pp Abbrev.abbrev(%w{ ruby rules })

      _Generates:_
        { "ruby"  =>  "ruby",
          "rub"   =>  "ruby",
          "rules" =>  "rules",
          "rule"  =>  "rules",
          "rul"   =>  "rules" }

      It also provides an array core extension, Array#abbrev.

        pp %w{ summer winter }.abbrev

      _Generates:_
        { "summer"  => "summer",
          "summe"   => "summer",
          "summ"    => "summer",
          "sum"     => "summer",
          "su"      => "summer",
          "s"       => "summer",
          "winter"  => "winter",
          "winte"   => "winter",
          "wint"    => "winter",
          "win"     => "winter",
          "wi"      => "winter",
          "w"       => "winter" }
base64:
  Base64:
    main: |-
      The Base64 module provides for the encoding (#encode64, #strict_encode64,
      #urlsafe_encode64) and decoding (#decode64, #strict_decode64,
      #urlsafe_decode64) of binary data using a Base64 representation.

      == Example

      A simple encoding and decoding.

          require "base64"

          enc   = Base64.encode64('Send reinforcements')
                              # -> "U2VuZCByZWluZm9yY2VtZW50cw==\n"
          plain = Base64.decode64(enc)
                              # -> "Send reinforcements"

      The purpose of using base64 to encode data is that it translates any
      binary data into purely printable characters.
benchmark:
  Benchmark:
    main: |-
      The Benchmark module provides methods to measure and report the time
      used to execute Ruby code.

      * Measure the time to construct the string given by the expression
        <code>"a"*1_000_000_000</code>:

            require 'benchmark'

            puts Benchmark.measure { "a"*1_000_000_000 }

        On my machine (OSX 10.8.3 on i5 1.7 GHz) this generates:

            0.350000   0.400000   0.750000 (  0.835234)

        This report shows the user CPU time, system CPU time, the sum of
        the user and system CPU times, and the elapsed real time. The unit
        of time is seconds.

      * Do some experiments sequentially using the #bm method:

            require 'benchmark'

            n = 5000000
            Benchmark.bm do |x|
              x.report { for i in 1..n; a = "1"; end }
              x.report { n.times do   ; a = "1"; end }
              x.report { 1.upto(n) do ; a = "1"; end }
            end

        The result:

                   user     system      total        real
               1.010000   0.000000   1.010000 (  1.014479)
               1.000000   0.000000   1.000000 (  0.998261)
               0.980000   0.000000   0.980000 (  0.981335)

      * Continuing the previous example, put a label in each report:

            require 'benchmark'

            n = 5000000
            Benchmark.bm(7) do |x|
              x.report("for:")   { for i in 1..n; a = "1"; end }
              x.report("times:") { n.times do   ; a = "1"; end }
              x.report("upto:")  { 1.upto(n) do ; a = "1"; end }
            end

      The result:

                          user     system      total        real
            for:      1.010000   0.000000   1.010000 (  1.015688)
            times:    1.000000   0.000000   1.000000 (  1.003611)
            upto:     1.030000   0.000000   1.030000 (  1.028098)

      * The times for some benchmarks depend on the order in which items
        are run.  These differences are due to the cost of memory
        allocation and garbage collection. To avoid these discrepancies,
        the #bmbm method is provided.  For example, to compare ways to
        sort an array of floats:

            require 'benchmark'

            array = (1..1000000).map { rand }

            Benchmark.bmbm do |x|
              x.report("sort!") { array.dup.sort! }
              x.report("sort")  { array.dup.sort  }
            end

        The result:

             Rehearsal -----------------------------------------
             sort!   1.490000   0.010000   1.500000 (  1.490520)
             sort    1.460000   0.000000   1.460000 (  1.463025)
             -------------------------------- total: 2.960000sec

                         user     system      total        real
             sort!   1.460000   0.000000   1.460000 (  1.460465)
             sort    1.450000   0.010000   1.460000 (  1.448327)

      * Report statistics of sequential experiments with unique labels,
        using the #benchmark method:

            require 'benchmark'
            include Benchmark         # we need the CAPTION and FORMAT constants

            n = 5000000
            Benchmark.benchmark(CAPTION, 7, FORMAT, ">total:", ">avg:") do |x|
              tf = x.report("for:")   { for i in 1..n; a = "1"; end }
              tt = x.report("times:") { n.times do   ; a = "1"; end }
              tu = x.report("upto:")  { 1.upto(n) do ; a = "1"; end }
              [tf+tt+tu, (tf+tt+tu)/3]
            end

        The result:

                          user     system      total        real
             for:      0.950000   0.000000   0.950000 (  0.952039)
             times:    0.980000   0.000000   0.980000 (  0.984938)
             upto:     0.950000   0.000000   0.950000 (  0.946787)
             >total:   2.880000   0.000000   2.880000 (  2.883764)
             >avg:     0.960000   0.000000   0.960000 (  0.961255)
  Benchmark::Tms:
    main: |-
      A data object, representing the times associated with a benchmark
      measurement.
bundler:
  Bundler:
    main: |-
      Bundler provides a consistent environment for Ruby projects by
      tracking and installing the exact gems and versions that are needed.

      Since Ruby 2.6, Bundler is a part of Ruby's standard library.

      Bunder is used by creating _gemfiles_ listing all the project dependencies
      and (optionally) their versions and then using

        require 'bundler/setup'

      or Bundler.setup to setup environment where only specified gems and their
      specified versions could be used.

      See {Bundler website}[https://bundler.io/docs.html] for extensive documentation
      on gemfiles creation and Bundler usage.

      As a standard library inside project, Bundler could be used for introspection
      of loaded and required modules.
  Bundler::BuildMetadata:
    main: Represents metadata from when the Bundler gem was built.
  Bundler::ConnectionPool:
    main: |-
      Generic connection pool class for e.g. sharing a limited number of network connections
      among many threads.  Note: Connections are lazily created.

      Example usage with block (faster):

         @pool = Bundler::ConnectionPool.new { Redis.new }

         @pool.with do |redis|
           redis.lpop('my-list') if redis.llen('my-list') > 0
         end

      Using optional timeout override (for that single invocation)

         @pool.with(timeout: 2.0) do |redis|
           redis.lpop('my-list') if redis.llen('my-list') > 0
         end

      Example usage replacing an existing connection (slower):

         $redis = Bundler::ConnectionPool.wrap { Redis.new }

         def do_work
           $redis.lpop('my-list') if $redis.llen('my-list') > 0
         end

      Accepts the following options:
      - :size - number of connections to pool, defaults to 5
      - :timeout - amount of time to wait for a connection if none currently available, defaults to 5 seconds
  Bundler::ConnectionPool::PoolShuttingDownError:
    main: |-
      Raised when you attempt to retrieve a connection from a pool that has been
      shut down.
  Bundler::ConnectionPool::TimedStack:
    main: |-
      Examples:

         ts = TimedStack.new(1) { MyConnection.new }

         # fetch a connection
         conn = ts.pop

         # return a connection
         ts.push conn

         conn = ts.pop
         ts.pop timeout: 5
         #=> raises Timeout::Error after 5 seconds
  Bundler::EndpointSpecification:
    main: used for Creating Specifications from the Gemcutter Endpoint
  Bundler::Fetcher:
    main: Handles all the fetching with the rubygems server
  Bundler::Fetcher::AuthenticationRequiredError:
    main: This error is raised if HTTP authentication is required, but not provided.
  Bundler::Fetcher::BadAuthenticationError:
    main: This error is raised if HTTP authentication is provided, but incorrect.
  Bundler::Fetcher::CertificateFailureError:
    main: This is the error raised if OpenSSL fails the cert verification
  Bundler::Fetcher::FallbackError:
    main: This error is raised if the API returns a 413 (only printed in verbose)
  Bundler::Fetcher::NetworkDownError:
    main: This error is raised when it looks like the network is down
  Bundler::Fetcher::SSLError:
    main: This is the error raised when a source is HTTPS and OpenSSL didn't load
  Bundler::Fetcher::TooManyRequestsError:
    main: This error is raised if we should rate limit our requests to the API
  Bundler::FileUtils:
    main: |-
      = fileutils.rb

      Copyright (c) 2000-2007 Minero Aoki

      This program is free software.
      You can distribute/modify this program under the same terms of ruby.

      == module Bundler::FileUtils

      Namespace for several file utility methods for copying, moving, removing, etc.

      === Module Functions

        require 'bundler/vendor/fileutils/lib/fileutils'

        Bundler::FileUtils.cd(dir, **options)
        Bundler::FileUtils.cd(dir, **options) {|dir| block }
        Bundler::FileUtils.pwd()
        Bundler::FileUtils.mkdir(dir, **options)
        Bundler::FileUtils.mkdir(list, **options)
        Bundler::FileUtils.mkdir_p(dir, **options)
        Bundler::FileUtils.mkdir_p(list, **options)
        Bundler::FileUtils.rmdir(dir, **options)
        Bundler::FileUtils.rmdir(list, **options)
        Bundler::FileUtils.ln(target, link, **options)
        Bundler::FileUtils.ln(targets, dir, **options)
        Bundler::FileUtils.ln_s(target, link, **options)
        Bundler::FileUtils.ln_s(targets, dir, **options)
        Bundler::FileUtils.ln_sf(target, link, **options)
        Bundler::FileUtils.cp(src, dest, **options)
        Bundler::FileUtils.cp(list, dir, **options)
        Bundler::FileUtils.cp_r(src, dest, **options)
        Bundler::FileUtils.cp_r(list, dir, **options)
        Bundler::FileUtils.mv(src, dest, **options)
        Bundler::FileUtils.mv(list, dir, **options)
        Bundler::FileUtils.rm(list, **options)
        Bundler::FileUtils.rm_r(list, **options)
        Bundler::FileUtils.rm_rf(list, **options)
        Bundler::FileUtils.install(src, dest, **options)
        Bundler::FileUtils.chmod(mode, list, **options)
        Bundler::FileUtils.chmod_R(mode, list, **options)
        Bundler::FileUtils.chown(user, group, list, **options)
        Bundler::FileUtils.chown_R(user, group, list, **options)
        Bundler::FileUtils.touch(list, **options)

      Possible <tt>options</tt> are:

      <tt>:force</tt> :: forced operation (rewrite files if exist, remove
                         directories if not empty, etc.);
      <tt>:verbose</tt> :: print command to be run, in bash syntax, before
                           performing it;
      <tt>:preserve</tt> :: preserve object's group, user and modification
                            time on copying;
      <tt>:noop</tt> :: no changes are made (usable in combination with
                        <tt>:verbose</tt> which will print the command to run)

      Each method documents the options that it honours. See also ::commands,
      ::options and ::options_of methods to introspect which command have which
      options.

      All methods that have the concept of a "source" file or directory can take
      either one file or a list of files in that argument.  See the method
      documentation for examples.

      There are some `low level' methods, which do not accept keyword arguments:

        Bundler::FileUtils.copy_entry(src, dest, preserve = false, dereference_root = false, remove_destination = false)
        Bundler::FileUtils.copy_file(src, dest, preserve = false, dereference = true)
        Bundler::FileUtils.copy_stream(srcstream, deststream)
        Bundler::FileUtils.remove_entry(path, force = false)
        Bundler::FileUtils.remove_entry_secure(path, force = false)
        Bundler::FileUtils.remove_file(path, force = false)
        Bundler::FileUtils.compare_file(path_a, path_b)
        Bundler::FileUtils.compare_stream(stream_a, stream_b)
        Bundler::FileUtils.uptodate?(file, cmp_list)

      == module Bundler::FileUtils::Verbose

      This module has all methods of Bundler::FileUtils module, but it outputs messages
      before acting.  This equates to passing the <tt>:verbose</tt> flag to methods
      in Bundler::FileUtils.

      == module Bundler::FileUtils::NoWrite

      This module has all methods of Bundler::FileUtils module, but never changes
      files/directories.  This equates to passing the <tt>:noop</tt> flag to methods
      in Bundler::FileUtils.

      == module Bundler::FileUtils::DryRun

      This module has all methods of Bundler::FileUtils module, but never changes
      files/directories.  This equates to passing the <tt>:noop</tt> and
      <tt>:verbose</tt> flags to methods in Bundler::FileUtils.
  Bundler::FileUtils::DryRun:
    main: |-
      This module has all methods of Bundler::FileUtils module, but never changes
      files/directories, with printing message before acting.
      This equates to passing the <tt>:noop</tt> and <tt>:verbose</tt> flag
      to methods in Bundler::FileUtils.
  Bundler::FileUtils::NoWrite:
    main: |-
      This module has all methods of Bundler::FileUtils module, but never changes
      files/directories.  This equates to passing the <tt>:noop</tt> flag
      to methods in Bundler::FileUtils.
  Bundler::FileUtils::Verbose:
    main: |-
      This module has all methods of Bundler::FileUtils module, but it outputs messages
      before acting.  This equates to passing the <tt>:verbose</tt> flag to
      methods in Bundler::FileUtils.
  Bundler::GemRemoteFetcher:
    main: |-
      Adds support for setting custom HTTP headers when fetching gems from the
      server.

      TODO: Get rid of this when and if gemstash only supports RubyGems versions
      that contain https://github.com/rubygems/rubygems/commit/3db265cc20b2f813.
  Bundler::GemVersionPromoter:
    main: |-
      This class contains all of the logic for determining the next version of a
      Gem to update to based on the requested level (patch, minor, major).
      Primarily designed to work with Resolver which will provide it the list of
      available dependency versions as found in its index, before returning it to
      to the resolution engine to select the best version.
  Bundler::MirrorSockets:
    main: |-
      Class used to build the list of sockets that correspond to
        a given mirror.

      One mirror may correspond to many different addresses, both
        because of it having many dns entries or because
        the network interface is both ipv4 and ipv5
  Bundler::Molinillo:
    main: Bundler::Molinillo is a generic dependency resolution algorithm.
  Bundler::Molinillo::CircularDependencyError:
    main: |-
      An error caused by attempting to fulfil a dependency that was circular

      @note This exception will be thrown iff a {Vertex} is added to a
        {DependencyGraph} that has a {DependencyGraph::Vertex#path_to?} an
        existing {DependencyGraph::Vertex}
  Bundler::Molinillo::Compatibility:
    main: Hacks needed for old Ruby versions.
  Bundler::Molinillo::Delegates:
    main: "@!visibility private"
  Bundler::Molinillo::Delegates::ResolutionState:
    main: Delegates all {Bundler::Molinillo::ResolutionState} methods to a `#state`
      property.
  Bundler::Molinillo::Delegates::SpecificationProvider:
    main: |-
      Delegates all {Bundler::Molinillo::SpecificationProvider} methods to a
      `#specification_provider` property.
  Bundler::Molinillo::DependencyGraph:
    main: A directed acyclic graph that is tuned to hold named dependencies
  Bundler::Molinillo::DependencyGraph::Action:
    main: |-
      An action that modifies a {DependencyGraph} that is reversible.
      @abstract
  Bundler::Molinillo::DependencyGraph::AddEdgeNoCircular:
    main: |-
      @!visibility private
      (see DependencyGraph#add_edge_no_circular)
  Bundler::Molinillo::DependencyGraph::DeleteEdge:
    main: |-
      @!visibility private
      (see DependencyGraph#delete_edge)
  Bundler::Molinillo::DependencyGraph::DetachVertexNamed:
    main: |-
      @!visibility private
      @see DependencyGraph#detach_vertex_named
  Bundler::Molinillo::DependencyGraph::Log:
    main: A log for dependency graph actions
  Bundler::Molinillo::DependencyGraph::Tag:
    main: |-
      @!visibility private
      @see DependencyGraph#tag
  Bundler::Molinillo::DependencyGraph::Vertex:
    main: |-
      A vertex in a {DependencyGraph} that encapsulates a {#name} and a
      {#payload}
  Bundler::Molinillo::DependencyState:
    main: |-
      A state that encapsulates a set of {#requirements} with an {Array} of
      possibilities
  Bundler::Molinillo::NoSuchDependencyError:
    main: |-
      An error caused by searching for a dependency that is completely unknown,
      i.e. has no versions available whatsoever.
  Bundler::Molinillo::PossibilityState:
    main: |-
      A state that encapsulates a single possibility to fulfill the given
      {#requirement}
  Bundler::Molinillo::Resolver:
    main: |-
      This class encapsulates a dependency resolver.
      The resolver is responsible for determining which set of dependencies to
      activate, with feedback from the {#specification_provider}
  Bundler::Molinillo::Resolver::Resolution:
    main: A specific resolution from a given {Resolver}
  Bundler::Molinillo::ResolverError:
    main: An error that occurred during the resolution process
  Bundler::Molinillo::SpecificationProvider:
    main: |-
      Provides information about specifcations and dependencies to the resolver,
      allowing the {Resolver} class to remain generic while still providing power
      and flexibility.

      This module contains the methods that users of Bundler::Molinillo must to implement,
      using knowledge of their own model classes.
  Bundler::Molinillo::UI:
    main: Conveys information about the resolution process to a user.
  Bundler::Molinillo::VersionConflict:
    main: An error caused by conflicts in version
  Bundler::Persistent::Net::HTTP::Persistent:
    main: |-
      Persistent connections for Net::HTTP

      Bundler::Persistent::Net::HTTP::Persistent maintains persistent connections across all the
      servers you wish to talk to.  For each host:port you communicate with a
      single persistent connection is created.

      Multiple Bundler::Persistent::Net::HTTP::Persistent objects will share the same set of
      connections.

      For each thread you start a new connection will be created.  A
      Bundler::Persistent::Net::HTTP::Persistent connection will not be shared across threads.

      You can shut down the HTTP connections when done by calling #shutdown.  You
      should name your Bundler::Persistent::Net::HTTP::Persistent object if you intend to call this
      method.

      Example:

        require 'bundler/vendor/net-http-persistent/lib/net/http/persistent'

        uri = Bundler::URI 'http://example.com/awesome/web/service'

        http = Bundler::Persistent::Net::HTTP::Persistent.new name: 'my_app_name'

        # perform a GET
        response = http.request uri

        # or

        get = Net::HTTP::Get.new uri.request_uri
        response = http.request get

        # create a POST
        post_uri = uri + 'create'
        post = Net::HTTP::Post.new post_uri.path
        post.set_form_data 'some' => 'cool data'

        # perform the POST, the Bundler::URI is always required
        response http.request post_uri, post

      Note that for GET, HEAD and other requests that do not have a body you want
      to use Bundler::URI#request_uri not Bundler::URI#path.  The request_uri contains the query
      params which are sent in the body for other requests.

      == SSL

      SSL connections are automatically created depending upon the scheme of the
      Bundler::URI.  SSL connections are automatically verified against the default
      certificate store for your computer.  You can override this by changing
      verify_mode or by specifying an alternate cert_store.

      Here are the SSL settings, see the individual methods for documentation:

      #certificate        :: This client's certificate
      #ca_file            :: The certificate-authorities
      #ca_path            :: Directory with certificate-authorities
      #cert_store         :: An SSL certificate store
      #ciphers            :: List of SSl ciphers allowed
      #private_key        :: The client's SSL private key
      #reuse_ssl_sessions :: Reuse a previously opened SSL session for a new
                             connection
      #ssl_timeout        :: SSL session lifetime
      #ssl_version        :: Which specific SSL version to use
      #verify_callback    :: For server certificate verification
      #verify_depth       :: Depth of certificate verification
      #verify_mode        :: How connections should be verified

      == Proxies

      A proxy can be set through #proxy= or at initialization time by providing a
      second argument to ::new.  The proxy may be the Bundler::URI of the proxy server or
      <code>:ENV</code> which will consult environment variables.

      See #proxy= and #proxy_from_env for details.

      == Headers

      Headers may be specified for use in every request.  #headers are appended to
      any headers on the request.  #override_headers replace existing headers on
      the request.

      The difference between the two can be seen in setting the User-Agent.  Using
      <code>http.headers['User-Agent'] = 'MyUserAgent'</code> will send "Ruby,
      MyUserAgent" while <code>http.override_headers['User-Agent'] =
      'MyUserAgent'</code> will send "MyUserAgent".

      == Tuning

      === Segregation

      By providing an application name to ::new you can separate your connections
      from the connections of other applications.

      === Idle Timeout

      If a connection hasn't been used for this number of seconds it will automatically be
      reset upon the next use to avoid attempting to send to a closed connection.
      The default value is 5 seconds. nil means no timeout. Set through #idle_timeout.

      Reducing this value may help avoid the "too many connection resets" error
      when sending non-idempotent requests while increasing this value will cause
      fewer round-trips.

      === Read Timeout

      The amount of time allowed between reading two chunks from the socket.  Set
      through #read_timeout

      === Max Requests

      The number of requests that should be made before opening a new connection.
      Typically many keep-alive capable servers tune this to 100 or less, so the
      101st request will fail with ECONNRESET. If unset (default), this value has no
      effect, if set, connections will be reset on the request after max_requests.

      === Open Timeout

      The amount of time to wait for a connection to be opened.  Set through
      #open_timeout.

      === Socket Options

      Socket options may be set on newly-created connections.  See #socket_options
      for details.

      === Non-Idempotent Requests

      By default non-idempotent requests will not be retried per RFC 2616.  By
      setting retry_change_requests to true requests will automatically be retried
      once.

      Only do this when you know that retrying a POST or other non-idempotent
      request is safe for your application and will not create duplicate
      resources.

      The recommended way to handle non-idempotent requests is the following:

        require 'bundler/vendor/net-http-persistent/lib/net/http/persistent'

        uri = Bundler::URI 'http://example.com/awesome/web/service'
        post_uri = uri + 'create'

        http = Bundler::Persistent::Net::HTTP::Persistent.new name: 'my_app_name'

        post = Net::HTTP::Post.new post_uri.path
        # ... fill in POST request

        begin
          response = http.request post_uri, post
        rescue Bundler::Persistent::Net::HTTP::Persistent::Error

          # POST failed, make a new request to verify the server did not process
          # the request
          exists_uri = uri + '...'
          response = http.get exists_uri

          # Retry if it failed
          retry if response.code == '404'
        end

      The method of determining if the resource was created or not is unique to
      the particular service you are using.  Of course, you will want to add
      protection from infinite looping.

      === Connection Termination

      If you are done using the Bundler::Persistent::Net::HTTP::Persistent instance you may shut down
      all the connections in the current thread with #shutdown.  This is not
      recommended for normal use, it should only be used when it will be several
      minutes before you make another HTTP request.

      If you are using multiple threads, call #shutdown in each thread when the
      thread is done making requests.  If you don't call shutdown, that's OK.
      Ruby will automatically garbage collect and shutdown your HTTP connections
      when the thread terminates.
  Bundler::Persistent::Net::HTTP::Persistent::Error:
    main: |-
      Error class for errors raised by Bundler::Persistent::Net::HTTP::Persistent.  Various
      SystemCallErrors are re-raised with a human-readable message under this
      class.
  Bundler::Plugin:
    main: |-
      This is the interfacing class represents the API that we intend to provide
      the plugins to use.

      For plugins to be independent of the Bundler internals they shall limit their
      interactions to methods of this class only. This will save them from breaking
      when some internal change.

      Currently we are delegating the methods defined in Bundler class to
      itself. So, this class acts as a buffer.

      If there is some change in the Bundler class that is incompatible to its
      previous behavior or if otherwise desired, we can reimplement(or implement)
      the method to preserve compatibility.

      To use this, either the class can inherit this class or use it directly.
      For example of both types of use, refer the file `spec/plugins/command.rb`

      To use it without inheriting, you will have to create an object of this
      to use the functions (except for declaration functions like command, source,
      and hooks).
  Bundler::Plugin::API::Source:
    main: |-
      This class provides the base to build source plugins
      All the method here are required to build a source plugin (except
      `uri_hash`, `gem_install_dir`; they are helpers).

      Defaults for methods, where ever possible are provided which is
      expected to work. But, all source plugins have to override
      `fetch_gemspec_files` and `install`. Defaults are also not provided for
      `remote!`, `cache!` and `unlock!`.

      The defaults shall work for most situations but nevertheless they can
      be (preferably should be) overridden as per the plugins' needs safely
      (as long as they behave as expected).
      On overriding `initialize` you should call super first.

      If required plugin should override `hash`, `==` and `eql?` methods to be
      able to match objects representing same sources, but may be created in
      different situation (like form gemfile and lockfile). The default ones
      checks only for class and uri, but elaborate source plugins may need
      more comparisons (e.g. git checking on branch or tag).

      @!attribute [r] uri
        @return [String] the remote specified with `source` block in Gemfile

      @!attribute [r] options
        @return [String] options passed during initialization (either from
          lockfile or Gemfile)

      @!attribute [r] name
        @return [String] name that can be used to uniquely identify a source

      @!attribute [rw] dependency_names
        @return [Array<String>] Names of dependencies that the source should
          try to resolve. It is not necessary to use this list internally. This
          is present to be compatible with `Definition` and is used by
          rubygems source.
  Bundler::Plugin::DSL:
    main: Dsl to parse the Gemfile looking for plugins to install
  Bundler::RemoteSpecification:
    main: |-
      Represents a lazily loaded gem specification, where the full specification
      is on the source server in rubygems' "quick" index. The proxy object is to
      be seeded with what we're given from the source's abbreviated index - the
      full specification will only be fetched when necessary.
  Bundler::Retry:
    main: General purpose class for retrying code that may fail
  Bundler::Settings::Mirror:
    main: |-
      A mirror

      Contains both the uri that should be used as a mirror and the
        fallback timeout which will be used for probing if the mirror
        replies on time or not.
  Bundler::Settings::MirrorConfig:
    main: |-
      Class used to parse one configuration line

      Gets the configuration line and the value.
        This object provides a `update_mirror` method
        used to setup the given mirror value.
  Bundler::Settings::Mirrors:
    main: |-
      Class used to build the mirror set and then find a mirror for a given URI

      @param prober [Prober object, nil] by default a TCPSocketProbe, this object
        will be used to probe the mirror address to validate that the mirror replies.
  Bundler::Settings::TCPSocketProbe:
    main: Class used for probing TCP availability for a given mirror.
  Bundler::SocketAddress:
    main: |-
      Socket address builder.

      Given a socket type, a host and a port,
        provides a method to build sockaddr string
  Bundler::Source::Git::GitProxy:
    main: |-
      The GitProxy is responsible to interact with git repositories.
      All actions required by the Git source is encapsulated in this
      object.
  Bundler::Thor::Actions::CapturableERB:
    main: |-
      Bundler::Thor::Actions#capture depends on what kind of buffer is used in ERB.
      Thus CapturableERB fixes ERB to use String buffer.
  Bundler::Thor::DynamicCommand:
    main: A dynamic command that handles method missing scenarios.
  Bundler::Thor::DynamicTask:
    main: A dynamic command that handles method missing scenarios.
  Bundler::Thor::Group:
    main: |-
      Bundler::Thor has a special class called Bundler::Thor::Group. The main difference to Bundler::Thor class
      is that it invokes all commands at once. It also include some methods that allows
      invocations to be done at the class method, which are not available to Bundler::Thor
      commands.
  Bundler::Thor::HiddenCommand:
    main: A command that is hidden in help messages but still invocable.
  Bundler::Thor::HiddenTask:
    main: A command that is hidden in help messages but still invocable.
  Bundler::Thor::RakeCompat:
    main: |-
      Adds a compatibility layer to your Bundler::Thor classes which allows you to use
      rake package tasks. For example, to use rspec rake tasks, one can do:

        require 'bundler/vendor/thor/lib/thor/rake_compat'
        require 'rspec/core/rake_task'

        class Default < Bundler::Thor
          include Bundler::Thor::RakeCompat

          RSpec::Core::RakeTask.new(:spec) do |t|
            t.spec_opts = ['--options', './.rspec']
            t.spec_files = FileList['spec/**/*_spec.rb']
          end
        end
  Bundler::Thor::Shell::Color:
    main: |-
      Inherit from Bundler::Thor::Shell::Basic and add set_color behavior. Check
      Bundler::Thor::Shell::Basic to see all available methods.
  Bundler::Thor::Shell::HTML:
    main: |-
      Inherit from Bundler::Thor::Shell::Basic and add set_color behavior. Check
      Bundler::Thor::Shell::Basic to see all available methods.
  Bundler::Thor::Util:
    main: |-
      This module holds several utilities:

      1) Methods to convert thor namespaces to constants and vice-versa.

        Bundler::Thor::Util.namespace_from_thor_class(Foo::Bar::Baz) #=> "foo:bar:baz"

      2) Loading thor files and sandboxing:

        Bundler::Thor::Util.load_thorfile("~/.thor/foo")
  Bundler::URI:
    main: |-
      Bundler::URI is a module providing classes to handle Uniform Resource Identifiers
      (RFC2396[http://tools.ietf.org/html/rfc2396]).

      == Features

      * Uniform way of handling URIs.
      * Flexibility to introduce custom Bundler::URI schemes.
      * Flexibility to have an alternate Bundler::URI::Parser (or just different patterns
        and regexp's).

      == Basic example

        require 'bundler/vendor/uri/lib/uri'

        uri = Bundler::URI("http://foo.com/posts?id=30&limit=5#time=1305298413")
        #=> #<Bundler::URI::HTTP http://foo.com/posts?id=30&limit=5#time=1305298413>

        uri.scheme    #=> "http"
        uri.host      #=> "foo.com"
        uri.path      #=> "/posts"
        uri.query     #=> "id=30&limit=5"
        uri.fragment  #=> "time=1305298413"

        uri.to_s      #=> "http://foo.com/posts?id=30&limit=5#time=1305298413"

      == Adding custom URIs

        module Bundler::URI
          class RSYNC < Generic
            DEFAULT_PORT = 873
          end
          @@schemes['RSYNC'] = RSYNC
        end
        #=> Bundler::URI::RSYNC

        Bundler::URI.scheme_list
        #=> {"FILE"=>Bundler::URI::File, "FTP"=>Bundler::URI::FTP, "HTTP"=>Bundler::URI::HTTP,
        #    "HTTPS"=>Bundler::URI::HTTPS, "LDAP"=>Bundler::URI::LDAP, "LDAPS"=>Bundler::URI::LDAPS,
        #    "MAILTO"=>Bundler::URI::MailTo, "RSYNC"=>Bundler::URI::RSYNC}

        uri = Bundler::URI("rsync://rsync.foo.com")
        #=> #<Bundler::URI::RSYNC rsync://rsync.foo.com>

      == RFC References

      A good place to view an RFC spec is http://www.ietf.org/rfc.html.

      Here is a list of all related RFC's:
      - RFC822[http://tools.ietf.org/html/rfc822]
      - RFC1738[http://tools.ietf.org/html/rfc1738]
      - RFC2255[http://tools.ietf.org/html/rfc2255]
      - RFC2368[http://tools.ietf.org/html/rfc2368]
      - RFC2373[http://tools.ietf.org/html/rfc2373]
      - RFC2396[http://tools.ietf.org/html/rfc2396]
      - RFC2732[http://tools.ietf.org/html/rfc2732]
      - RFC3986[http://tools.ietf.org/html/rfc3986]

      == Class tree

      - Bundler::URI::Generic (in uri/generic.rb)
        - Bundler::URI::File - (in uri/file.rb)
        - Bundler::URI::FTP - (in uri/ftp.rb)
        - Bundler::URI::HTTP - (in uri/http.rb)
          - Bundler::URI::HTTPS - (in uri/https.rb)
        - Bundler::URI::LDAP - (in uri/ldap.rb)
          - Bundler::URI::LDAPS - (in uri/ldaps.rb)
        - Bundler::URI::MailTo - (in uri/mailto.rb)
      - Bundler::URI::Parser - (in uri/common.rb)
      - Bundler::URI::REGEXP - (in uri/common.rb)
        - Bundler::URI::REGEXP::PATTERN - (in uri/common.rb)
      - Bundler::URI::Util - (in uri/common.rb)
      - Bundler::URI::Escape - (in uri/common.rb)
      - Bundler::URI::Error - (in uri/common.rb)
        - Bundler::URI::InvalidURIError - (in uri/common.rb)
        - Bundler::URI::InvalidComponentError - (in uri/common.rb)
        - Bundler::URI::BadURIError - (in uri/common.rb)

      == Copyright Info

      Author:: Akira Yamada <akira@ruby-lang.org>
      Documentation::
        Akira Yamada <akira@ruby-lang.org>
        Dmitry V. Sabanin <sdmitry@lrn.ru>
        Vincent Batts <vbatts@hashbangbash.com>
      License::
       Copyright (c) 2001 akira yamada <akira@ruby-lang.org>
       You can redistribute it and/or modify it under the same term as Ruby.
      Revision:: $Id$
  Bundler::URI::BadURIError:
    main: Bundler::URI is valid, bad usage is not.
  Bundler::URI::Error:
    main: Base class for all Bundler::URI exceptions.
  Bundler::URI::Escape:
    main: Module for escaping unsafe characters with codes.
  Bundler::URI::FTP:
    main: |-
      FTP Bundler::URI syntax is defined by RFC1738 section 3.2.

      This class will be redesigned because of difference of implementations;
      the structure of its path. draft-hoffman-ftp-uri-04 is a draft but it
      is a good summary about the de facto spec.
      http://tools.ietf.org/html/draft-hoffman-ftp-uri-04
  Bundler::URI::File:
    main: The "file" Bundler::URI is defined by RFC8089.
  Bundler::URI::Generic:
    main: |-
      Base class for all Bundler::URI classes.
      Implements generic Bundler::URI syntax as per RFC 2396.
  Bundler::URI::HTTP:
    main: |-
      The syntax of HTTP URIs is defined in RFC1738 section 3.3.

      Note that the Ruby Bundler::URI library allows HTTP URLs containing usernames and
      passwords. This is not legal as per the RFC, but used to be
      supported in Internet Explorer 5 and 6, before the MS04-004 security
      update. See <URL:http://support.microsoft.com/kb/834489>.
  Bundler::URI::HTTPS:
    main: |-
      The default port for HTTPS URIs is 443, and the scheme is 'https:' rather
      than 'http:'. Other than that, HTTPS URIs are identical to HTTP URIs;
      see Bundler::URI::HTTP.
  Bundler::URI::InvalidComponentError:
    main: Not a Bundler::URI component.
  Bundler::URI::InvalidURIError:
    main: Not a Bundler::URI.
  Bundler::URI::LDAP:
    main: LDAP Bundler::URI SCHEMA (described in RFC2255).
  Bundler::URI::LDAPS:
    main: |-
      The default port for LDAPS URIs is 636, and the scheme is 'ldaps:' rather
      than 'ldap:'. Other than that, LDAPS URIs are identical to LDAP URIs;
      see Bundler::URI::LDAP.
  Bundler::URI::MailTo:
    main: RFC6068, the mailto URL scheme.
  Bundler::URI::Parser:
    main: |-
      Class that parses String's into Bundler::URI's.

      It contains a Hash set of patterns and Regexp's that match and validate.
  Bundler::URI::REGEXP:
    main: Includes Bundler::URI::REGEXP::PATTERN
  Bundler::URI::RFC2396_Parser:
    main: |-
      Class that parses String's into Bundler::URI's.

      It contains a Hash set of patterns and Regexp's that match and validate.
  Bundler::URI::RFC2396_REGEXP:
    main: Includes Bundler::URI::REGEXP::PATTERN
  Bundler::URI::RFC2396_REGEXP::PATTERN:
    main: Patterns used to parse Bundler::URI's
  Bundler::VersionConflict:
    main: Internal error, should be rescued
  Bundler::YAMLSerializer:
    main: A stub yaml serializer that can handle only hashes and strings (as of now).
  Error:
    main: |-
      Bundler::Thor::Error is raised when it's caused by wrong usage of thor classes. Those
      errors have their backtrace suppressed and are nicely shown to the user.

      Errors that are caused by the developer, like declaring a method which
      overwrites a thor keyword, SHOULD NOT raise a Bundler::Thor::Error. This way, we
      ensure that developer errors are shown with full backtrace.
  InvocationError:
    main: Raised when a command was found, but not invoked properly.
  UndefinedCommandError:
    main: Raised when a command was not found.
  UndefinedTaskError:
    main: Raised when a command was not found.
cgi:
  CGI:
    main: |-
      == Overview

      The Common Gateway Interface (CGI) is a simple protocol for passing an HTTP
      request from a web server to a standalone program, and returning the output
      to the web browser.  Basically, a CGI program is called with the parameters
      of the request passed in either in the environment (GET) or via $stdin
      (POST), and everything it prints to $stdout is returned to the client.

      This file holds the CGI class.  This class provides functionality for
      retrieving HTTP request parameters, managing cookies, and generating HTML
      output.

      The file CGI::Session provides session management functionality; see that
      class for more details.

      See http://www.w3.org/CGI/ for more information on the CGI protocol.

      == Introduction

      CGI is a large class, providing several categories of methods, many of which
      are mixed in from other modules.  Some of the documentation is in this class,
      some in the modules CGI::QueryExtension and CGI::HtmlExtension.  See
      CGI::Cookie for specific information on handling cookies, and cgi/session.rb
      (CGI::Session) for information on sessions.

      For queries, CGI provides methods to get at environmental variables,
      parameters, cookies, and multipart request data.  For responses, CGI provides
      methods for writing output and generating HTML.

      Read on for more details.  Examples are provided at the bottom.

      == Queries

      The CGI class dynamically mixes in parameter and cookie-parsing
      functionality,  environmental variable access, and support for
      parsing multipart requests (including uploaded files) from the
      CGI::QueryExtension module.

      === Environmental Variables

      The standard CGI environmental variables are available as read-only
      attributes of a CGI object.  The following is a list of these variables:

        AUTH_TYPE               HTTP_HOST          REMOTE_IDENT
        CONTENT_LENGTH          HTTP_NEGOTIATE     REMOTE_USER
        CONTENT_TYPE            HTTP_PRAGMA        REQUEST_METHOD
        GATEWAY_INTERFACE       HTTP_REFERER       SCRIPT_NAME
        HTTP_ACCEPT             HTTP_USER_AGENT    SERVER_NAME
        HTTP_ACCEPT_CHARSET     PATH_INFO          SERVER_PORT
        HTTP_ACCEPT_ENCODING    PATH_TRANSLATED    SERVER_PROTOCOL
        HTTP_ACCEPT_LANGUAGE    QUERY_STRING       SERVER_SOFTWARE
        HTTP_CACHE_CONTROL      REMOTE_ADDR
        HTTP_FROM               REMOTE_HOST

      For each of these variables, there is a corresponding attribute with the
      same name, except all lower case and without a preceding HTTP_.
      +content_length+ and +server_port+ are integers; the rest are strings.

      === Parameters

      The method #params() returns a hash of all parameters in the request as
      name/value-list pairs, where the value-list is an Array of one or more
      values.  The CGI object itself also behaves as a hash of parameter names
      to values, but only returns a single value (as a String) for each
      parameter name.

      For instance, suppose the request contains the parameter
      "favourite_colours" with the multiple values "blue" and "green".  The
      following behavior would occur:

        cgi.params["favourite_colours"]  # => ["blue", "green"]
        cgi["favourite_colours"]         # => "blue"

      If a parameter does not exist, the former method will return an empty
      array, the latter an empty string.  The simplest way to test for existence
      of a parameter is by the #has_key? method.

      === Cookies

      HTTP Cookies are automatically parsed from the request.  They are available
      from the #cookies() accessor, which returns a hash from cookie name to
      CGI::Cookie object.

      === Multipart requests

      If a request's method is POST and its content type is multipart/form-data,
      then it may contain uploaded files.  These are stored by the QueryExtension
      module in the parameters of the request.  The parameter name is the name
      attribute of the file input field, as usual.  However, the value is not
      a string, but an IO object, either an IOString for small files, or a
      Tempfile for larger ones.  This object also has the additional singleton
      methods:

      #local_path():: the path of the uploaded file on the local filesystem
      #original_filename():: the name of the file on the client computer
      #content_type():: the content type of the file

      == Responses

      The CGI class provides methods for sending header and content output to
      the HTTP client, and mixes in methods for programmatic HTML generation
      from CGI::HtmlExtension and CGI::TagMaker modules.  The precise version of HTML
      to use for HTML generation is specified at object creation time.

      === Writing output

      The simplest way to send output to the HTTP client is using the #out() method.
      This takes the HTTP headers as a hash parameter, and the body content
      via a block.  The headers can be generated as a string using the #http_header()
      method.  The output stream can be written directly to using the #print()
      method.

      === Generating HTML

      Each HTML element has a corresponding method for generating that
      element as a String.  The name of this method is the same as that
      of the element, all lowercase.  The attributes of the element are
      passed in as a hash, and the body as a no-argument block that evaluates
      to a String.  The HTML generation module knows which elements are
      always empty, and silently drops any passed-in body.  It also knows
      which elements require matching closing tags and which don't.  However,
      it does not know what attributes are legal for which elements.

      There are also some additional HTML generation methods mixed in from
      the CGI::HtmlExtension module.  These include individual methods for the
      different types of form inputs, and methods for elements that commonly
      take particular attributes where the attributes can be directly specified
      as arguments, rather than via a hash.

      === Utility HTML escape and other methods like a function.

      There are some utility tool defined in cgi/util.rb .
      And when include, you can use utility methods like a function.

      == Examples of use

      === Get form values

        require "cgi"
        cgi = CGI.new
        value = cgi['field_name']   # <== value string for 'field_name'
          # if not 'field_name' included, then return "".
        fields = cgi.keys            # <== array of field names

        # returns true if form has 'field_name'
        cgi.has_key?('field_name')
        cgi.has_key?('field_name')
        cgi.include?('field_name')

      CAUTION! cgi['field_name'] returned an Array with the old
      cgi.rb(included in Ruby 1.6)

      === Get form values as hash

        require "cgi"
        cgi = CGI.new
        params = cgi.params

      cgi.params is a hash.

        cgi.params['new_field_name'] = ["value"]  # add new param
        cgi.params['field_name'] = ["new_value"]  # change value
        cgi.params.delete('field_name')           # delete param
        cgi.params.clear                          # delete all params

      === Save form values to file

        require "pstore"
        db = PStore.new("query.db")
        db.transaction do
          db["params"] = cgi.params
        end

      === Restore form values from file

        require "pstore"
        db = PStore.new("query.db")
        db.transaction do
          cgi.params = db["params"]
        end

      === Get multipart form values

        require "cgi"
        cgi = CGI.new
        value = cgi['field_name']   # <== value string for 'field_name'
        value.read                  # <== body of value
        value.local_path            # <== path to local file of value
        value.original_filename     # <== original filename of value
        value.content_type          # <== content_type of value

      and value has StringIO or Tempfile class methods.

      === Get cookie values

        require "cgi"
        cgi = CGI.new
        values = cgi.cookies['name']  # <== array of 'name'
          # if not 'name' included, then return [].
        names = cgi.cookies.keys      # <== array of cookie names

      and cgi.cookies is a hash.

      === Get cookie objects

        require "cgi"
        cgi = CGI.new
        for name, cookie in cgi.cookies
          cookie.expires = Time.now + 30
        end
        cgi.out("cookie" => cgi.cookies) {"string"}

        cgi.cookies # { "name1" => cookie1, "name2" => cookie2, ... }

        require "cgi"
        cgi = CGI.new
        cgi.cookies['name'].expires = Time.now + 30
        cgi.out("cookie" => cgi.cookies['name']) {"string"}

      === Print http header and html string to $DEFAULT_OUTPUT ($>)

        require "cgi"
        cgi = CGI.new("html4")  # add HTML generation methods
        cgi.out do
          cgi.html do
            cgi.head do
              cgi.title { "TITLE" }
            end +
            cgi.body do
              cgi.form("ACTION" => "uri") do
                cgi.p do
                  cgi.textarea("get_text") +
                  cgi.br +
                  cgi.submit
                end
              end +
              cgi.pre do
                CGI.escapeHTML(
                  "params: #{cgi.params.inspect}\n" +
                  "cookies: #{cgi.cookies.inspect}\n" +
                  ENV.collect do |key, value|
                    "#{key} --> #{value}\n"
                  end.join("")
                )
              end
            end
          end
        end

        # add HTML generation methods
        CGI.new("html3")    # html3.2
        CGI.new("html4")    # html4.01 (Strict)
        CGI.new("html4Tr")  # html4.01 Transitional
        CGI.new("html4Fr")  # html4.01 Frameset
        CGI.new("html5")    # html5

      === Some utility methods

        require 'cgi/util'
        CGI.escapeHTML('Usage: foo "bar" <baz>')

      === Some utility methods like a function

        require 'cgi/util'
        include CGI::Util
        escapeHTML('Usage: foo "bar" <baz>')
        h('Usage: foo "bar" <baz>') # alias
  CGI::Cookie:
    main: |-
      Class representing an HTTP cookie.

      In addition to its specific fields and methods, a Cookie instance
      is a delegator to the array of its values.

      See RFC 2965.

      == Examples of use
        cookie1 = CGI::Cookie.new("name", "value1", "value2", ...)
        cookie1 = CGI::Cookie.new("name" => "name", "value" => "value")
        cookie1 = CGI::Cookie.new('name'     => 'name',
                                  'value'    => ['value1', 'value2', ...],
                                  'path'     => 'path',   # optional
                                  'domain'   => 'domain', # optional
                                  'expires'  => Time.now, # optional
                                  'secure'   => true,     # optional
                                  'httponly' => true      # optional
                                  )

        cgi.out("cookie" => [cookie1, cookie2]) { "string" }

        name     = cookie1.name
        values   = cookie1.value
        path     = cookie1.path
        domain   = cookie1.domain
        expires  = cookie1.expires
        secure   = cookie1.secure
        httponly = cookie1.httponly

        cookie1.name     = 'name'
        cookie1.value    = ['value1', 'value2', ...]
        cookie1.path     = 'path'
        cookie1.domain   = 'domain'
        cookie1.expires  = Time.now + 30
        cookie1.secure   = true
        cookie1.httponly = true
  CGI::HtmlExtension:
    main: |-
      Mixin module providing HTML generation methods.

      For example,
        cgi.a("http://www.example.com") { "Example" }
          # => "<A HREF=\"http://www.example.com\">Example</A>"

      Modules Html3, Html4, etc., contain more basic HTML-generation methods
      (+#title+, +#h1+, etc.).

      See class CGI for a detailed example.
  CGI::InvalidEncoding:
    main: Exception raised when there is an invalid encoding detected
  CGI::QueryExtension:
    main: |-
      Mixin module that provides the following:

      1. Access to the CGI environment variables as methods.  See
         documentation to the CGI class for a list of these variables.  The
         methods are exposed by removing the leading +HTTP_+ (if it exists) and
         downcasing the name.  For example, +auth_type+ will return the
         environment variable +AUTH_TYPE+, and +accept+ will return the value
         for +HTTP_ACCEPT+.

      2. Access to cookies, including the cookies attribute.

      3. Access to parameters, including the params attribute, and overloading
         #[] to perform parameter value lookup by key.

      4. The initialize_query method, for initializing the above
         mechanisms, handling multipart forms, and allowing the
         class to be used in "offline" mode.
  CGI::Session:
    main: |-
      == Overview

      This file provides the CGI::Session class, which provides session
      support for CGI scripts.  A session is a sequence of HTTP requests
      and responses linked together and associated with a single client.
      Information associated with the session is stored
      on the server between requests.  A session id is passed between client
      and server with every request and response, transparently
      to the user.  This adds state information to the otherwise stateless
      HTTP request/response protocol.

      == Lifecycle

      A CGI::Session instance is created from a CGI object.  By default,
      this CGI::Session instance will start a new session if none currently
      exists, or continue the current session for this client if one does
      exist.  The +new_session+ option can be used to either always or
      never create a new session.  See #new() for more details.

      #delete() deletes a session from session storage.  It
      does not however remove the session id from the client.  If the client
      makes another request with the same id, the effect will be to start
      a new session with the old session's id.

      == Setting and retrieving session data.

      The Session class associates data with a session as key-value pairs.
      This data can be set and retrieved by indexing the Session instance
      using '[]', much the same as hashes (although other hash methods
      are not supported).

      When session processing has been completed for a request, the
      session should be closed using the close() method.  This will
      store the session's state to persistent storage.  If you want
      to store the session's state to persistent storage without
      finishing session processing for this request, call the update()
      method.

      == Storing session state

      The caller can specify what form of storage to use for the session's
      data with the +database_manager+ option to CGI::Session::new.  The
      following storage classes are provided as part of the standard library:

      CGI::Session::FileStore:: stores data as plain text in a flat file.  Only
                                works with String data.  This is the default
                                storage type.
      CGI::Session::MemoryStore:: stores data in an in-memory hash.  The data
                                  only persists for as long as the current Ruby
                                  interpreter instance does.
      CGI::Session::PStore:: stores data in Marshalled format.  Provided by
                             cgi/session/pstore.rb.  Supports data of any type,
                             and provides file-locking and transaction support.

      Custom storage types can also be created by defining a class with
      the following methods:

         new(session, options)
         restore  # returns hash of session data.
         update
         close
         delete

      Changing storage type mid-session does not work.  Note in particular
      that by default the FileStore and PStore session data files have the
      same name.  If your application switches from one to the other without
      making sure that filenames will be different
      and clients still have old sessions lying around in cookies, then
      things will break nastily!

      == Maintaining the session id.

      Most session state is maintained on the server.  However, a session
      id must be passed backwards and forwards between client and server
      to maintain a reference to this session state.

      The simplest way to do this is via cookies.  The CGI::Session class
      provides transparent support for session id communication via cookies
      if the client has cookies enabled.

      If the client has cookies disabled, the session id must be included
      as a parameter of all requests sent by the client to the server.  The
      CGI::Session class in conjunction with the CGI class will transparently
      add the session id as a hidden input field to all forms generated
      using the CGI#form() HTML generation method.  No built-in support is
      provided for other mechanisms, such as URL re-writing.  The caller is
      responsible for extracting the session id from the session_id
      attribute and manually encoding it in URLs and adding it as a hidden
      input to HTML forms created by other mechanisms.  Also, session expiry
      is not automatically handled.

      == Examples of use

      === Setting the user's name

        require 'cgi'
        require 'cgi/session'
        require 'cgi/session/pstore'     # provides CGI::Session::PStore

        cgi = CGI.new("html4")

        session = CGI::Session.new(cgi,
            'database_manager' => CGI::Session::PStore,  # use PStore
            'session_key' => '_rb_sess_id',              # custom session key
            'session_expires' => Time.now + 30 * 60,     # 30 minute timeout
            'prefix' => 'pstore_sid_')                   # PStore option
        if cgi.has_key?('user_name') and cgi['user_name'] != ''
            # coerce to String: cgi[] returns the
            # string-like CGI::QueryExtension::Value
            session['user_name'] = cgi['user_name'].to_s
        elsif !session['user_name']
            session['user_name'] = "guest"
        end
        session.close

      === Creating a new session safely

        require 'cgi'
        require 'cgi/session'

        cgi = CGI.new("html4")

        # We make sure to delete an old session if one exists,
        # not just to free resources, but to prevent the session
        # from being maliciously hijacked later on.
        begin
            session = CGI::Session.new(cgi, 'new_session' => false)
            session.delete
        rescue ArgumentError  # if no old session
        end
        session = CGI::Session.new(cgi, 'new_session' => true)
        session.close
  CGI::Session::FileStore:
    main: |-
      File-based session storage class.

      Implements session storage as a flat file of 'key=value' values.
      This storage type only works directly with String values; the
      user is responsible for converting other types to Strings when
      storing and from Strings when retrieving.
  CGI::Session::MemoryStore:
    main: |-
      In-memory session storage class.

      Implements session storage as a global in-memory hash.  Session
      data will only persist for as long as the Ruby interpreter
      instance does.
  CGI::Session::NullStore:
    main: |-
      Dummy session storage class.

      Implements session storage place holder.  No actual storage
      will be done.
  CGI::Session::PStore:
    main: |-
      PStore-based session storage class.

      This builds upon the top-level PStore class provided by the
      library file pstore.rb.  Session data is marshalled and stored
      in a file.  File locking and transaction services are provided.
csv:
  CSV:
    main: |-
      This class provides a complete interface to CSV files and data. It offers
      tools to enable you to read and write to and from Strings or IO objects, as
      needed.

      The most generic interface of the library is:

         csv = CSV.new(string_or_io, **options)

         # Reading: IO object should be open for read
         csv.read # => array of rows
         # or
         csv.each do |row|
           # ...
         end
         # or
         row = csv.shift

         # Writing: IO object should be open for write
         csv << row

      There are several specialized class methods for one-statement reading or writing,
      described in the Specialized Methods section.

      If a String is passed into ::new, it is internally wrapped into a StringIO object.

      +options+ can be used for specifying the particular CSV flavor (column
      separators, row separators, value quoting and so on), and for data conversion,
      see Data Conversion section for the description of the latter.

      == Specialized Methods

      === Reading

        # From a file: all at once
        arr_of_rows = CSV.read("path/to/file.csv", **options)
        # iterator-style:
        CSV.foreach("path/to/file.csv", **options) do |row|
          # ...
        end

        # From a string
        arr_of_rows = CSV.parse("CSV,data,String", **options)
        # or
        CSV.parse("CSV,data,String", **options) do |row|
          # ...
        end

      === Writing

        # To a file
        CSV.open("path/to/file.csv", "wb") do |csv|
          csv << ["row", "of", "CSV", "data"]
          csv << ["another", "row"]
          # ...
        end

        # To a String
        csv_string = CSV.generate do |csv|
          csv << ["row", "of", "CSV", "data"]
          csv << ["another", "row"]
          # ...
        end

      === Shortcuts

        # Core extensions for converting one line
        csv_string = ["CSV", "data"].to_csv   # to CSV
        csv_array  = "CSV,String".parse_csv   # from CSV

        # CSV() method
        CSV             { |csv_out| csv_out << %w{my data here} }  # to $stdout
        CSV(csv = "")   { |csv_str| csv_str << %w{my data here} }  # to a String
        CSV($stderr)    { |csv_err| csv_err << %w{my data here} }  # to $stderr
        CSV($stdin)     { |csv_in|  csv_in.each { |row| p row } }  # from $stdin

      == Data Conversion

      === CSV with headers

      CSV allows to specify column names of CSV file, whether they are in data, or
      provided separately. If headers are specified, reading methods return an instance
      of CSV::Table, consisting of CSV::Row.

        # Headers are part of data
        data = CSV.parse(<<~ROWS, headers: true)
          Name,Department,Salary
          Bob,Engineering,1000
          Jane,Sales,2000
          John,Management,5000
        ROWS

        data.class      #=> CSV::Table
        data.first      #=> #<CSV::Row "Name":"Bob" "Department":"Engineering" "Salary":"1000">
        data.first.to_h #=> {"Name"=>"Bob", "Department"=>"Engineering", "Salary"=>"1000"}

        # Headers provided by developer
        data = CSV.parse('Bob,Engineering,1000', headers: %i[name department salary])
        data.first      #=> #<CSV::Row name:"Bob" department:"Engineering" salary:"1000">

      === Typed data reading

      CSV allows to provide a set of data _converters_ e.g. transformations to try on input
      data. Converter could be a symbol from CSV::Converters constant's keys, or lambda.

        # Without any converters:
        CSV.parse('Bob,2018-03-01,100')
        #=> [["Bob", "2018-03-01", "100"]]

        # With built-in converters:
        CSV.parse('Bob,2018-03-01,100', converters: %i[numeric date])
        #=> [["Bob", #<Date: 2018-03-01>, 100]]

        # With custom converters:
        CSV.parse('Bob,2018-03-01,100', converters: [->(v) { Time.parse(v) rescue v }])
        #=> [["Bob", 2018-03-01 00:00:00 +0200, "100"]]

      == CSV and Character Encodings (M17n or Multilingualization)

      This new CSV parser is m17n savvy.  The parser works in the Encoding of the IO
      or String object being read from or written to. Your data is never transcoded
      (unless you ask Ruby to transcode it for you) and will literally be parsed in
      the Encoding it is in. Thus CSV will return Arrays or Rows of Strings in the
      Encoding of your data. This is accomplished by transcoding the parser itself
      into your Encoding.

      Some transcoding must take place, of course, to accomplish this multiencoding
      support. For example, <tt>:col_sep</tt>, <tt>:row_sep</tt>, and
      <tt>:quote_char</tt> must be transcoded to match your data.  Hopefully this
      makes the entire process feel transparent, since CSV's defaults should just
      magically work for your data. However, you can set these values manually in
      the target Encoding to avoid the translation.

      It's also important to note that while all of CSV's core parser is now
      Encoding agnostic, some features are not. For example, the built-in
      converters will try to transcode data to UTF-8 before making conversions.
      Again, you can provide custom converters that are aware of your Encodings to
      avoid this translation. It's just too hard for me to support native
      conversions in all of Ruby's Encodings.

      Anyway, the practical side of this is simple: make sure IO and String objects
      passed into CSV have the proper Encoding set and everything should just work.
      CSV methods that allow you to open IO objects (CSV::foreach(), CSV::open(),
      CSV::read(), and CSV::readlines()) do allow you to specify the Encoding.

      One minor exception comes when generating CSV into a String with an Encoding
      that is not ASCII compatible. There's no existing data for CSV to use to
      prepare itself and thus you will probably need to manually specify the desired
      Encoding for most of those cases. It will try to guess using the fields in a
      row of output though, when using CSV::generate_line() or Array#to_csv().

      I try to point out any other Encoding issues in the documentation of methods
      as they come up.

      This has been tested to the best of my ability with all non-"dummy" Encodings
      Ruby ships with. However, it is brave new code and may have some bugs.
      Please feel free to {report}[mailto:james@grayproductions.net] any issues you
      find with it.
  CSV::FieldsConverter:
    main: 'Note: Don''t use this class directly. This is an internal class.'
  CSV::MalformedCSVError:
    main: The error thrown when the parser encounters illegal CSV formatting.
  CSV::Parser:
    main: 'Note: Don''t use this class directly. This is an internal class.'
  CSV::Parser::InputsScanner:
    main: |-
      CSV::InputsScanner receives IO inputs, encoding and the chunk_size.
      It also controls the life cycle of the object with its methods +keep_start+,
      +keep_end+, +keep_back+, +keep_drop+.

      CSV::InputsScanner.scan() tries to match with pattern at the current position.
      If there's a match, the scanner advances the “scan pointer” and returns the matched string.
      Otherwise, the scanner returns nil.

      CSV::InputsScanner.rest() returns the “rest” of the string (i.e. everything after the scan pointer).
      If there is no more data (eos? = true), it returns "".
  CSV::Parser::InvalidEncoding:
    main: Raised when encoding is invalid.
  CSV::Parser::Scanner:
    main: |-
      CSV::Scanner receives a CSV output, scans it and return the content.
      It also controls the life cycle of the object with its methods +keep_start+,
      +keep_end+, +keep_back+, +keep_drop+.

      Uses StringScanner (the official strscan gem). Strscan provides lexical
      scanning operations on a String. We inherit its object and take advantage
      on the methods. For more information, please visit:
      https://ruby-doc.org/stdlib-2.6.1/libdoc/strscan/rdoc/StringScanner.html
  CSV::Row:
    main: |-
      A CSV::Row is part Array and part Hash. It retains an order for the fields
      and allows duplicates just as an Array would, but also allows you to access
      fields by name just as you could if they were in a Hash.

      All rows returned by CSV will be constructed from this class, if header row
      processing is activated.
  CSV::Table:
    main: |-
      A CSV::Table is a two-dimensional data structure for representing CSV
      documents. Tables allow you to work with the data by row or column,
      manipulate the data, and even convert the results back to CSV, if needed.

      All tables returned by CSV will be constructed from this class, if header
      row processing is activated.
  CSV::Writer:
    main: 'Note: Don''t use this class directly. This is an internal class.'
debug:
  DEBUGGER__:
    main: |-
      This library provides debugging functionality to Ruby.

      To add a debugger to your code, start by requiring +debug+ in your
      program:

        def say(word)
          require 'debug'
          puts word
        end

      This will cause Ruby to interrupt execution and show a prompt when the +say+
      method is run.

      Once you're inside the prompt, you can start debugging your program.

        (rdb:1) p word
        "hello"

      == Getting help

      You can get help at any time by pressing +h+.

        (rdb:1) h
        Debugger help v.-0.002b
        Commands
          b[reak] [file:|class:]<line|method>
          b[reak] [class.]<line|method>
                                     set breakpoint to some position
          wat[ch] <expression>       set watchpoint to some expression
          cat[ch] (<exception>|off)  set catchpoint to an exception
          b[reak]                    list breakpoints
          cat[ch]                    show catchpoint
          del[ete][ nnn]             delete some or all breakpoints
          disp[lay] <expression>     add expression into display expression list
          undisp[lay][ nnn]          delete one particular or all display expressions
          c[ont]                     run until program ends or hit breakpoint
          s[tep][ nnn]               step (into methods) one line or till line nnn
          n[ext][ nnn]               go over one line or till line nnn
          w[here]                    display frames
          f[rame]                    alias for where
          l[ist][ (-|nn-mm)]         list program, - lists backwards
                                     nn-mm lists given lines
          up[ nn]                    move to higher frame
          down[ nn]                  move to lower frame
          fin[ish]                   return to outer frame
          tr[ace] (on|off)           set trace mode of current thread
          tr[ace] (on|off) all       set trace mode of all threads
          q[uit]                     exit from debugger
          v[ar] g[lobal]             show global variables
          v[ar] l[ocal]              show local variables
          v[ar] i[nstance] <object>  show instance variables of object
          v[ar] c[onst] <object>     show constants of object
          m[ethod] i[nstance] <obj>  show methods of object
          m[ethod] <class|module>    show instance methods of class or module
          th[read] l[ist]            list all threads
          th[read] c[ur[rent]]       show current thread
          th[read] [sw[itch]] <nnn>  switch thread context to nnn
          th[read] stop <nnn>        stop thread nnn
          th[read] resume <nnn>      resume thread nnn
          p expression               evaluate expression and print its value
          h[elp]                     print this help
          <everything else>          evaluate

      == Usage

      The following is a list of common functionalities that the debugger
      provides.

      === Navigating through your code

      In general, a debugger is used to find bugs in your program, which
      often means pausing execution and inspecting variables at some point
      in time.

      Let's look at an example:

        def my_method(foo)
          require 'debug'
          foo = get_foo if foo.nil?
          raise if foo.nil?
        end

      When you run this program, the debugger will kick in just before the
      +foo+ assignment.

        (rdb:1) p foo
        nil

      In this example, it'd be interesting to move to the next line and
      inspect the value of +foo+ again. You can do that by pressing +n+:

        (rdb:1) n # goes to next line
        (rdb:1) p foo
        nil

      You now know that the original value of +foo+ was nil, and that it
      still was nil after calling +get_foo+.

      Other useful commands for navigating through your code are:

      +c+::
        Runs the program until it either exists or encounters another breakpoint.
        You usually press +c+ when you are finished debugging your program and
        want to resume its execution.
      +s+::
        Steps into method definition. In the previous example, +s+ would take you
        inside the method definition of +get_foo+.
      +r+::
        Restart the program.
      +q+::
        Quit the program.

      === Inspecting variables

      You can use the debugger to easily inspect both local and global variables.
      We've seen how to inspect local variables before:

        (rdb:1) p my_arg
        42

      You can also pretty print the result of variables or expressions:

        (rdb:1) pp %w{a very long long array containing many words}
        ["a",
         "very",
         "long",
         ...
        ]

      You can list all local variables with +v l+:

        (rdb:1) v l
          foo => "hello"

      Similarly, you can show all global variables with +v g+:

        (rdb:1) v g
          all global variables

      Finally, you can omit +p+ if you simply want to evaluate a variable or
      expression

        (rdb:1) 5**2
        25

      === Going beyond basics

      Ruby Debug provides more advanced functionalities like switching
      between threads, setting breakpoints and watch expressions, and more.
      The full list of commands is available at any time by pressing +h+.

      == Staying out of trouble

      Make sure you remove every instance of +require 'debug'+ before
      shipping your code. Failing to do so may result in your program
      hanging unpredictably.

      Debug is not available in safe mode.
delegate:
  Delegator:
    main: |-
      This library provides three different ways to delegate method calls to an
      object.  The easiest to use is SimpleDelegator.  Pass an object to the
      constructor and all methods supported by the object will be delegated.  This
      object can be changed later.

      Going a step further, the top level DelegateClass method allows you to easily
      setup delegation through class inheritance.  This is considerably more
      flexible and thus probably the most common use for this library.

      Finally, if you need full control over the delegation scheme, you can inherit
      from the abstract class Delegator and customize as needed.  (If you find
      yourself needing this control, have a look at Forwardable which is also in
      the standard library.  It may suit your needs better.)

      SimpleDelegator's implementation serves as a nice example of the use of
      Delegator:

        class SimpleDelegator < Delegator
          def __getobj__
            @delegate_sd_obj # return object we are delegating to, required
          end

          def __setobj__(obj)
            @delegate_sd_obj = obj # change delegation object,
                                   # a feature we're providing
          end
        end

      == Notes

      Be advised, RDoc will not detect delegated methods.
  SimpleDelegator:
    main: |-
      A concrete implementation of Delegator, this class provides the means to
      delegate all supported method calls to the object passed into the constructor
      and even to change the object being delegated to at a later time with
      #__setobj__.

        class User
          def born_on
            Date.new(1989, 9, 10)
          end
        end

        class UserDecorator < SimpleDelegator
          def birth_year
            born_on.year
          end
        end

        decorated_user = UserDecorator.new(User.new)
        decorated_user.birth_year  #=> 1989
        decorated_user.__getobj__  #=> #<User: ...>

      A SimpleDelegator instance can take advantage of the fact that SimpleDelegator
      is a subclass of +Delegator+ to call <tt>super</tt> to have methods called on
      the object being delegated to.

        class SuperArray < SimpleDelegator
          def [](*args)
            super + 1
          end
        end

        SuperArray.new([1])[0]  #=> 2

      Here's a simple example that takes advantage of the fact that
      SimpleDelegator's delegation object can be changed at any time.

        class Stats
          def initialize
            @source = SimpleDelegator.new([])
          end

          def stats(records)
            @source.__setobj__(records)

            "Elements:  #{@source.size}\n" +
            " Non-Nil:  #{@source.compact.size}\n" +
            "  Unique:  #{@source.uniq.size}\n"
          end
        end

        s = Stats.new
        puts s.stats(%w{James Edward Gray II})
        puts
        puts s.stats([1, 2, 3, nil, 4, 5, 1, 2])

      Prints:

        Elements:  4
         Non-Nil:  4
          Unique:  4

        Elements:  8
         Non-Nil:  7
          Unique:  6
did_you_mean:
  DidYouMean:
    main: |-
      The +DidYouMean+ gem adds functionality to suggest possible method/class
      names upon errors such as +NameError+ and +NoMethodError+. In Ruby 2.3 or
      later, it is automatically activated during startup.

      @example

        methosd
        # => NameError: undefined local variable or method `methosd' for main:Object
        #   Did you mean?  methods
        #                  method

        OBject
        # => NameError: uninitialized constant OBject
        #    Did you mean?  Object

        @full_name = "Yuki Nishijima"
        first_name, last_name = full_name.split(" ")
        # => NameError: undefined local variable or method `full_name' for main:Object
        #    Did you mean?  @full_name

        @@full_name = "Yuki Nishijima"
        @@full_anme
        # => NameError: uninitialized class variable @@full_anme in Object
        #    Did you mean?  @@full_name

        full_name = "Yuki Nishijima"
        full_name.starts_with?("Y")
        # => NoMethodError: undefined method `starts_with?' for "Yuki Nishijima":String
        #    Did you mean?  start_with?

        hash = {foo: 1, bar: 2, baz: 3}
        hash.fetch(:fooo)
        # => KeyError: key not found: :fooo
        #    Did you mean?  :foo

      == Disabling +did_you_mean+

      Occasionally, you may want to disable the +did_you_mean+ gem for e.g.
      debugging issues in the error object itself. You can disable it entirely by
      specifying +--disable-did_you_mean+ option to the +ruby+ command:

        $ ruby --disable-did_you_mean -e "1.zeor?"
        -e:1:in `<main>': undefined method `zeor?' for 1:Integer (NameError)

      When you do not have direct access to the +ruby+ command (e.g.
      +rails console+, +irb+), you could applyoptions using the +RUBYOPT+
      environment variable:

        $ RUBYOPT='--disable-did_you_mean' irb
        irb:0> 1.zeor?
        # => NoMethodError (undefined method `zeor?' for 1:Integer)

      == Getting the original error message

      Sometimes, you do not want to disable the gem entirely, but need to get the
      original error message without suggestions (e.g. testing). In this case, you
      could use the +#original_message+ method on the error object:

        no_method_error = begin
                            1.zeor?
                          rescue NoMethodError => error
                            error
                          end

        no_method_error.message
        # => NoMethodError (undefined method `zeor?' for 1:Integer)
        #    Did you mean?  zero?

        no_method_error.original_message
        # => NoMethodError (undefined method `zeor?' for 1:Integer)
drb:
  ACL:
    main: |-
      Simple Access Control Lists.

      Access control lists are composed of "allow" and "deny" halves to control
      access.  Use "all" or "*" to match any address.  To match a specific address
      use any address or address mask that IPAddr can understand.

      Example:

        list = %w[
          deny all
          allow 192.168.1.1
          allow ::ffff:192.168.1.2
          allow 192.168.1.3
        ]

        # From Socket#peeraddr, see also ACL#allow_socket?
        addr = ["AF_INET", 10, "lc630", "192.168.1.3"]

        acl = ACL.new
        p acl.allow_addr?(addr) # => true

        acl = ACL.new(list, ACL::DENY_ALLOW)
        p acl.allow_addr?(addr) # => true
  ACL::ACLEntry:
    main: An entry in an ACL
  ACL::ACLList:
    main: |-
      A list of ACLEntry objects.  Used to implement the allow and deny halves
      of an ACL
  DRb:
    main: |-
      == Overview

      dRuby is a distributed object system for Ruby.  It is written in
      pure Ruby and uses its own protocol.  No add-in services are needed
      beyond those provided by the Ruby runtime, such as TCP sockets.  It
      does not rely on or interoperate with other distributed object
      systems such as CORBA, RMI, or .NET.

      dRuby allows methods to be called in one Ruby process upon a Ruby
      object located in another Ruby process, even on another machine.
      References to objects can be passed between processes.  Method
      arguments and return values are dumped and loaded in marshalled
      format.  All of this is done transparently to both the caller of the
      remote method and the object that it is called upon.

      An object in a remote process is locally represented by a
      DRb::DRbObject instance.  This acts as a sort of proxy for the
      remote object.  Methods called upon this DRbObject instance are
      forwarded to its remote object.  This is arranged dynamically at run
      time.  There are no statically declared interfaces for remote
      objects, such as CORBA's IDL.

      dRuby calls made into a process are handled by a DRb::DRbServer
      instance within that process.  This reconstitutes the method call,
      invokes it upon the specified local object, and returns the value to
      the remote caller.  Any object can receive calls over dRuby.  There
      is no need to implement a special interface, or mixin special
      functionality.  Nor, in the general case, does an object need to
      explicitly register itself with a DRbServer in order to receive
      dRuby calls.

      One process wishing to make dRuby calls upon another process must
      somehow obtain an initial reference to an object in the remote
      process by some means other than as the return value of a remote
      method call, as there is initially no remote object reference it can
      invoke a method upon.  This is done by attaching to the server by
      URI.  Each DRbServer binds itself to a URI such as
      'druby://example.com:8787'.  A DRbServer can have an object attached
      to it that acts as the server's *front* *object*.  A DRbObject can
      be explicitly created from the server's URI.  This DRbObject's
      remote object will be the server's front object.  This front object
      can then return references to other Ruby objects in the DRbServer's
      process.

      Method calls made over dRuby behave largely the same as normal Ruby
      method calls made within a process.  Method calls with blocks are
      supported, as are raising exceptions.  In addition to a method's
      standard errors, a dRuby call may also raise one of the
      dRuby-specific errors, all of which are subclasses of DRb::DRbError.

      Any type of object can be passed as an argument to a dRuby call or
      returned as its return value.  By default, such objects are dumped
      or marshalled at the local end, then loaded or unmarshalled at the
      remote end.  The remote end therefore receives a copy of the local
      object, not a distributed reference to it; methods invoked upon this
      copy are executed entirely in the remote process, not passed on to
      the local original.  This has semantics similar to pass-by-value.

      However, if an object cannot be marshalled, a dRuby reference to it
      is passed or returned instead.  This will turn up at the remote end
      as a DRbObject instance.  All methods invoked upon this remote proxy
      are forwarded to the local object, as described in the discussion of
      DRbObjects.  This has semantics similar to the normal Ruby
      pass-by-reference.

      The easiest way to signal that we want an otherwise marshallable
      object to be passed or returned as a DRbObject reference, rather
      than marshalled and sent as a copy, is to include the
      DRb::DRbUndumped mixin module.

      dRuby supports calling remote methods with blocks.  As blocks (or
      rather the Proc objects that represent them) are not marshallable,
      the block executes in the local, not the remote, context.  Each
      value yielded to the block is passed from the remote object to the
      local block, then the value returned by each block invocation is
      passed back to the remote execution context to be collected, before
      the collected values are finally returned to the local context as
      the return value of the method invocation.

      == Examples of usage

      For more dRuby samples, see the +samples+ directory in the full
      dRuby distribution.

      === dRuby in client/server mode

      This illustrates setting up a simple client-server drb
      system.  Run the server and client code in different terminals,
      starting the server code first.

      ==== Server code

        require 'drb/drb'

        # The URI for the server to connect to
        URI="druby://localhost:8787"

        class TimeServer

          def get_current_time
            return Time.now
          end

        end

        # The object that handles requests on the server
        FRONT_OBJECT=TimeServer.new

        DRb.start_service(URI, FRONT_OBJECT)
        # Wait for the drb server thread to finish before exiting.
        DRb.thread.join

      ==== Client code

        require 'drb/drb'

        # The URI to connect to
        SERVER_URI="druby://localhost:8787"

        # Start a local DRbServer to handle callbacks.
        #
        # Not necessary for this small example, but will be required
        # as soon as we pass a non-marshallable object as an argument
        # to a dRuby call.
        #
        # Note: this must be called at least once per process to take any effect.
        # This is particularly important if your application forks.
        DRb.start_service

        timeserver = DRbObject.new_with_uri(SERVER_URI)
        puts timeserver.get_current_time

      === Remote objects under dRuby

      This example illustrates returning a reference to an object
      from a dRuby call.  The Logger instances live in the server
      process.  References to them are returned to the client process,
      where methods can be invoked upon them.  These methods are
      executed in the server process.

      ==== Server code

        require 'drb/drb'

        URI="druby://localhost:8787"

        class Logger

            # Make dRuby send Logger instances as dRuby references,
            # not copies.
            include DRb::DRbUndumped

            def initialize(n, fname)
                @name = n
                @filename = fname
            end

            def log(message)
                File.open(@filename, "a") do |f|
                    f.puts("#{Time.now}: #{@name}: #{message}")
                end
            end

        end

        # We have a central object for creating and retrieving loggers.
        # This retains a local reference to all loggers created.  This
        # is so an existing logger can be looked up by name, but also
        # to prevent loggers from being garbage collected.  A dRuby
        # reference to an object is not sufficient to prevent it being
        # garbage collected!
        class LoggerFactory

            def initialize(bdir)
                @basedir = bdir
                @loggers = {}
            end

            def get_logger(name)
                if !@loggers.has_key? name
                    # make the filename safe, then declare it to be so
                    fname = name.gsub(/[.\/\\\:]/, "_")
                    @loggers[name] = Logger.new(name, @basedir + "/" + fname)
                end
                return @loggers[name]
            end

        end

        FRONT_OBJECT=LoggerFactory.new("/tmp/dlog")

        DRb.start_service(URI, FRONT_OBJECT)
        DRb.thread.join

      ==== Client code

        require 'drb/drb'

        SERVER_URI="druby://localhost:8787"

        DRb.start_service

        log_service=DRbObject.new_with_uri(SERVER_URI)

        ["loga", "logb", "logc"].each do |logname|

            logger=log_service.get_logger(logname)

            logger.log("Hello, world!")
            logger.log("Goodbye, world!")
            logger.log("=== EOT ===")

        end

      == Security

      As with all network services, security needs to be considered when
      using dRuby.  By allowing external access to a Ruby object, you are
      not only allowing outside clients to call the methods you have
      defined for that object, but by default to execute arbitrary Ruby
      code on your server.  Consider the following:

         # !!! UNSAFE CODE !!!
         ro = DRbObject::new_with_uri("druby://your.server.com:8989")
         class << ro
           undef :instance_eval  # force call to be passed to remote object
         end
         ro.instance_eval("`rm -rf *`")

      The dangers posed by instance_eval and friends are such that a
      DRbServer should only be used when clients are trusted.

      A DRbServer can be configured with an access control list to
      selectively allow or deny access from specified IP addresses.  The
      main druby distribution provides the ACL class for this purpose.  In
      general, this mechanism should only be used alongside, rather than
      as a replacement for, a good firewall.

      == dRuby internals

      dRuby is implemented using three main components: a remote method
      call marshaller/unmarshaller; a transport protocol; and an
      ID-to-object mapper.  The latter two can be directly, and the first
      indirectly, replaced, in order to provide different behaviour and
      capabilities.

      Marshalling and unmarshalling of remote method calls is performed by
      a DRb::DRbMessage instance.  This uses the Marshal module to dump
      the method call before sending it over the transport layer, then
      reconstitute it at the other end.  There is normally no need to
      replace this component, and no direct way is provided to do so.
      However, it is possible to implement an alternative marshalling
      scheme as part of an implementation of the transport layer.

      The transport layer is responsible for opening client and server
      network connections and forwarding dRuby request across them.
      Normally, it uses DRb::DRbMessage internally to manage marshalling
      and unmarshalling.  The transport layer is managed by
      DRb::DRbProtocol.  Multiple protocols can be installed in
      DRbProtocol at the one time; selection between them is determined by
      the scheme of a dRuby URI.  The default transport protocol is
      selected by the scheme 'druby:', and implemented by
      DRb::DRbTCPSocket.  This uses plain TCP/IP sockets for
      communication.  An alternative protocol, using UNIX domain sockets,
      is implemented by DRb::DRbUNIXSocket in the file drb/unix.rb, and
      selected by the scheme 'drbunix:'.  A sample implementation over
      HTTP can be found in the samples accompanying the main dRuby
      distribution.

      The ID-to-object mapping component maps dRuby object ids to the
      objects they refer to, and vice versa.  The implementation to use
      can be specified as part of a DRb::DRbServer's configuration.  The
      default implementation is provided by DRb::DRbIdConv.  It uses an
      object's ObjectSpace id as its dRuby id.  This means that the dRuby
      reference to that object only remains meaningful for the lifetime of
      the object's process and the lifetime of the object within that
      process.  A modified implementation is provided by DRb::TimerIdConv
      in the file drb/timeridconv.rb.  This implementation retains a local
      reference to all objects exported over dRuby for a configurable
      period of time (defaulting to ten minutes), to prevent them being
      garbage-collected within this time.  Another sample implementation
      is provided in sample/name.rb in the main dRuby distribution.  This
      allows objects to specify their own id or "name".  A dRuby reference
      can be made persistent across processes by having each process
      register an object using the same dRuby name.
  DRb::DRbArray:
    main: |-
      An Array wrapper that can be sent to another server via DRb.

      All entries in the array will be dumped or be references that point to
      the local server.
  DRb::DRbBadScheme:
    main: |-
      Error raised by a dRuby protocol when it doesn't support the
      scheme specified in a URI.  See DRb::DRbProtocol.
  DRb::DRbBadURI:
    main: |-
      Error raised by the DRbProtocol module when it cannot find any
      protocol implementation support the scheme specified in a URI.
  DRb::DRbConn:
    main: |-
      Class handling the connection between a DRbObject and the
      server the real object lives on.

      This class maintains a pool of connections, to reduce the
      overhead of starting and closing down connections for each
      method call.

      This class is used internally by DRbObject.  The user does
      not normally need to deal with it directly.
  DRb::DRbConnError:
    main: |-
      Error raised when an error occurs on the underlying communication
      protocol.
  DRb::DRbError:
    main: Superclass of all errors raised in the DRb module.
  DRb::DRbIdConv:
    main: |-
      Class responsible for converting between an object and its id.

      This, the default implementation, uses an object's local ObjectSpace
      __id__ as its id.  This means that an object's identification over
      drb remains valid only while that object instance remains alive
      within the server runtime.

      For alternative mechanisms, see DRb::TimerIdConv in drb/timeridconv.rb
      and DRbNameIdConv in sample/name.rb in the full drb distribution.
  DRb::DRbMessage:
    main: |-
      Handler for sending and receiving drb messages.

      This takes care of the low-level marshalling and unmarshalling
      of drb requests and responses sent over the wire between server
      and client.  This relieves the implementor of a new drb
      protocol layer with having to deal with these details.

      The user does not have to directly deal with this object in
      normal use.
  DRb::DRbObject:
    main: |-
      Object wrapping a reference to a remote drb object.

      Method calls on this object are relayed to the remote
      object that this object is a stub for.
  DRb::DRbObservable:
    main: The Observable module extended to DRb.  See Observable for details.
  DRb::DRbProtocol:
    main: |-
      Module managing the underlying network protocol(s) used by drb.

      By default, drb uses the DRbTCPSocket protocol.  Other protocols
      can be defined.  A protocol must define the following class methods:

        [open(uri, config)] Open a client connection to the server at +uri+,
                            using configuration +config+.  Return a protocol
                            instance for this connection.
        [open_server(uri, config)] Open a server listening at +uri+,
                                   using configuration +config+.  Return a
                                   protocol instance for this listener.
        [uri_option(uri, config)] Take a URI, possibly containing an option
                                  component (e.g. a trailing '?param=val'),
                                  and return a [uri, option] tuple.

      All of these methods should raise a DRbBadScheme error if the URI
      does not identify the protocol they support (e.g. "druby:" for
      the standard Ruby protocol).  This is how the DRbProtocol module,
      given a URI, determines which protocol implementation serves that
      protocol.

      The protocol instance returned by #open_server must have the
      following methods:

      [accept] Accept a new connection to the server.  Returns a protocol
               instance capable of communicating with the client.
      [close] Close the server connection.
      [uri] Get the URI for this server.

      The protocol instance returned by #open must have the following methods:

      [send_request (ref, msg_id, arg, b)]
           Send a request to +ref+ with the given message id and arguments.
           This is most easily implemented by calling DRbMessage.send_request,
           providing a stream that sits on top of the current protocol.
      [recv_reply]
           Receive a reply from the server and return it as a [success-boolean,
           reply-value] pair.  This is most easily implemented by calling
           DRb.recv_reply, providing a stream that sits on top of the
           current protocol.
      [alive?]
           Is this connection still alive?
      [close]
           Close this connection.

      The protocol instance returned by #open_server().accept() must have
      the following methods:

      [recv_request]
          Receive a request from the client and return a [object, message,
          args, block] tuple.  This is most easily implemented by calling
          DRbMessage.recv_request, providing a stream that sits on top of
          the current protocol.
      [send_reply(succ, result)]
          Send a reply to the client.  This is most easily implemented
          by calling DRbMessage.send_reply, providing a stream that sits
          on top of the current protocol.
      [close]
          Close this connection.

      A new protocol is registered with the DRbProtocol module using
      the add_protocol method.

      For examples of other protocols, see DRbUNIXSocket in drb/unix.rb,
      and HTTP0 in sample/http0.rb and sample/http0serv.rb in the full
      drb distribution.
  DRb::DRbRemoteError:
    main: An exception wrapping an error object
  DRb::DRbSSLSocket:
    main: |-
      The protocol for DRb over an SSL socket

      The URI for a DRb socket over SSL is:
      <code>drbssl://<host>:<port>?<option></code>.  The option is optional
  DRb::DRbSSLSocket::SSLConfig:
    main: |-
      SSLConfig handles the needed SSL information for establishing a
      DRbSSLSocket connection, including generating the X509 / RSA pair.

      An instance of this config can be passed to DRbSSLSocket.new,
      DRbSSLSocket.open and DRbSSLSocket.open_server

      See DRb::DRbSSLSocket::SSLConfig.new for more details
  DRb::DRbServer:
    main: |-
      Class representing a drb server instance.

      A DRbServer must be running in the local process before any incoming
      dRuby calls can be accepted, or any local objects can be passed as
      dRuby references to remote processes, even if those local objects are
      never actually called remotely. You do not need to start a DRbServer
      in the local process if you are only making outgoing dRuby calls
      passing marshalled parameters.

      Unless multiple servers are being used, the local DRbServer is normally
      started by calling DRb.start_service.
  DRb::DRbServerNotFound:
    main: |-
      Error raised by the DRb module when an attempt is made to refer to
      the context's current drb server but the context does not have one.
      See #current_server.
  DRb::DRbTCPSocket:
    main: |-
      The default drb protocol which communicates over a TCP socket.

      The DRb TCP protocol URI looks like:
      <code>druby://<host>:<port>?<option></code>.  The option is optional.
  DRb::DRbUNIXSocket:
    main: |-
      Implements DRb over a UNIX socket

      DRb UNIX socket URIs look like <code>drbunix:<path>?<option></code>.  The
      option is optional.
  DRb::DRbUndumped:
    main: |-
      Mixin module making an object undumpable or unmarshallable.

      If an object which includes this module is returned by method
      called over drb, then the object remains in the server space
      and a reference to the object is returned, rather than the
      object being marshalled and moved into the client space.
  DRb::DRbUnknown:
    main: |-
      Class wrapping a marshalled object whose type is unknown locally.

      If an object is returned by a method invoked over drb, but the
      class of the object is unknown in the client namespace, or
      the object is a constant unknown in the client namespace, then
      the still-marshalled object is returned wrapped in a DRbUnknown instance.

      If this object is passed as an argument to a method invoked over
      drb, then the wrapped object is passed instead.

      The class or constant name of the object can be read from the
      +name+ attribute.  The marshalled object is held in the +buf+
      attribute.
  DRb::DRbUnknownError:
    main: An exception wrapping a DRb::DRbUnknown object
  DRb::GW:
    main: |-
      The GW provides a synchronized store for participants in the gateway to
      communicate.
  DRb::GWIdConv:
    main: |-
      Gateway id conversion forms a gateway between different DRb protocols or
      networks.

      The gateway needs to install this id conversion and create servers for
      each of the protocols or networks it will be a gateway between.  It then
      needs to create a server that attaches to each of these networks.  For
      example:

        require 'drb/drb'
        require 'drb/unix'
        require 'drb/gw'

        DRb.install_id_conv DRb::GWIdConv.new
        gw = DRb::GW.new
        s1 = DRb::DRbServer.new 'drbunix:/path/to/gateway', gw
        s2 = DRb::DRbServer.new 'druby://example:10000', gw

        s1.thread.join
        s2.thread.join

      Each client must register services with the gateway, for example:

        DRb.start_service 'drbunix:', nil # an anonymous server
        gw = DRbObject.new nil, 'drbunix:/path/to/gateway'
        gw[:unix] = some_service
        DRb.thread.join
  DRb::TimerIdConv:
    main: |-
      Timer id conversion keeps objects alive for a certain amount of time after
      their last access.  The default time period is 600 seconds and can be
      changed upon initialization.

      To use TimerIdConv:

       DRb.install_id_conv TimerIdConv.new 60 # one minute
  DRb::WeakIdConv:
    main: |-
      To use WeakIdConv:

       DRb.start_service(nil, nil, {:idconv => DRb::WeakIdConv.new})
erb:
  ERB:
    main: |-
      = ERB -- Ruby Templating

      == Introduction

      ERB provides an easy to use but powerful templating system for Ruby.  Using
      ERB, actual Ruby code can be added to any plain text document for the
      purposes of generating document information details and/or flow control.

      A very simple example is this:

        require 'erb'

        x = 42
        template = ERB.new <<-EOF
          The value of x is: <%= x %>
        EOF
        puts template.result(binding)

      <em>Prints:</em> The value of x is: 42

      More complex examples are given below.

      == Recognized Tags

      ERB recognizes certain tags in the provided template and converts them based
      on the rules below:

        <% Ruby code -- inline with output %>
        <%= Ruby expression -- replace with result %>
        <%# comment -- ignored -- useful in testing %>
        % a line of Ruby code -- treated as <% line %> (optional -- see ERB.new)
        %% replaced with % if first thing on a line and % processing is used
        <%% or %%> -- replace with <% or %> respectively

      All other text is passed through ERB filtering unchanged.

      == Options

      There are several settings you can change when you use ERB:
      * the nature of the tags that are recognized;
      * the binding used to resolve local variables in the template.

      See the ERB.new and ERB#result methods for more detail.

      == Character encodings

      ERB (or Ruby code generated by ERB) returns a string in the same
      character encoding as the input string.  When the input string has
      a magic comment, however, it returns a string in the encoding specified
      by the magic comment.

        # -*- coding: utf-8 -*-
        require 'erb'

        template = ERB.new <<EOF
        <%#-*- coding: Big5 -*-%>
          \_\_ENCODING\_\_ is <%= \_\_ENCODING\_\_ %>.
        EOF
        puts template.result

      <em>Prints:</em> \_\_ENCODING\_\_ is Big5.

      == Examples

      === Plain Text

      ERB is useful for any generic templating situation.  Note that in this example, we use the
      convenient "% at start of line" tag, and we quote the template literally with
      <tt>%q{...}</tt> to avoid trouble with the backslash.

        require "erb"

        # Create template.
        template = %q{
          From:  James Edward Gray II <james@grayproductions.net>
          To:  <%= to %>
          Subject:  Addressing Needs

          <%= to[/\w+/] %>:

          Just wanted to send a quick note assuring that your needs are being
          addressed.

          I want you to know that my team will keep working on the issues,
          especially:

          <%# ignore numerous minor requests -- focus on priorities %>
          % priorities.each do |priority|
            * <%= priority %>
          % end

          Thanks for your patience.

          James Edward Gray II
        }.gsub(/^  /, '')

        message = ERB.new(template, trim_mode: "%<>")

        # Set up template data.
        to = "Community Spokesman <spokesman@ruby_community.org>"
        priorities = [ "Run Ruby Quiz",
                       "Document Modules",
                       "Answer Questions on Ruby Talk" ]

        # Produce result.
        email = message.result
        puts email

      <i>Generates:</i>

        From:  James Edward Gray II <james@grayproductions.net>
        To:  Community Spokesman <spokesman@ruby_community.org>
        Subject:  Addressing Needs

        Community:

        Just wanted to send a quick note assuring that your needs are being addressed.

        I want you to know that my team will keep working on the issues, especially:

            * Run Ruby Quiz
            * Document Modules
            * Answer Questions on Ruby Talk

        Thanks for your patience.

        James Edward Gray II

      === Ruby in HTML

      ERB is often used in <tt>.rhtml</tt> files (HTML with embedded Ruby).  Notice the need in
      this example to provide a special binding when the template is run, so that the instance
      variables in the Product object can be resolved.

        require "erb"

        # Build template data class.
        class Product
          def initialize( code, name, desc, cost )
            @code = code
            @name = name
            @desc = desc
            @cost = cost

            @features = [ ]
          end

          def add_feature( feature )
            @features << feature
          end

          # Support templating of member data.
          def get_binding
            binding
          end

          # ...
        end

        # Create template.
        template = %{
          <html>
            <head><title>Ruby Toys -- <%= @name %></title></head>
            <body>

              <h1><%= @name %> (<%= @code %>)</h1>
              <p><%= @desc %></p>

              <ul>
                <% @features.each do |f| %>
                  <li><b><%= f %></b></li>
                <% end %>
              </ul>

              <p>
                <% if @cost < 10 %>
                  <b>Only <%= @cost %>!!!</b>
                <% else %>
                   Call for a price, today!
                <% end %>
              </p>

            </body>
          </html>
        }.gsub(/^  /, '')

        rhtml = ERB.new(template)

        # Set up template data.
        toy = Product.new( "TZ-1002",
                           "Rubysapien",
                           "Geek's Best Friend!  Responds to Ruby commands...",
                           999.95 )
        toy.add_feature("Listens for verbal commands in the Ruby language!")
        toy.add_feature("Ignores Perl, Java, and all C variants.")
        toy.add_feature("Karate-Chop Action!!!")
        toy.add_feature("Matz signature on left leg.")
        toy.add_feature("Gem studded eyes... Rubies, of course!")

        # Produce result.
        rhtml.run(toy.get_binding)

      <i>Generates (some blank lines removed):</i>

         <html>
           <head><title>Ruby Toys -- Rubysapien</title></head>
           <body>

             <h1>Rubysapien (TZ-1002)</h1>
             <p>Geek's Best Friend!  Responds to Ruby commands...</p>

             <ul>
                 <li><b>Listens for verbal commands in the Ruby language!</b></li>
                 <li><b>Ignores Perl, Java, and all C variants.</b></li>
                 <li><b>Karate-Chop Action!!!</b></li>
                 <li><b>Matz signature on left leg.</b></li>
                 <li><b>Gem studded eyes... Rubies, of course!</b></li>
             </ul>

             <p>
                  Call for a price, today!
             </p>

           </body>
         </html>

      == Notes

      There are a variety of templating solutions available in various Ruby projects.
      For example, RDoc, distributed with Ruby, uses its own template engine, which
      can be reused elsewhere.

      Other popular engines could be found in the corresponding
      {Category}[https://www.ruby-toolbox.com/categories/template_engines] of
      The Ruby Toolbox.
  ERB::DefMethod:
    main: |-
      Utility module to define eRuby script as instance method.

      === Example

      example.rhtml:
        <% for item in @items %>
        <b><%= item %></b>
        <% end %>

      example.rb:
        require 'erb'
        class MyClass
          extend ERB::DefMethod
          def_erb_method('render()', 'example.rhtml')
          def initialize(items)
            @items = items
          end
        end
        print MyClass.new([10,20,30]).render()

      result:

        <b>10</b>

        <b>20</b>

        <b>30</b>
  ERB::Util:
    main: A utility module for conversion routines, often handy in HTML generation.
fileutils:
  FileUtils:
    main: |-
      = fileutils.rb

      Copyright (c) 2000-2007 Minero Aoki

      This program is free software.
      You can distribute/modify this program under the same terms of ruby.

      == module FileUtils

      Namespace for several file utility methods for copying, moving, removing, etc.

      === Module Functions

        require 'fileutils'

        FileUtils.cd(dir, **options)
        FileUtils.cd(dir, **options) {|dir| block }
        FileUtils.pwd()
        FileUtils.mkdir(dir, **options)
        FileUtils.mkdir(list, **options)
        FileUtils.mkdir_p(dir, **options)
        FileUtils.mkdir_p(list, **options)
        FileUtils.rmdir(dir, **options)
        FileUtils.rmdir(list, **options)
        FileUtils.ln(target, link, **options)
        FileUtils.ln(targets, dir, **options)
        FileUtils.ln_s(target, link, **options)
        FileUtils.ln_s(targets, dir, **options)
        FileUtils.ln_sf(target, link, **options)
        FileUtils.cp(src, dest, **options)
        FileUtils.cp(list, dir, **options)
        FileUtils.cp_r(src, dest, **options)
        FileUtils.cp_r(list, dir, **options)
        FileUtils.mv(src, dest, **options)
        FileUtils.mv(list, dir, **options)
        FileUtils.rm(list, **options)
        FileUtils.rm_r(list, **options)
        FileUtils.rm_rf(list, **options)
        FileUtils.install(src, dest, **options)
        FileUtils.chmod(mode, list, **options)
        FileUtils.chmod_R(mode, list, **options)
        FileUtils.chown(user, group, list, **options)
        FileUtils.chown_R(user, group, list, **options)
        FileUtils.touch(list, **options)

      Possible <tt>options</tt> are:

      <tt>:force</tt> :: forced operation (rewrite files if exist, remove
                         directories if not empty, etc.);
      <tt>:verbose</tt> :: print command to be run, in bash syntax, before
                           performing it;
      <tt>:preserve</tt> :: preserve object's group, user and modification
                            time on copying;
      <tt>:noop</tt> :: no changes are made (usable in combination with
                        <tt>:verbose</tt> which will print the command to run)

      Each method documents the options that it honours. See also ::commands,
      ::options and ::options_of methods to introspect which command have which
      options.

      All methods that have the concept of a "source" file or directory can take
      either one file or a list of files in that argument.  See the method
      documentation for examples.

      There are some `low level' methods, which do not accept keyword arguments:

        FileUtils.copy_entry(src, dest, preserve = false, dereference_root = false, remove_destination = false)
        FileUtils.copy_file(src, dest, preserve = false, dereference = true)
        FileUtils.copy_stream(srcstream, deststream)
        FileUtils.remove_entry(path, force = false)
        FileUtils.remove_entry_secure(path, force = false)
        FileUtils.remove_file(path, force = false)
        FileUtils.compare_file(path_a, path_b)
        FileUtils.compare_stream(stream_a, stream_b)
        FileUtils.uptodate?(file, cmp_list)

      == module FileUtils::Verbose

      This module has all methods of FileUtils module, but it outputs messages
      before acting.  This equates to passing the <tt>:verbose</tt> flag to methods
      in FileUtils.

      == module FileUtils::NoWrite

      This module has all methods of FileUtils module, but never changes
      files/directories.  This equates to passing the <tt>:noop</tt> flag to methods
      in FileUtils.

      == module FileUtils::DryRun

      This module has all methods of FileUtils module, but never changes
      files/directories.  This equates to passing the <tt>:noop</tt> and
      <tt>:verbose</tt> flags to methods in FileUtils.
  FileUtils::DryRun:
    main: |-
      This module has all methods of FileUtils module, but never changes
      files/directories, with printing message before acting.
      This equates to passing the <tt>:noop</tt> and <tt>:verbose</tt> flag
      to methods in FileUtils.
  FileUtils::NoWrite:
    main: |-
      This module has all methods of FileUtils module, but never changes
      files/directories.  This equates to passing the <tt>:noop</tt> flag
      to methods in FileUtils.
  FileUtils::Verbose:
    main: |-
      This module has all methods of FileUtils module, but it outputs messages
      before acting.  This equates to passing the <tt>:verbose</tt> flag to
      methods in FileUtils.
find:
  Find:
    main: |-
      The +Find+ module supports the top-down traversal of a set of file paths.

      For example, to total the size of all files under your home directory,
      ignoring anything in a "dot" directory (e.g. $HOME/.ssh):

        require 'find'

        total_size = 0

        Find.find(ENV["HOME"]) do |path|
          if FileTest.directory?(path)
            if File.basename(path).start_with?('.')
              Find.prune       # Don't look any further into this directory.
            else
              next
            end
          else
            total_size += FileTest.size(path)
          end
        end
forwardable:
  Forwardable:
    main: |-
      The Forwardable module provides delegation of specified
      methods to a designated object, using the methods #def_delegator
      and #def_delegators.

      For example, say you have a class RecordCollection which
      contains an array <tt>@records</tt>.  You could provide the lookup method
      #record_number(), which simply calls #[] on the <tt>@records</tt>
      array, like this:

        require 'forwardable'

        class RecordCollection
          attr_accessor :records
          extend Forwardable
          def_delegator :@records, :[], :record_number
        end

      We can use the lookup method like so:

        r = RecordCollection.new
        r.records = [4,5,6]
        r.record_number(0)  # => 4

      Further, if you wish to provide the methods #size, #<<, and #map,
      all of which delegate to @records, this is how you can do it:

        class RecordCollection # re-open RecordCollection class
          def_delegators :@records, :size, :<<, :map
        end

        r = RecordCollection.new
        r.records = [1,2,3]
        r.record_number(0)   # => 1
        r.size               # => 3
        r << 4               # => [1, 2, 3, 4]
        r.map { |x| x * 2 }  # => [2, 4, 6, 8]

      You can even extend regular objects with Forwardable.

        my_hash = Hash.new
        my_hash.extend Forwardable              # prepare object for delegation
        my_hash.def_delegator "STDOUT", "puts"  # add delegation for STDOUT.puts()
        my_hash.puts "Howdy!"

      == Another example

      You could use Forwardable as an alternative to inheritance, when you don't want
      to inherit all methods from the superclass. For instance, here is how you might
      add a range of +Array+ instance methods to a new class +Queue+:

        class Queue
          extend Forwardable

          def initialize
            @q = [ ]    # prepare delegate object
          end

          # setup preferred interface, enq() and deq()...
          def_delegator :@q, :push, :enq
          def_delegator :@q, :shift, :deq

          # support some general Array methods that fit Queues well
          def_delegators :@q, :clear, :first, :push, :shift, :size
        end

        q = Queue.new
        q.enq 1, 2, 3, 4, 5
        q.push 6

        q.shift    # => 1
        while q.size > 0
          puts q.deq
        end

        q.enq "Ruby", "Perl", "Python"
        puts q.first
        q.clear
        puts q.first

      This should output:

        2
        3
        4
        5
        6
        Ruby
        nil

      == Notes

      Be advised, RDoc will not detect delegated methods.

      +forwardable.rb+ provides single-method delegation via the def_delegator and
      def_delegators methods. For full-class delegation via DelegateClass, see
      +delegate.rb+.
  SingleForwardable:
    main: |-
      SingleForwardable can be used to setup delegation at the object level as well.

         printer = String.new
         printer.extend SingleForwardable        # prepare object for delegation
         printer.def_delegator "STDOUT", "puts"  # add delegation for STDOUT.puts()
         printer.puts "Howdy!"

      Also, SingleForwardable can be used to set up delegation for a Class or Module.

        class Implementation
          def self.service
            puts "serviced!"
          end
        end

        module Facade
          extend SingleForwardable
          def_delegator :Implementation, :service
        end

        Facade.service #=> serviced!

      If you want to use both Forwardable and SingleForwardable, you can
      use methods def_instance_delegator and def_single_delegator, etc.
getoptlong:
  GetoptLong:
    main: |-
      The GetoptLong class allows you to parse command line options similarly to
      the GNU getopt_long() C library call. Note, however, that GetoptLong is a
      pure Ruby implementation.

      GetoptLong allows for POSIX-style options like <tt>--file</tt> as well
      as single letter options like <tt>-f</tt>

      The empty option <tt>--</tt> (two minus symbols) is used to end option
      processing. This can be particularly important if options have optional
      arguments.

      Here is a simple example of usage:

          require 'getoptlong'

          opts = GetoptLong.new(
            [ '--help', '-h', GetoptLong::NO_ARGUMENT ],
            [ '--repeat', '-n', GetoptLong::REQUIRED_ARGUMENT ],
            [ '--name', GetoptLong::OPTIONAL_ARGUMENT ]
          )

          dir = nil
          name = nil
          repetitions = 1
          opts.each do |opt, arg|
            case opt
              when '--help'
                puts <<-EOF
          hello [OPTION] ... DIR

          -h, --help:
             show help

          --repeat x, -n x:
             repeat x times

          --name [name]:
             greet user by name, if name not supplied default is John

          DIR: The directory in which to issue the greeting.
                EOF
              when '--repeat'
                repetitions = arg.to_i
              when '--name'
                if arg == ''
                  name = 'John'
                else
                  name = arg
                end
            end
          end

          if ARGV.length != 1
            puts "Missing dir argument (try --help)"
            exit 0
          end

          dir = ARGV.shift

          Dir.chdir(dir)
          for i in (1..repetitions)
            print "Hello"
            if name
              print ", #{name}"
            end
            puts
          end

      Example command line:

          hello -n 6 --name -- /tmp
  GetoptLong::Error:
    main: Error types.
ipaddr:
  IPAddr:
    main: |-
      IPAddr provides a set of methods to manipulate an IP address.  Both IPv4 and
      IPv6 are supported.

      == Example

        require 'ipaddr'

        ipaddr1 = IPAddr.new "3ffe:505:2::1"

        p ipaddr1                   #=> #<IPAddr: IPv6:3ffe:0505:0002:0000:0000:0000:0000:0001/ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff>

        p ipaddr1.to_s              #=> "3ffe:505:2::1"

        ipaddr2 = ipaddr1.mask(48)  #=> #<IPAddr: IPv6:3ffe:0505:0002:0000:0000:0000:0000:0000/ffff:ffff:ffff:0000:0000:0000:0000:0000>

        p ipaddr2.to_s              #=> "3ffe:505:2::"

        ipaddr3 = IPAddr.new "192.168.2.0/24"

        p ipaddr3                   #=> #<IPAddr: IPv4:192.168.2.0/255.255.255.0>
  IPAddr::AddressFamilyError:
    main: |-
      Raised when the address family is invalid such as an address with an
      unsupported family, an address with an inconsistent family, or an address
      who's family cannot be determined.
  IPAddr::Error:
    main: |-
      Generic IPAddr related error. Exceptions raised in this class should
      inherit from Error.
  IPAddr::InvalidAddressError:
    main: Raised when the provided IP address is an invalid address.
  IPAddr::InvalidPrefixError:
    main: Raised when the address is an invalid length.
irb:
  IRB:
    main: |-
      IRB stands for "interactive Ruby" and is a tool to interactively execute Ruby
      expressions read from the standard input.

      The +irb+ command from your shell will start the interpreter.

      == Usage

      Use of irb is easy if you know Ruby.

      When executing irb, prompts are displayed as follows. Then, enter the Ruby
      expression. An input is executed when it is syntactically complete.

          $ irb
          irb(main):001:0> 1+2
          #=> 3
          irb(main):002:0> class Foo
          irb(main):003:1>  def foo
          irb(main):004:2>    print 1
          irb(main):005:2>  end
          irb(main):006:1> end
          #=> nil

      The singleline editor module or multiline editor module can be used with irb.
      Use of multiline editor is default if it's installed.

      == Command line options

        Usage:  irb.rb [options] [programfile] [arguments]
          -f                Suppress read of ~/.irbrc
          -d                Set $DEBUG to true (same as `ruby -d')
          -r load-module    Same as `ruby -r'
          -I path           Specify $LOAD_PATH directory
          -U                Same as `ruby -U`
          -E enc            Same as `ruby -E`
          -w                Same as `ruby -w`
          -W[level=2]       Same as `ruby -W`
          --inspect         Use `inspect' for output (default except for bc mode)
          --noinspect       Don't use inspect for output
          --multiline       Use multiline editor module
          --nomultiline     Don't use multiline editor module
          --singleline      Use singleline editor module
          --nosingleline    Don't use singleline editor module
          --colorize        Use colorization
          --nocolorize      Don't use colorization
          --prompt prompt-mode
          --prompt-mode prompt-mode
                            Switch prompt mode. Pre-defined prompt modes are
                            `default', `simple', `xmp' and `inf-ruby'
          --inf-ruby-mode   Use prompt appropriate for inf-ruby-mode on emacs.
                            Suppresses --multiline and --singleline.
          --simple-prompt   Simple prompt mode
          --noprompt        No prompt mode
          --tracer          Display trace for each execution of commands.
          --back-trace-limit n
                            Display backtrace top n and tail n. The default
                            value is 16.
          -v, --version     Print the version of irb

      == Configuration

      IRB reads from <code>~/.irbrc</code> when it's invoked.

      If <code>~/.irbrc</code> doesn't exist, +irb+ will try to read in the following order:

      * +.irbrc+
      * +irb.rc+
      * +_irbrc+
      * <code>$irbrc</code>

      The following are alternatives to the command line options. To use them type
      as follows in an +irb+ session:

          IRB.conf[:IRB_NAME]="irb"
          IRB.conf[:INSPECT_MODE]=nil
          IRB.conf[:IRB_RC] = nil
          IRB.conf[:BACK_TRACE_LIMIT]=16
          IRB.conf[:USE_LOADER] = false
          IRB.conf[:USE_MULTILINE] = nil
          IRB.conf[:USE_SINGLELINE] = nil
          IRB.conf[:USE_COLORIZE] = true
          IRB.conf[:USE_TRACER] = false
          IRB.conf[:IGNORE_SIGINT] = true
          IRB.conf[:IGNORE_EOF] = false
          IRB.conf[:PROMPT_MODE] = :DEFAULT
          IRB.conf[:PROMPT] = {...}

      === Auto indentation

      To disable auto-indent mode in irb, add the following to your +.irbrc+:

          IRB.conf[:AUTO_INDENT] = false

      === Autocompletion

      To enable autocompletion for irb, add the following to your +.irbrc+:

          require 'irb/completion'

      === History

      By default, irb will store the last 1000 commands you used in
      <code>IRB.conf[:HISTORY_FILE]</code> (<code>~/.irb_history</code> by default).

      If you want to disable history, add the following to your +.irbrc+:

          IRB.conf[:SAVE_HISTORY] = nil

      See IRB::Context#save_history= for more information.

      The history of _results_ of commands evaluated is not stored by default,
      but can be turned on to be stored with this +.irbrc+ setting:

          IRB.conf[:EVAL_HISTORY] = <number>

      See IRB::Context#eval_history= and History class. The history of command
      results is not permanently saved in any file.

      == Customizing the IRB Prompt

      In order to customize the prompt, you can change the following Hash:

          IRB.conf[:PROMPT]

      This example can be used in your +.irbrc+

          IRB.conf[:PROMPT][:MY_PROMPT] = { # name of prompt mode
            :AUTO_INDENT => false,          # disables auto-indent mode
            :PROMPT_I =>  ">> ",            # simple prompt
            :PROMPT_S => nil,               # prompt for continuated strings
            :PROMPT_C => nil,               # prompt for continuated statement
            :RETURN => "    ==>%s\n"        # format to return value
          }

          IRB.conf[:PROMPT_MODE] = :MY_PROMPT

      Or, invoke irb with the above prompt mode by:

          irb --prompt my-prompt

      Constants +PROMPT_I+, +PROMPT_S+ and +PROMPT_C+ specify the format. In the
      prompt specification, some special strings are available:

          %N    # command name which is running
          %m    # to_s of main object (self)
          %M    # inspect of main object (self)
          %l    # type of string(", ', /, ]), `]' is inner %w[...]
          %NNi  # indent level. NN is digits and means as same as printf("%NNd").
                # It can be omitted
          %NNn  # line number.
          %%    # %

      For instance, the default prompt mode is defined as follows:

          IRB.conf[:PROMPT_MODE][:DEFAULT] = {
            :PROMPT_I => "%N(%m):%03n:%i> ",
            :PROMPT_N => "%N(%m):%03n:%i> ",
            :PROMPT_S => "%N(%m):%03n:%i%l ",
            :PROMPT_C => "%N(%m):%03n:%i* ",
            :RETURN => "%s\n" # used to printf
          }

      irb comes with a number of available modes:

        # :NULL:
        #   :PROMPT_I:
        #   :PROMPT_N:
        #   :PROMPT_S:
        #   :PROMPT_C:
        #   :RETURN: |
        #     %s
        # :DEFAULT:
        #   :PROMPT_I: ! '%N(%m):%03n:%i> '
        #   :PROMPT_N: ! '%N(%m):%03n:%i> '
        #   :PROMPT_S: ! '%N(%m):%03n:%i%l '
        #   :PROMPT_C: ! '%N(%m):%03n:%i* '
        #   :RETURN: |
        #     => %s
        # :CLASSIC:
        #   :PROMPT_I: ! '%N(%m):%03n:%i> '
        #   :PROMPT_N: ! '%N(%m):%03n:%i> '
        #   :PROMPT_S: ! '%N(%m):%03n:%i%l '
        #   :PROMPT_C: ! '%N(%m):%03n:%i* '
        #   :RETURN: |
        #     %s
        # :SIMPLE:
        #   :PROMPT_I: ! '>> '
        #   :PROMPT_N: ! '>> '
        #   :PROMPT_S:
        #   :PROMPT_C: ! '?> '
        #   :RETURN: |
        #     => %s
        # :INF_RUBY:
        #   :PROMPT_I: ! '%N(%m):%03n:%i> '
        #   :PROMPT_N:
        #   :PROMPT_S:
        #   :PROMPT_C:
        #   :RETURN: |
        #     %s
        #   :AUTO_INDENT: true
        # :XMP:
        #   :PROMPT_I:
        #   :PROMPT_N:
        #   :PROMPT_S:
        #   :PROMPT_C:
        #   :RETURN: |2
        #         ==>%s

      == Restrictions

      Because irb evaluates input immediately after it is syntactically complete,
      the results may be slightly different than directly using Ruby.

      == IRB Sessions

      IRB has a special feature, that allows you to manage many sessions at once.

      You can create new sessions with Irb.irb, and get a list of current sessions
      with the +jobs+ command in the prompt.

      === Commands

      JobManager provides commands to handle the current sessions:

        jobs    # List of current sessions
        fg      # Switches to the session of the given number
        kill    # Kills the session with the given number

      The +exit+ command, or ::irb_exit, will quit the current session and call any
      exit hooks with IRB.irb_at_exit.

      A few commands for loading files within the session are also available:

      +source+::
        Loads a given file in the current session and displays the source lines,
        see IrbLoader#source_file
      +irb_load+::
        Loads the given file similarly to Kernel#load, see IrbLoader#irb_load
      +irb_require+::
        Loads the given file similarly to Kernel#require

      === Configuration

      The command line options, or IRB.conf, specify the default behavior of
      Irb.irb.

      On the other hand, each conf in IRB@Command+line+options is used to
      individually configure IRB.irb.

      If a proc is set for IRB.conf[:IRB_RC], its will be invoked after execution
      of that proc with the context of the current session as its argument. Each
      session can be configured using this mechanism.

      === Session variables

      There are a few variables in every Irb session that can come in handy:

      <code>_</code>::
        The value command executed, as a local variable
      <code>__</code>::
        The history of evaluated commands. Available only if
        <code>IRB.conf[:EVAL_HISTORY]</code> is not +nil+ (which is the default).
        See also IRB::Context#eval_history= and IRB::History.
      <code>__[line_no]</code>::
        Returns the evaluation value at the given line number, +line_no+.
        If +line_no+ is a negative, the return value +line_no+ many lines before
        the most recent return value.

      === Example using IRB Sessions

        # invoke a new session
        irb(main):001:0> irb
        # list open sessions
        irb.1(main):001:0> jobs
          #0->irb on main (#<Thread:0x400fb7e4> : stop)
          #1->irb#1 on main (#<Thread:0x40125d64> : running)

        # change the active session
        irb.1(main):002:0> fg 0
        # define class Foo in top-level session
        irb(main):002:0> class Foo;end
        # invoke a new session with the context of Foo
        irb(main):003:0> irb Foo
        # define Foo#foo
        irb.2(Foo):001:0> def foo
        irb.2(Foo):002:1>   print 1
        irb.2(Foo):003:1> end

        # change the active session
        irb.2(Foo):004:0> fg 0
        # list open sessions
        irb(main):004:0> jobs
          #0->irb on main (#<Thread:0x400fb7e4> : running)
          #1->irb#1 on main (#<Thread:0x40125d64> : stop)
          #2->irb#2 on Foo (#<Thread:0x4011d54c> : stop)
        # check if Foo#foo is available
        irb(main):005:0> Foo.instance_methods #=> [:foo, ...]

        # change the active session
        irb(main):006:0> fg 2
        # define Foo#bar in the context of Foo
        irb.2(Foo):005:0> def bar
        irb.2(Foo):006:1>  print "bar"
        irb.2(Foo):007:1> end
        irb.2(Foo):010:0>  Foo.instance_methods #=> [:bar, :foo, ...]

        # change the active session
        irb.2(Foo):011:0> fg 0
        irb(main):007:0> f = Foo.new  #=> #<Foo:0x4010af3c>
        # invoke a new session with the context of f (instance of Foo)
        irb(main):008:0> irb f
        # list open sessions
        irb.3(<Foo:0x4010af3c>):001:0> jobs
          #0->irb on main (#<Thread:0x400fb7e4> : stop)
          #1->irb#1 on main (#<Thread:0x40125d64> : stop)
          #2->irb#2 on Foo (#<Thread:0x4011d54c> : stop)
          #3->irb#3 on #<Foo:0x4010af3c> (#<Thread:0x4010a1e0> : running)
        # evaluate f.foo
        irb.3(<Foo:0x4010af3c>):002:0> foo #=> 1 => nil
        # evaluate f.bar
        irb.3(<Foo:0x4010af3c>):003:0> bar #=> bar => nil
        # kill jobs 1, 2, and 3
        irb.3(<Foo:0x4010af3c>):004:0> kill 1, 2, 3
        # list open sessions, should only include main session
        irb(main):009:0> jobs
          #0->irb on main (#<Thread:0x400fb7e4> : running)
        # quit irb
        irb(main):010:0> exit
  IRB::Abort:
    main: An exception raised by IRB.irb_abort
  IRB::Color::SymbolState:
    main: A class to manage a state to know whether the current token is for Symbol
      or not.
  IRB::Context:
    main: |-
      A class that wraps the current state of the irb session, including the
      configuration of IRB.conf.
  IRB::ContextExtender:
    main: Extends methods for the Context module
  IRB::ExtendCommandBundle:
    main: Installs the default irb extensions command bundle.
  IRB::FileInputMethod:
    main: Use a File for IO with irb, see InputMethod
  IRB::History:
    main: |-
      Represents history of results of previously evaluated commands.

      Available via <code>__</code> variable, only if <code>IRB.conf[:EVAL_HISTORY]</code>
      or <code>IRB::CurrentContext().eval_history</code> is non-nil integer value
      (by default it is +nil+).

      Example (in `irb`):

         # Initialize history
         IRB::CurrentContext().eval_history = 10
         # => 10

         # Perform some commands...
         1 + 2
         # => 3
         puts 'x'
         # x
         # => nil
         raise RuntimeError
         # ...error raised

         # Inspect history (format is "<item number> <evaluated value>":
         __
         # => 1 10
         # 2 3
         # 3 nil

         __[1]
         # => 10
  IRB::Inspector:
    main: |-
      An irb inspector

      In order to create your own custom inspector there are two things you
      should be aware of:

      Inspector uses #inspect_value, or +inspect_proc+, for output of return values.

      This also allows for an optional #init+, or +init_proc+, which is called
      when the inspector is activated.

      Knowing this, you can create a rudimentary inspector as follows:

          irb(main):001:0> ins = IRB::Inspector.new(proc{ |v| "omg! #{v}" })
          irb(main):001:0> IRB.CurrentContext.inspect_mode = ins # => omg! #<IRB::Inspector:0x007f46f7ba7d28>
          irb(main):001:0> "what?" #=> omg! what?
  IRB::IrbLoader:
    main: |-
      Provides a few commands for loading files within an irb session.

      See ExtendCommandBundle for more information.
  IRB::LoadAbort:
    main: Raised in the event of an exception in a file loaded from an Irb session
  IRB::MethodExtender:
    main: A convenience module for extending Ruby methods.
  IRB::Notifier:
    main: An output formatter used internally by the lexer.
  IRB::Notifier::AbstractNotifier:
    main: |-
      An abstract class, or superclass, for CompositeNotifier and
      LeveledNotifier to inherit. It provides several wrapper methods for the
      OutputMethod object used by the Notifier.
  IRB::Notifier::CompositeNotifier:
    main: |-
      A class that can be used to create a group of notifier objects with the
      intent of representing a leveled notification system for irb.

      This class will allow you to generate other notifiers, and assign them
      the appropriate level for output.

      The Notifier class provides a class-method Notifier.def_notifier to
      create a new composite notifier. Using the first composite notifier
      object you create, sibling notifiers can be initialized with
      #def_notifier.
  IRB::Notifier::LeveledNotifier:
    main: |-
      A leveled notifier is comparable to the composite group from
      CompositeNotifier#notifiers.
  IRB::Notifier::NoMsgNotifier:
    main: |-
      NoMsgNotifier is a LeveledNotifier that's used as the default notifier
      when creating a new CompositeNotifier.

      This notifier is used as the +zero+ index, or level +0+, for
      CompositeNotifier#notifiers, and will not output messages of any sort.
  IRB::OutputMethod:
    main: |-
      An abstract output class for IO in irb. This is mainly used internally by
      IRB::Notifier. You can define your own output method to use with Irb.new,
      or Context.new
  IRB::StdioOutputMethod:
    main: A standard output printer
  XMP:
    main: |-
      An example printer for irb.

      It's much like the standard library PrettyPrint, that shows the value of each
      expression as it runs.

      In order to use this library, you must first require it:

          require 'irb/xmp'

      Now, you can take advantage of the Object#xmp convenience method.

          xmp <<END
            foo = "bar"
            baz = 42
          END
          #=> foo = "bar"
            #==>"bar"
          #=> baz = 42
            #==>42

      You can also create an XMP object, with an optional binding to print
      expressions in the given binding:

          ctx = binding
          x = XMP.new ctx
          x.puts
          #=> today = "a good day"
            #==>"a good day"
          ctx.eval 'today # is what?'
          #=> "a good day"
  XMP::StringInputMethod:
    main: A custom InputMethod class used by XMP for evaluating string io.
logger:
  Logger:
    main: |-
      == Description

      The Logger class provides a simple but sophisticated logging utility that
      you can use to output messages.

      The messages have associated levels, such as +INFO+ or +ERROR+ that indicate
      their importance.  You can then give the Logger a level, and only messages
      at that level or higher will be printed.

      The levels are:

      +UNKNOWN+:: An unknown message that should always be logged.
      +FATAL+:: An unhandleable error that results in a program crash.
      +ERROR+:: A handleable error condition.
      +WARN+::  A warning.
      +INFO+::  Generic (useful) information about system operation.
      +DEBUG+:: Low-level information for developers.

      For instance, in a production system, you may have your Logger set to
      +INFO+ or even +WARN+.
      When you are developing the system, however, you probably
      want to know about the program's internal state, and would set the Logger to
      +DEBUG+.

      *Note*: Logger does not escape or sanitize any messages passed to it.
      Developers should be aware of when potentially malicious data (user-input)
      is passed to Logger, and manually escape the untrusted data:

        logger.info("User-input: #{input.dump}")
        logger.info("User-input: %p" % input)

      You can use #formatter= for escaping all data.

        original_formatter = Logger::Formatter.new
        logger.formatter = proc { |severity, datetime, progname, msg|
          original_formatter.call(severity, datetime, progname, msg.dump)
        }
        logger.info(input)

      === Example

      This creates a Logger that outputs to the standard output stream, with a
      level of +WARN+:

        require 'logger'

        logger = Logger.new(STDOUT)
        logger.level = Logger::WARN

        logger.debug("Created logger")
        logger.info("Program started")
        logger.warn("Nothing to do!")

        path = "a_non_existent_file"

        begin
          File.foreach(path) do |line|
            unless line =~ /^(\w+) = (.*)$/
              logger.error("Line in wrong format: #{line.chomp}")
            end
          end
        rescue => err
          logger.fatal("Caught exception; exiting")
          logger.fatal(err)
        end

      Because the Logger's level is set to +WARN+, only the warning, error, and
      fatal messages are recorded.  The debug and info messages are silently
      discarded.

      === Features

      There are several interesting features that Logger provides, like
      auto-rolling of log files, setting the format of log messages, and
      specifying a program name in conjunction with the message.  The next section
      shows you how to achieve these things.

      == HOWTOs

      === How to create a logger

      The options below give you various choices, in more or less increasing
      complexity.

      1. Create a logger which logs messages to STDERR/STDOUT.

           logger = Logger.new(STDERR)
           logger = Logger.new(STDOUT)

      2. Create a logger for the file which has the specified name.

           logger = Logger.new('logfile.log')

      3. Create a logger for the specified file.

           file = File.open('foo.log', File::WRONLY | File::APPEND)
           # To create new logfile, add File::CREAT like:
           # file = File.open('foo.log', File::WRONLY | File::APPEND | File::CREAT)
           logger = Logger.new(file)

      4. Create a logger which ages the logfile once it reaches a certain size.
         Leave 10 "old" log files where each file is about 1,024,000 bytes.

           logger = Logger.new('foo.log', 10, 1024000)

      5. Create a logger which ages the logfile daily/weekly/monthly.

           logger = Logger.new('foo.log', 'daily')
           logger = Logger.new('foo.log', 'weekly')
           logger = Logger.new('foo.log', 'monthly')

      === How to log a message

      Notice the different methods (+fatal+, +error+, +info+) being used to log
      messages of various levels?  Other methods in this family are +warn+ and
      +debug+.  +add+ is used below to log a message of an arbitrary (perhaps
      dynamic) level.

      1. Message in a block.

           logger.fatal { "Argument 'foo' not given." }

      2. Message as a string.

           logger.error "Argument #{@foo} mismatch."

      3. With progname.

           logger.info('initialize') { "Initializing..." }

      4. With severity.

           logger.add(Logger::FATAL) { 'Fatal error!' }

      The block form allows you to create potentially complex log messages,
      but to delay their evaluation until and unless the message is
      logged.  For example, if we have the following:

          logger.debug { "This is a " + potentially + " expensive operation" }

      If the logger's level is +INFO+ or higher, no debug messages will be logged,
      and the entire block will not even be evaluated.  Compare to this:

          logger.debug("This is a " + potentially + " expensive operation")

      Here, the string concatenation is done every time, even if the log
      level is not set to show the debug message.

      === How to close a logger

           logger.close

      === Setting severity threshold

      1. Original interface.

           logger.sev_threshold = Logger::WARN

      2. Log4r (somewhat) compatible interface.

           logger.level = Logger::INFO

           # DEBUG < INFO < WARN < ERROR < FATAL < UNKNOWN

      3. Symbol or String (case insensitive)

           logger.level = :info
           logger.level = 'INFO'

           # :debug < :info < :warn < :error < :fatal < :unknown

      4. Constructor

           Logger.new(logdev, level: Logger::INFO)
           Logger.new(logdev, level: :info)
           Logger.new(logdev, level: 'INFO')

      == Format

      Log messages are rendered in the output stream in a certain format by
      default.  The default format and a sample are shown below:

      Log format:
        SeverityID, [DateTime #pid] SeverityLabel -- ProgName: message

      Log sample:
        I, [1999-03-03T02:34:24.895701 #19074]  INFO -- Main: info.

      You may change the date and time format via #datetime_format=.

        logger.datetime_format = '%Y-%m-%d %H:%M:%S'
              # e.g. "2004-01-03 00:54:26"

      or via the constructor.

        Logger.new(logdev, datetime_format: '%Y-%m-%d %H:%M:%S')

      Or, you may change the overall format via the #formatter= method.

        logger.formatter = proc do |severity, datetime, progname, msg|
          "#{datetime}: #{msg}\n"
        end
        # e.g. "2005-09-22 08:51:08 +0900: hello world"

      or via the constructor.

        Logger.new(logdev, formatter: proc {|severity, datetime, progname, msg|
          "#{datetime}: #{msg}\n"
        })
matrix:
  Matrix:
    main: |-
      The +Matrix+ class represents a mathematical matrix. It provides methods for creating
      matrices, operating on them arithmetically and algebraically,
      and determining their mathematical properties such as trace, rank, inverse, determinant,
      or eigensystem.
  Matrix::EigenvalueDecomposition:
    main: |-
      Eigenvalues and eigenvectors of a real matrix.

      Computes the eigenvalues and eigenvectors of a matrix A.

      If A is diagonalizable, this provides matrices V and D
      such that A = V*D*V.inv, where D is the diagonal matrix with entries
      equal to the eigenvalues and V is formed by the eigenvectors.

      If A is symmetric, then V is orthogonal and thus A = V*D*V.t
  Matrix::LUPDecomposition:
    main: |-
      For an m-by-n matrix A with m >= n, the LU decomposition is an m-by-n
      unit lower triangular matrix L, an n-by-n upper triangular matrix U,
      and a m-by-m permutation matrix P so that L*U = P*A.
      If m < n, then L is m-by-m and U is m-by-n.

      The LUP decomposition with pivoting always exists, even if the matrix is
      singular, so the constructor will never fail.  The primary use of the
      LU decomposition is in the solution of square systems of simultaneous
      linear equations.  This will fail if singular? returns true.
  Vector:
    main: |-
      The +Vector+ class represents a mathematical vector, which is useful in its own right, and
      also constitutes a row or column of a Matrix.

      == Method Catalogue

      To create a Vector:
      * Vector.[](*array)
      * Vector.elements(array, copy = true)
      * Vector.basis(size: n, index: k)
      * Vector.zero(n)

      To access elements:
      * #[](i)

      To set elements:
      * #[]=(i, v)

      To enumerate the elements:
      * #each2(v)
      * #collect2(v)

      Properties of vectors:
      * #angle_with(v)
      * Vector.independent?(*vs)
      * #independent?(*vs)
      * #zero?

      Vector arithmetic:
      * #*(x) "is matrix or number"
      * #+(v)
      * #-(v)
      * #/(v)
      * #+@
      * #-@

      Vector functions:
      * #inner_product(v), dot(v)
      * #cross_product(v), cross(v)
      * #collect
      * #collect!
      * #magnitude
      * #map
      * #map!
      * #map2(v)
      * #norm
      * #normalize
      * #r
      * #round
      * #size

      Conversion to other data types:
      * #covector
      * #to_a
      * #coerce(other)

      String representations:
      * #to_s
      * #inspect
mkmf:
  MakeMakefile:
    main: |-
      mkmf.rb is used by Ruby C extensions to generate a Makefile which will
      correctly compile and link the C extension to Ruby and a third-party
      library.
mutex_m:
  Mutex_m:
    main: |-
      = mutex_m.rb

      When 'mutex_m' is required, any object that extends or includes Mutex_m will
      be treated like a Mutex.

      Start by requiring the standard library Mutex_m:

        require "mutex_m.rb"

      From here you can extend an object with Mutex instance methods:

        obj = Object.new
        obj.extend Mutex_m

      Or mixin Mutex_m into your module to your class inherit Mutex instance
      methods --- remember to call super() in your class initialize method.

        class Foo
          include Mutex_m
          def initialize
            # ...
            super()
          end
          # ...
        end
        obj = Foo.new
        # this obj can be handled like Mutex
net/ftp:
  Net::FTP:
    main: |-
      This class implements the File Transfer Protocol.  If you have used a
      command-line FTP program, and are familiar with the commands, you will be
      able to use this class easily.  Some extra features are included to take
      advantage of Ruby's style and strengths.

      == Example

        require 'net/ftp'

      === Example 1

        ftp = Net::FTP.new('example.com')
        ftp.login
        files = ftp.chdir('pub/lang/ruby/contrib')
        files = ftp.list('n*')
        ftp.getbinaryfile('nif.rb-0.91.gz', 'nif.gz', 1024)
        ftp.close

      === Example 2

        Net::FTP.open('example.com') do |ftp|
          ftp.login
          files = ftp.chdir('pub/lang/ruby/contrib')
          files = ftp.list('n*')
          ftp.getbinaryfile('nif.rb-0.91.gz', 'nif.gz', 1024)
        end

      == Major Methods

      The following are the methods most likely to be useful to users:
      - FTP.open
      - #getbinaryfile
      - #gettextfile
      - #putbinaryfile
      - #puttextfile
      - #chdir
      - #nlst
      - #size
      - #rename
      - #delete
  Net::FTP::MLSxEntry:
    main: |-
      MLSxEntry represents an entry in responses of MLST/MLSD.
      Each entry has the facts (e.g., size, last modification time, etc.)
      and the pathname.
net/http:
  Net::HTTP:
    main: |-
      == An HTTP client API for Ruby.

      Net::HTTP provides a rich library which can be used to build HTTP
      user-agents.  For more details about HTTP see
      [RFC2616](http://www.ietf.org/rfc/rfc2616.txt).

      Net::HTTP is designed to work closely with URI.  URI::HTTP#host,
      URI::HTTP#port and URI::HTTP#request_uri are designed to work with
      Net::HTTP.

      If you are only performing a few GET requests you should try OpenURI.

      == Simple Examples

      All examples assume you have loaded Net::HTTP with:

        require 'net/http'

      This will also require 'uri' so you don't need to require it separately.

      The Net::HTTP methods in the following section do not persist
      connections.  They are not recommended if you are performing many HTTP
      requests.

      === GET

        Net::HTTP.get('example.com', '/index.html') # => String

      === GET by URI

        uri = URI('http://example.com/index.html?count=10')
        Net::HTTP.get(uri) # => String

      === GET with Dynamic Parameters

        uri = URI('http://example.com/index.html')
        params = { :limit => 10, :page => 3 }
        uri.query = URI.encode_www_form(params)

        res = Net::HTTP.get_response(uri)
        puts res.body if res.is_a?(Net::HTTPSuccess)

      === POST

        uri = URI('http://www.example.com/search.cgi')
        res = Net::HTTP.post_form(uri, 'q' => 'ruby', 'max' => '50')
        puts res.body

      === POST with Multiple Values

        uri = URI('http://www.example.com/search.cgi')
        res = Net::HTTP.post_form(uri, 'q' => ['ruby', 'perl'], 'max' => '50')
        puts res.body

      == How to use Net::HTTP

      The following example code can be used as the basis of an HTTP user-agent
      which can perform a variety of request types using persistent
      connections.

        uri = URI('http://example.com/some_path?query=string')

        Net::HTTP.start(uri.host, uri.port) do |http|
          request = Net::HTTP::Get.new uri

          response = http.request request # Net::HTTPResponse object
        end

      Net::HTTP::start immediately creates a connection to an HTTP server which
      is kept open for the duration of the block.  The connection will remain
      open for multiple requests in the block if the server indicates it
      supports persistent connections.

      If you wish to re-use a connection across multiple HTTP requests without
      automatically closing it you can use ::new and then call #start and
      #finish manually.

      The request types Net::HTTP supports are listed below in the section "HTTP
      Request Classes".

      For all the Net::HTTP request objects and shortcut request methods you may
      supply either a String for the request path or a URI from which Net::HTTP
      will extract the request path.

      === Response Data

        uri = URI('http://example.com/index.html')
        res = Net::HTTP.get_response(uri)

        # Headers
        res['Set-Cookie']            # => String
        res.get_fields('set-cookie') # => Array
        res.to_hash['set-cookie']    # => Array
        puts "Headers: #{res.to_hash.inspect}"

        # Status
        puts res.code       # => '200'
        puts res.message    # => 'OK'
        puts res.class.name # => 'HTTPOK'

        # Body
        puts res.body if res.response_body_permitted?

      === Following Redirection

      Each Net::HTTPResponse object belongs to a class for its response code.

      For example, all 2XX responses are instances of a Net::HTTPSuccess
      subclass, a 3XX response is an instance of a Net::HTTPRedirection
      subclass and a 200 response is an instance of the Net::HTTPOK class.  For
      details of response classes, see the section "HTTP Response Classes"
      below.

      Using a case statement you can handle various types of responses properly:

        def fetch(uri_str, limit = 10)
          # You should choose a better exception.
          raise ArgumentError, 'too many HTTP redirects' if limit == 0

          response = Net::HTTP.get_response(URI(uri_str))

          case response
          when Net::HTTPSuccess then
            response
          when Net::HTTPRedirection then
            location = response['location']
            warn "redirected to #{location}"
            fetch(location, limit - 1)
          else
            response.value
          end
        end

        print fetch('http://www.ruby-lang.org')

      === POST

      A POST can be made using the Net::HTTP::Post request class.  This example
      creates a URL encoded POST body:

        uri = URI('http://www.example.com/todo.cgi')
        req = Net::HTTP::Post.new(uri)
        req.set_form_data('from' => '2005-01-01', 'to' => '2005-03-31')

        res = Net::HTTP.start(uri.hostname, uri.port) do |http|
          http.request(req)
        end

        case res
        when Net::HTTPSuccess, Net::HTTPRedirection
          # OK
        else
          res.value
        end

      To send multipart/form-data use Net::HTTPHeader#set_form:

        req = Net::HTTP::Post.new(uri)
        req.set_form([['upload', File.open('foo.bar')]], 'multipart/form-data')

      Other requests that can contain a body such as PUT can be created in the
      same way using the corresponding request class (Net::HTTP::Put).

      === Setting Headers

      The following example performs a conditional GET using the
      If-Modified-Since header.  If the files has not been modified since the
      time in the header a Not Modified response will be returned.  See RFC 2616
      section 9.3 for further details.

        uri = URI('http://example.com/cached_response')
        file = File.stat 'cached_response'

        req = Net::HTTP::Get.new(uri)
        req['If-Modified-Since'] = file.mtime.rfc2822

        res = Net::HTTP.start(uri.hostname, uri.port) {|http|
          http.request(req)
        }

        open 'cached_response', 'w' do |io|
          io.write res.body
        end if res.is_a?(Net::HTTPSuccess)

      === Basic Authentication

      Basic authentication is performed according to
      [RFC2617](http://www.ietf.org/rfc/rfc2617.txt).

        uri = URI('http://example.com/index.html?key=value')

        req = Net::HTTP::Get.new(uri)
        req.basic_auth 'user', 'pass'

        res = Net::HTTP.start(uri.hostname, uri.port) {|http|
          http.request(req)
        }
        puts res.body

      === Streaming Response Bodies

      By default Net::HTTP reads an entire response into memory.  If you are
      handling large files or wish to implement a progress bar you can instead
      stream the body directly to an IO.

        uri = URI('http://example.com/large_file')

        Net::HTTP.start(uri.host, uri.port) do |http|
          request = Net::HTTP::Get.new uri

          http.request request do |response|
            open 'large_file', 'w' do |io|
              response.read_body do |chunk|
                io.write chunk
              end
            end
          end
        end

      === HTTPS

      HTTPS is enabled for an HTTP connection by Net::HTTP#use_ssl=.

        uri = URI('https://secure.example.com/some_path?query=string')

        Net::HTTP.start(uri.host, uri.port, :use_ssl => true) do |http|
          request = Net::HTTP::Get.new uri
          response = http.request request # Net::HTTPResponse object
        end

      Or if you simply want to make a GET request, you may pass in an URI
      object that has an HTTPS URL. Net::HTTP automatically turns on TLS
      verification if the URI object has a 'https' URI scheme.

        uri = URI('https://example.com/')
        Net::HTTP.get(uri) # => String

      In previous versions of Ruby you would need to require 'net/https' to use
      HTTPS. This is no longer true.

      === Proxies

      Net::HTTP will automatically create a proxy from the +http_proxy+
      environment variable if it is present.  To disable use of +http_proxy+,
      pass +nil+ for the proxy address.

      You may also create a custom proxy:

        proxy_addr = 'your.proxy.host'
        proxy_port = 8080

        Net::HTTP.new('example.com', nil, proxy_addr, proxy_port).start { |http|
          # always proxy via your.proxy.addr:8080
        }

      See Net::HTTP.new for further details and examples such as proxies that
      require a username and password.

      === Compression

      Net::HTTP automatically adds Accept-Encoding for compression of response
      bodies and automatically decompresses gzip and deflate responses unless a
      Range header was sent.

      Compression can be disabled through the Accept-Encoding: identity header.

      == HTTP Request Classes

      Here is the HTTP request class hierarchy.

      * Net::HTTPRequest
        * Net::HTTP::Get
        * Net::HTTP::Head
        * Net::HTTP::Post
        * Net::HTTP::Patch
        * Net::HTTP::Put
        * Net::HTTP::Proppatch
        * Net::HTTP::Lock
        * Net::HTTP::Unlock
        * Net::HTTP::Options
        * Net::HTTP::Propfind
        * Net::HTTP::Delete
        * Net::HTTP::Move
        * Net::HTTP::Copy
        * Net::HTTP::Mkcol
        * Net::HTTP::Trace

      == HTTP Response Classes

      Here is HTTP response class hierarchy.  All classes are defined in Net
      module and are subclasses of Net::HTTPResponse.

      HTTPUnknownResponse:: For unhandled HTTP extensions
      HTTPInformation::                    1xx
        HTTPContinue::                        100
        HTTPSwitchProtocol::                  101
      HTTPSuccess::                        2xx
        HTTPOK::                              200
        HTTPCreated::                         201
        HTTPAccepted::                        202
        HTTPNonAuthoritativeInformation::     203
        HTTPNoContent::                       204
        HTTPResetContent::                    205
        HTTPPartialContent::                  206
        HTTPMultiStatus::                     207
        HTTPIMUsed::                          226
      HTTPRedirection::                    3xx
        HTTPMultipleChoices::                 300
        HTTPMovedPermanently::                301
        HTTPFound::                           302
        HTTPSeeOther::                        303
        HTTPNotModified::                     304
        HTTPUseProxy::                        305
        HTTPTemporaryRedirect::               307
      HTTPClientError::                    4xx
        HTTPBadRequest::                      400
        HTTPUnauthorized::                    401
        HTTPPaymentRequired::                 402
        HTTPForbidden::                       403
        HTTPNotFound::                        404
        HTTPMethodNotAllowed::                405
        HTTPNotAcceptable::                   406
        HTTPProxyAuthenticationRequired::     407
        HTTPRequestTimeOut::                  408
        HTTPConflict::                        409
        HTTPGone::                            410
        HTTPLengthRequired::                  411
        HTTPPreconditionFailed::              412
        HTTPRequestEntityTooLarge::           413
        HTTPRequestURITooLong::               414
        HTTPUnsupportedMediaType::            415
        HTTPRequestedRangeNotSatisfiable::    416
        HTTPExpectationFailed::               417
        HTTPUnprocessableEntity::             422
        HTTPLocked::                          423
        HTTPFailedDependency::                424
        HTTPUpgradeRequired::                 426
        HTTPPreconditionRequired::            428
        HTTPTooManyRequests::                 429
        HTTPRequestHeaderFieldsTooLarge::     431
        HTTPUnavailableForLegalReasons::      451
      HTTPServerError::                    5xx
        HTTPInternalServerError::             500
        HTTPNotImplemented::                  501
        HTTPBadGateway::                      502
        HTTPServiceUnavailable::              503
        HTTPGatewayTimeOut::                  504
        HTTPVersionNotSupported::             505
        HTTPInsufficientStorage::             507
        HTTPNetworkAuthenticationRequired::   511

      There is also the Net::HTTPBadResponse exception which is raised when
      there is a protocol error.
  Net::HTTP::Copy:
    main: See Net::HTTPGenericRequest for attributes and methods.
  Net::HTTP::Delete:
    main: |-
      See Net::HTTPGenericRequest for attributes and methods.
      See Net::HTTP for usage examples.
  Net::HTTP::Get:
    main: |-
      See Net::HTTPGenericRequest for attributes and methods.
      See Net::HTTP for usage examples.
  Net::HTTP::Head:
    main: |-
      See Net::HTTPGenericRequest for attributes and methods.
      See Net::HTTP for usage examples.
  Net::HTTP::Lock:
    main: See Net::HTTPGenericRequest for attributes and methods.
  Net::HTTP::Mkcol:
    main: See Net::HTTPGenericRequest for attributes and methods.
  Net::HTTP::Move:
    main: See Net::HTTPGenericRequest for attributes and methods.
  Net::HTTP::Options:
    main: See Net::HTTPGenericRequest for attributes and methods.
  Net::HTTP::Patch:
    main: See Net::HTTPGenericRequest for attributes and methods.
  Net::HTTP::Post:
    main: |-
      See Net::HTTPGenericRequest for attributes and methods.
      See Net::HTTP for usage examples.
  Net::HTTP::Propfind:
    main: See Net::HTTPGenericRequest for attributes and methods.
  Net::HTTP::Proppatch:
    main: See Net::HTTPGenericRequest for attributes and methods.
  Net::HTTP::Put:
    main: |-
      See Net::HTTPGenericRequest for attributes and methods.
      See Net::HTTP for usage examples.
  Net::HTTP::Trace:
    main: See Net::HTTPGenericRequest for attributes and methods.
  Net::HTTP::Unlock:
    main: See Net::HTTPGenericRequest for attributes and methods.
  Net::HTTPExceptions:
    main: |-
      Net::HTTP exception class.
      You cannot use Net::HTTPExceptions directly; instead, you must use
      its subclasses.
  Net::HTTPGenericRequest:
    main: |-
      HTTPGenericRequest is the parent of the Net::HTTPRequest class.
      Do not use this directly; use a subclass of Net::HTTPRequest.

      Mixes in the Net::HTTPHeader module to provide easier access to HTTP headers.
  Net::HTTPHeader:
    main: |-
      The HTTPHeader module defines methods for reading and writing
      HTTP headers.

      It is used as a mixin by other classes, to provide hash-like
      access to HTTP header values. Unlike raw hash access, HTTPHeader
      provides access via case-insensitive keys. It also provides
      methods for accessing commonly-used HTTP header values in more
      convenient formats.
  Net::HTTPInternalServerError:
    main: |-
      444 No Response - Nginx
      449 Retry With - Microsoft
      450 Blocked by Windows Parental Controls - Microsoft
      499 Client Closed Request - Nginx
  Net::HTTPMisdirectedRequest:
    main: |-
      418 I'm a teapot - RFC 2324; a joke RFC
      420 Enhance Your Calm - Twitter
  Net::HTTPNotExtended:
    main: 509 Bandwidth Limit Exceeded - Apache bw/limited extension
  Net::HTTPRequest:
    main: |-
      HTTP request class.
      This class wraps together the request header and the request path.
      You cannot use this class directly. Instead, you should use one of its
      subclasses: Net::HTTP::Get, Net::HTTP::Post, Net::HTTP::Head.
  Net::HTTPResponse:
    main: |-
      HTTP response class.

      This class wraps together the response header and the response body (the
      entity requested).

      It mixes in the HTTPHeader module, which provides access to response
      header values both via hash-like methods and via individual readers.

      Note that each possible HTTP response code defines its own
      HTTPResponse subclass. All classes are defined under the Net module.
      Indentation indicates inheritance.  For a list of the classes see Net::HTTP.

      Correspondence <code>HTTP code => class</code> is stored in CODE_TO_OBJ
      constant:

         Net::HTTPResponse::CODE_TO_OBJ['404'] #=> Net::HTTPNotFound
  Net::HTTPTemporaryRedirect:
    main: 306 Switch Proxy - no longer unused
  Net::HTTPUnknownResponse:
    main: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml
  Net::HTTPUpgradeRequired:
    main: 425 Unordered Collection - existed only in draft
net/https: {}
net/imap:
  Net::IMAP:
    main: |-
      Net::IMAP implements Internet Message Access Protocol (IMAP) client
      functionality.  The protocol is described in [IMAP].

      == IMAP Overview

      An IMAP client connects to a server, and then authenticates
      itself using either #authenticate() or #login().  Having
      authenticated itself, there is a range of commands
      available to it.  Most work with mailboxes, which may be
      arranged in an hierarchical namespace, and each of which
      contains zero or more messages.  How this is implemented on
      the server is implementation-dependent; on a UNIX server, it
      will frequently be implemented as files in mailbox format
      within a hierarchy of directories.

      To work on the messages within a mailbox, the client must
      first select that mailbox, using either #select() or (for
      read-only access) #examine().  Once the client has successfully
      selected a mailbox, they enter _selected_ state, and that
      mailbox becomes the _current_ mailbox, on which mail-item
      related commands implicitly operate.

      Messages have two sorts of identifiers: message sequence
      numbers and UIDs.

      Message sequence numbers number messages within a mailbox
      from 1 up to the number of items in the mailbox.  If a new
      message arrives during a session, it receives a sequence
      number equal to the new size of the mailbox.  If messages
      are expunged from the mailbox, remaining messages have their
      sequence numbers "shuffled down" to fill the gaps.

      UIDs, on the other hand, are permanently guaranteed not to
      identify another message within the same mailbox, even if
      the existing message is deleted.  UIDs are required to
      be assigned in ascending (but not necessarily sequential)
      order within a mailbox; this means that if a non-IMAP client
      rearranges the order of mailitems within a mailbox, the
      UIDs have to be reassigned.  An IMAP client thus cannot
      rearrange message orders.

      == Examples of Usage

      === List sender and subject of all recent messages in the default mailbox

        imap = Net::IMAP.new('mail.example.com')
        imap.authenticate('LOGIN', 'joe_user', 'joes_password')
        imap.examine('INBOX')
        imap.search(["RECENT"]).each do |message_id|
          envelope = imap.fetch(message_id, "ENVELOPE")[0].attr["ENVELOPE"]
          puts "#{envelope.from[0].name}: \t#{envelope.subject}"
        end

      === Move all messages from April 2003 from "Mail/sent-mail" to "Mail/sent-apr03"

        imap = Net::IMAP.new('mail.example.com')
        imap.authenticate('LOGIN', 'joe_user', 'joes_password')
        imap.select('Mail/sent-mail')
        if not imap.list('Mail/', 'sent-apr03')
          imap.create('Mail/sent-apr03')
        end
        imap.search(["BEFORE", "30-Apr-2003", "SINCE", "1-Apr-2003"]).each do |message_id|
          imap.copy(message_id, "Mail/sent-apr03")
          imap.store(message_id, "+FLAGS", [:Deleted])
        end
        imap.expunge

      == Thread Safety

      Net::IMAP supports concurrent threads. For example,

        imap = Net::IMAP.new("imap.foo.net", "imap2")
        imap.authenticate("cram-md5", "bar", "password")
        imap.select("inbox")
        fetch_thread = Thread.start { imap.fetch(1..-1, "UID") }
        search_result = imap.search(["BODY", "hello"])
        fetch_result = fetch_thread.value
        imap.disconnect

      This script invokes the FETCH command and the SEARCH command concurrently.

      == Errors

      An IMAP server can send three different types of responses to indicate
      failure:

      NO:: the attempted command could not be successfully completed.  For
           instance, the username/password used for logging in are incorrect;
           the selected mailbox does not exist; etc.

      BAD:: the request from the client does not follow the server's
            understanding of the IMAP protocol.  This includes attempting
            commands from the wrong client state; for instance, attempting
            to perform a SEARCH command without having SELECTed a current
            mailbox.  It can also signal an internal server
            failure (such as a disk crash) has occurred.

      BYE:: the server is saying goodbye.  This can be part of a normal
            logout sequence, and can be used as part of a login sequence
            to indicate that the server is (for some reason) unwilling
            to accept your connection.  As a response to any other command,
            it indicates either that the server is shutting down, or that
            the server is timing out the client connection due to inactivity.

      These three error response are represented by the errors
      Net::IMAP::NoResponseError, Net::IMAP::BadResponseError, and
      Net::IMAP::ByeResponseError, all of which are subclasses of
      Net::IMAP::ResponseError.  Essentially, all methods that involve
      sending a request to the server can generate one of these errors.
      Only the most pertinent instances have been documented below.

      Because the IMAP class uses Sockets for communication, its methods
      are also susceptible to the various errors that can occur when
      working with sockets.  These are generally represented as
      Errno errors.  For instance, any method that involves sending a
      request to the server and/or receiving a response from it could
      raise an Errno::EPIPE error if the network connection unexpectedly
      goes down.  See the socket(7), ip(7), tcp(7), socket(2), connect(2),
      and associated man pages.

      Finally, a Net::IMAP::DataFormatError is thrown if low-level data
      is found to be in an incorrect format (for instance, when converting
      between UTF-8 and UTF-16), and Net::IMAP::ResponseParseError is
      thrown if a server response is non-parseable.

      == References

      [[IMAP]]
         M. Crispin, "INTERNET MESSAGE ACCESS PROTOCOL - VERSION 4rev1",
         RFC 2060, December 1996.  (Note: since obsoleted by RFC 3501)

      [[LANGUAGE-TAGS]]
         Alvestrand, H., "Tags for the Identification of
         Languages", RFC 1766, March 1995.

      [[MD5]]
         Myers, J., and M. Rose, "The Content-MD5 Header Field", RFC
         1864, October 1995.

      [[MIME-IMB]]
         Freed, N., and N. Borenstein, "MIME (Multipurpose Internet
         Mail Extensions) Part One: Format of Internet Message Bodies", RFC
         2045, November 1996.

      [[RFC-822]]
         Crocker, D., "Standard for the Format of ARPA Internet Text
         Messages", STD 11, RFC 822, University of Delaware, August 1982.

      [[RFC-2087]]
         Myers, J., "IMAP4 QUOTA extension", RFC 2087, January 1997.

      [[RFC-2086]]
         Myers, J., "IMAP4 ACL extension", RFC 2086, January 1997.

      [[RFC-2195]]
         Klensin, J., Catoe, R., and Krumviede, P., "IMAP/POP AUTHorize Extension
         for Simple Challenge/Response", RFC 2195, September 1997.

      [[SORT-THREAD-EXT]]
         Crispin, M., "INTERNET MESSAGE ACCESS PROTOCOL - SORT and THREAD
         Extensions", draft-ietf-imapext-sort, May 2003.

      [[OSSL]]
         http://www.openssl.org

      [[RSSL]]
         http://savannah.gnu.org/projects/rubypki

      [[UTF7]]
         Goldsmith, D. and Davis, M., "UTF-7: A Mail-Safe Transformation Format of
         Unicode", RFC 2152, May 1997.
  Net::IMAP::BadResponseError:
    main: |-
      Error raised upon a "BAD" response from the server, indicating
      that the client command violated the IMAP protocol, or an internal
      server failure has occurred.
  Net::IMAP::BodyTypeAttachment:
    main: |-
      Net::IMAP::BodyTypeAttachment represents attachment body structures
      of messages.

      ==== Fields:

      media_type:: Returns the content media type name.

      subtype:: Returns +nil+.

      param:: Returns a hash that represents parameters.

      multipart?:: Returns false.
  Net::IMAP::BodyTypeBasic:
    main: |-
      Net::IMAP::BodyTypeBasic represents basic body structures of messages.

      ==== Fields:

      media_type:: Returns the content media type name as defined in [MIME-IMB].

      subtype:: Returns the content subtype name as defined in [MIME-IMB].

      param:: Returns a hash that represents parameters as defined in [MIME-IMB].

      content_id:: Returns a string giving the content id as defined in [MIME-IMB].

      description:: Returns a string giving the content description as defined in
                    [MIME-IMB].

      encoding:: Returns a string giving the content transfer encoding as defined in
                 [MIME-IMB].

      size:: Returns a number giving the size of the body in octets.

      md5:: Returns a string giving the body MD5 value as defined in [MD5].

      disposition:: Returns a Net::IMAP::ContentDisposition object giving
                    the content disposition.

      language:: Returns a string or an array of strings giving the body
                 language value as defined in [LANGUAGE-TAGS].

      extension:: Returns extension data.

      multipart?:: Returns false.
  Net::IMAP::BodyTypeMessage:
    main: |-
      Net::IMAP::BodyTypeMessage represents MESSAGE/RFC822 body structures of messages.

      ==== Fields:

      envelope:: Returns a Net::IMAP::Envelope giving the envelope structure.

      body:: Returns an object giving the body structure.

      And Net::IMAP::BodyTypeMessage has all methods of Net::IMAP::BodyTypeText.
  Net::IMAP::BodyTypeMultipart:
    main: |-
      Net::IMAP::BodyTypeMultipart represents multipart body structures
      of messages.

      ==== Fields:

      media_type:: Returns the content media type name as defined in [MIME-IMB].

      subtype:: Returns the content subtype name as defined in [MIME-IMB].

      parts:: Returns multiple parts.

      param:: Returns a hash that represents parameters as defined in [MIME-IMB].

      disposition:: Returns a Net::IMAP::ContentDisposition object giving
                    the content disposition.

      language:: Returns a string or an array of strings giving the body
                 language value as defined in [LANGUAGE-TAGS].

      extension:: Returns extension data.

      multipart?:: Returns true.
  Net::IMAP::BodyTypeText:
    main: |-
      Net::IMAP::BodyTypeText represents TEXT body structures of messages.

      ==== Fields:

      lines:: Returns the size of the body in text lines.

      And Net::IMAP::BodyTypeText has all fields of Net::IMAP::BodyTypeBasic.
  Net::IMAP::ByeResponseError:
    main: |-
      Error raised upon a "BYE" response from the server, indicating
      that the client is not being allowed to login, or has been timed
      out due to inactivity.
  Net::IMAP::CramMD5Authenticator:
    main: |-
      Authenticator for the "CRAM-MD5" authentication type.  See
      #authenticate().
  Net::IMAP::DataFormatError:
    main: Error raised when data is in the incorrect format.
  Net::IMAP::DigestMD5Authenticator:
    main: |-
      Authenticator for the "DIGEST-MD5" authentication type.  See
      #authenticate().
  Net::IMAP::Error:
    main: Superclass of IMAP errors.
  Net::IMAP::FlagCountError:
    main: Error raised when too many flags are interned to symbols.
  Net::IMAP::LoginAuthenticator:
    main: |-
      Authenticator for the "LOGIN" authentication type.  See
      #authenticate().
  Net::IMAP::NoResponseError:
    main: |-
      Error raised upon a "NO" response from the server, indicating
      that the client command could not be completed successfully.
  Net::IMAP::NumValidator:
    main: Common validators of number and nz_number types
  Net::IMAP::PlainAuthenticator:
    main: |-
      Authenticator for the "PLAIN" authentication type.  See
      #authenticate().
  Net::IMAP::ResponseError:
    main: |-
      Superclass of all errors used to encapsulate "fail" responses
      from the server.
  Net::IMAP::ResponseParseError:
    main: Error raised when a response from the server is non-parseable.
net/pop:
  Net::APOP:
    main: This class is equivalent to POP3, except that it uses APOP authentication.
  Net::APOPSession:
    main: This class is equivalent to POP3, except that it uses APOP authentication.
  Net::POP3:
    main: |-
      == What is This Library?

      This library provides functionality for retrieving
      email via POP3, the Post Office Protocol version 3. For details
      of POP3, see [RFC1939] (http://www.ietf.org/rfc/rfc1939.txt).

      == Examples

      === Retrieving Messages

      This example retrieves messages from the server and deletes them
      on the server.

      Messages are written to files named 'inbox/1', 'inbox/2', ....
      Replace 'pop.example.com' with your POP3 server address, and
      'YourAccount' and 'YourPassword' with the appropriate account
      details.

          require 'net/pop'

          pop = Net::POP3.new('pop.example.com')
          pop.start('YourAccount', 'YourPassword')             # (1)
          if pop.mails.empty?
            puts 'No mail.'
          else
            i = 0
            pop.each_mail do |m|   # or "pop.mails.each ..."   # (2)
              File.open("inbox/#{i}", 'w') do |f|
                f.write m.pop
              end
              m.delete
              i += 1
            end
            puts "#{pop.mails.size} mails popped."
          end
          pop.finish                                           # (3)

      1. Call Net::POP3#start and start POP session.
      2. Access messages by using POP3#each_mail and/or POP3#mails.
      3. Close POP session by calling POP3#finish or use the block form of #start.

      === Shortened Code

      The example above is very verbose. You can shorten the code by using
      some utility methods. First, the block form of Net::POP3.start can
      be used instead of POP3.new, POP3#start and POP3#finish.

          require 'net/pop'

          Net::POP3.start('pop.example.com', 110,
                          'YourAccount', 'YourPassword') do |pop|
            if pop.mails.empty?
              puts 'No mail.'
            else
              i = 0
              pop.each_mail do |m|   # or "pop.mails.each ..."
                File.open("inbox/#{i}", 'w') do |f|
                  f.write m.pop
                end
                m.delete
                i += 1
              end
              puts "#{pop.mails.size} mails popped."
            end
          end

      POP3#delete_all is an alternative for #each_mail and #delete.

          require 'net/pop'

          Net::POP3.start('pop.example.com', 110,
                          'YourAccount', 'YourPassword') do |pop|
            if pop.mails.empty?
              puts 'No mail.'
            else
              i = 1
              pop.delete_all do |m|
                File.open("inbox/#{i}", 'w') do |f|
                  f.write m.pop
                end
                i += 1
              end
            end
          end

      And here is an even shorter example.

          require 'net/pop'

          i = 0
          Net::POP3.delete_all('pop.example.com', 110,
                               'YourAccount', 'YourPassword') do |m|
            File.open("inbox/#{i}", 'w') do |f|
              f.write m.pop
            end
            i += 1
          end

      === Memory Space Issues

      All the examples above get each message as one big string.
      This example avoids this.

          require 'net/pop'

          i = 1
          Net::POP3.delete_all('pop.example.com', 110,
                               'YourAccount', 'YourPassword') do |m|
            File.open("inbox/#{i}", 'w') do |f|
              m.pop do |chunk|    # get a message little by little.
                f.write chunk
              end
              i += 1
            end
          end

      === Using APOP

      The net/pop library supports APOP authentication.
      To use APOP, use the Net::APOP class instead of the Net::POP3 class.
      You can use the utility method, Net::POP3.APOP(). For example:

          require 'net/pop'

          # Use APOP authentication if $isapop == true
          pop = Net::POP3.APOP($isapop).new('apop.example.com', 110)
          pop.start('YourAccount', 'YourPassword') do |pop|
            # Rest of the code is the same.
          end

      === Fetch Only Selected Mail Using 'UIDL' POP Command

      If your POP server provides UIDL functionality,
      you can grab only selected mails from the POP server.
      e.g.

          def need_pop?( id )
            # determine if we need pop this mail...
          end

          Net::POP3.start('pop.example.com', 110,
                          'Your account', 'Your password') do |pop|
            pop.mails.select { |m| need_pop?(m.unique_id) }.each do |m|
              do_something(m.pop)
            end
          end

      The POPMail#unique_id() method returns the unique-id of the message as a
      String. Normally the unique-id is a hash of the message.
  Net::POPAuthenticationError:
    main: POP3 authentication error.
  Net::POPBadResponse:
    main: Unexpected response from the server.
  Net::POPError:
    main: |-
      Non-authentication POP3 protocol error
      (reply code "-ERR", except authentication).
  Net::POPMail:
    main: |-
      This class represents a message which exists on the POP server.
      Instances of this class are created by the POP3 class; they should
      not be directly created by the user.
net/protocol:
  Net::OpenTimeout:
    main: |-
      OpenTimeout, a subclass of Timeout::Error, is raised if a connection cannot
      be created within the open_timeout.
  Net::ReadTimeout:
    main: |-
      ReadTimeout, a subclass of Timeout::Error, is raised if a chunk of the
      response cannot be read within the read_timeout.
  Net::WriteAdapter:
    main: The writer adapter class
  Net::WriteTimeout:
    main: |-
      WriteTimeout, a subclass of Timeout::Error, is raised if a chunk of the
      response cannot be written within the write_timeout.  Not raised on Windows.
net/smtp:
  Net::SMTP:
    main: |-
      == What is This Library?

      This library provides functionality to send internet
      mail via SMTP, the Simple Mail Transfer Protocol. For details of
      SMTP itself, see [RFC2821] (http://www.ietf.org/rfc/rfc2821.txt).

      == What is This Library NOT?

      This library does NOT provide functions to compose internet mails.
      You must create them by yourself. If you want better mail support,
      try RubyMail or TMail or search for alternatives in
      {RubyGems.org}[https://rubygems.org/] or {The Ruby
      Toolbox}[https://www.ruby-toolbox.com/].

      FYI: the official documentation on internet mail is: [RFC2822] (http://www.ietf.org/rfc/rfc2822.txt).

      == Examples

      === Sending Messages

      You must open a connection to an SMTP server before sending messages.
      The first argument is the address of your SMTP server, and the second
      argument is the port number. Using SMTP.start with a block is the simplest
      way to do this. This way, the SMTP connection is closed automatically
      after the block is executed.

          require 'net/smtp'
          Net::SMTP.start('your.smtp.server', 25) do |smtp|
            # Use the SMTP object smtp only in this block.
          end

      Replace 'your.smtp.server' with your SMTP server. Normally
      your system manager or internet provider supplies a server
      for you.

      Then you can send messages.

          msgstr = <<END_OF_MESSAGE
          From: Your Name <your@mail.address>
          To: Destination Address <someone@example.com>
          Subject: test message
          Date: Sat, 23 Jun 2001 16:26:43 +0900
          Message-Id: <unique.message.id.string@example.com>

          This is a test message.
          END_OF_MESSAGE

          require 'net/smtp'
          Net::SMTP.start('your.smtp.server', 25) do |smtp|
            smtp.send_message msgstr,
                              'your@mail.address',
                              'his_address@example.com'
          end

      === Closing the Session

      You MUST close the SMTP session after sending messages, by calling
      the #finish method:

          # using SMTP#finish
          smtp = Net::SMTP.start('your.smtp.server', 25)
          smtp.send_message msgstr, 'from@address', 'to@address'
          smtp.finish

      You can also use the block form of SMTP.start/SMTP#start.  This closes
      the SMTP session automatically:

          # using block form of SMTP.start
          Net::SMTP.start('your.smtp.server', 25) do |smtp|
            smtp.send_message msgstr, 'from@address', 'to@address'
          end

      I strongly recommend this scheme.  This form is simpler and more robust.

      === HELO domain

      In almost all situations, you must provide a third argument
      to SMTP.start/SMTP#start. This is the domain name which you are on
      (the host to send mail from). It is called the "HELO domain".
      The SMTP server will judge whether it should send or reject
      the SMTP session by inspecting the HELO domain.

          Net::SMTP.start('your.smtp.server', 25,
                          'mail.from.domain') { |smtp| ... }

      === SMTP Authentication

      The Net::SMTP class supports three authentication schemes;
      PLAIN, LOGIN and CRAM MD5.  (SMTP Authentication: [RFC2554])
      To use SMTP authentication, pass extra arguments to
      SMTP.start/SMTP#start.

          # PLAIN
          Net::SMTP.start('your.smtp.server', 25, 'mail.from.domain',
                          'Your Account', 'Your Password', :plain)
          # LOGIN
          Net::SMTP.start('your.smtp.server', 25, 'mail.from.domain',
                          'Your Account', 'Your Password', :login)

          # CRAM MD5
          Net::SMTP.start('your.smtp.server', 25, 'mail.from.domain',
                          'Your Account', 'Your Password', :cram_md5)
  Net::SMTP::Response:
    main: |-
      This class represents a response received by the SMTP server. Instances
      of this class are created by the SMTP class; they should not be directly
      created by the user. For more information on SMTP responses, view
      {Section 4.2 of RFC 5321}[http://tools.ietf.org/html/rfc5321#section-4.2]
  Net::SMTPAuthenticationError:
    main: Represents an SMTP authentication error.
  Net::SMTPError:
    main: Module mixed in to all SMTP error classes
  Net::SMTPFatalError:
    main: Represents a fatal SMTP error (error code 5xx, except for 500)
  Net::SMTPServerBusy:
    main: Represents SMTP error code 4xx, a temporary error.
  Net::SMTPSyntaxError:
    main: Represents an SMTP command syntax error (error code 500)
  Net::SMTPUnknownError:
    main: Unexpected reply code returned from server.
  Net::SMTPUnsupportedCommand:
    main: Command is not supported on server.
observer:
  Observable:
    main: |-
      The Observer pattern (also known as publish/subscribe) provides a simple
      mechanism for one object to inform a set of interested third-party objects
      when its state changes.

      == Mechanism

      The notifying class mixes in the +Observable+
      module, which provides the methods for managing the associated observer
      objects.

      The observable object must:
      * assert that it has +#changed+
      * call +#notify_observers+

      An observer subscribes to updates using Observable#add_observer, which also
      specifies the method called via #notify_observers. The default method for
      #notify_observers is #update.

      === Example

      The following example demonstrates this nicely.  A +Ticker+, when run,
      continually receives the stock +Price+ for its <tt>@symbol</tt>.  A +Warner+
      is a general observer of the price, and two warners are demonstrated, a
      +WarnLow+ and a +WarnHigh+, which print a warning if the price is below or
      above their set limits, respectively.

      The +update+ callback allows the warners to run without being explicitly
      called.  The system is set up with the +Ticker+ and several observers, and the
      observers do their duty without the top-level code having to interfere.

      Note that the contract between publisher and subscriber (observable and
      observer) is not declared or enforced.  The +Ticker+ publishes a time and a
      price, and the warners receive that.  But if you don't ensure that your
      contracts are correct, nothing else can warn you.

        require "observer"

        class Ticker          ### Periodically fetch a stock price.
          include Observable

          def initialize(symbol)
            @symbol = symbol
          end

          def run
            last_price = nil
            loop do
              price = Price.fetch(@symbol)
              print "Current price: #{price}\n"
              if price != last_price
                changed                 # notify observers
                last_price = price
                notify_observers(Time.now, price)
              end
              sleep 1
            end
          end
        end

        class Price           ### A mock class to fetch a stock price (60 - 140).
          def self.fetch(symbol)
            60 + rand(80)
          end
        end

        class Warner          ### An abstract observer of Ticker objects.
          def initialize(ticker, limit)
            @limit = limit
            ticker.add_observer(self)
          end
        end

        class WarnLow < Warner
          def update(time, price)       # callback for observer
            if price < @limit
              print "--- #{time.to_s}: Price below #@limit: #{price}\n"
            end
          end
        end

        class WarnHigh < Warner
          def update(time, price)       # callback for observer
            if price > @limit
              print "+++ #{time.to_s}: Price above #@limit: #{price}\n"
            end
          end
        end

        ticker = Ticker.new("MSFT")
        WarnLow.new(ticker, 80)
        WarnHigh.new(ticker, 120)
        ticker.run

      Produces:

        Current price: 83
        Current price: 75
        --- Sun Jun 09 00:10:25 CDT 2002: Price below 80: 75
        Current price: 90
        Current price: 134
        +++ Sun Jun 09 00:10:25 CDT 2002: Price above 120: 134
        Current price: 134
        Current price: 112
        Current price: 79
        --- Sun Jun 09 00:10:25 CDT 2002: Price below 80: 79
open-uri:
  OpenURI:
    main: |-
      OpenURI is an easy-to-use wrapper for Net::HTTP, Net::HTTPS and Net::FTP.

      == Example

      It is possible to open an http, https or ftp URL as though it were a file:

        URI.open("http://www.ruby-lang.org/") {|f|
          f.each_line {|line| p line}
        }

      The opened file has several getter methods for its meta-information, as
      follows, since it is extended by OpenURI::Meta.

        URI.open("http://www.ruby-lang.org/en") {|f|
          f.each_line {|line| p line}
          p f.base_uri         # <URI::HTTP:0x40e6ef2 URL:http://www.ruby-lang.org/en/>
          p f.content_type     # "text/html"
          p f.charset          # "iso-8859-1"
          p f.content_encoding # []
          p f.last_modified    # Thu Dec 05 02:45:02 UTC 2002
        }

      Additional header fields can be specified by an optional hash argument.

        URI.open("http://www.ruby-lang.org/en/",
          "User-Agent" => "Ruby/#{RUBY_VERSION}",
          "From" => "foo@bar.invalid",
          "Referer" => "http://www.ruby-lang.org/") {|f|
          # ...
        }

      The environment variables such as http_proxy, https_proxy and ftp_proxy
      are in effect by default. Here we disable proxy:

        URI.open("http://www.ruby-lang.org/en/", :proxy => nil) {|f|
          # ...
        }

      See OpenURI::OpenRead.open and URI.open for more on available options.

      URI objects can be opened in a similar way.

        uri = URI.parse("http://www.ruby-lang.org/en/")
        uri.open {|f|
          # ...
        }

      URI objects can be read directly. The returned string is also extended by
      OpenURI::Meta.

        str = uri.read
        p str.base_uri

      Author:: Tanaka Akira <akr@m17n.org>
  OpenURI::HTTPRedirect:
    main: |-
      Raised on redirection,
      only occurs when +redirect+ option for HTTP is +false+.
  OpenURI::Meta:
    main: Mixin for holding meta-information.
  OpenURI::OpenRead:
    main: Mixin for HTTP and FTP URIs.
open3:
  Open3:
    main: |-
      Open3 grants you access to stdin, stdout, stderr and a thread to wait for the
      child process when running another program.
      You can specify various attributes, redirections, current directory, etc., of
      the program in the same way as for Process.spawn.

      - Open3.popen3 : pipes for stdin, stdout, stderr
      - Open3.popen2 : pipes for stdin, stdout
      - Open3.popen2e : pipes for stdin, merged stdout and stderr
      - Open3.capture3 : give a string for stdin; get strings for stdout, stderr
      - Open3.capture2 : give a string for stdin; get a string for stdout
      - Open3.capture2e : give a string for stdin; get a string for merged stdout and stderr
      - Open3.pipeline_rw : pipes for first stdin and last stdout of a pipeline
      - Open3.pipeline_r : pipe for last stdout of a pipeline
      - Open3.pipeline_w : pipe for first stdin of a pipeline
      - Open3.pipeline_start : run a pipeline without waiting
      - Open3.pipeline : run a pipeline and wait for its completion
optionparser: {}
optparse:
  OptionParser:
    main: |-
      == OptionParser

      === Introduction

      OptionParser is a class for command-line option analysis.  It is much more
      advanced, yet also easier to use, than GetoptLong, and is a more Ruby-oriented
      solution.

      === Features

      1. The argument specification and the code to handle it are written in the
         same place.
      2. It can output an option summary; you don't need to maintain this string
         separately.
      3. Optional and mandatory arguments are specified very gracefully.
      4. Arguments can be automatically converted to a specified class.
      5. Arguments can be restricted to a certain set.

      All of these features are demonstrated in the examples below.  See
      #make_switch for full documentation.

      === Minimal example

        require 'optparse'

        options = {}
        OptionParser.new do |opts|
          opts.banner = "Usage: example.rb [options]"

          opts.on("-v", "--[no-]verbose", "Run verbosely") do |v|
            options[:verbose] = v
          end
        end.parse!

        p options
        p ARGV

      === Generating Help

      OptionParser can be used to automatically generate help for the commands you
      write:

        require 'optparse'

        Options = Struct.new(:name)

        class Parser
          def self.parse(options)
            args = Options.new("world")

            opt_parser = OptionParser.new do |opts|
              opts.banner = "Usage: example.rb [options]"

              opts.on("-nNAME", "--name=NAME", "Name to say hello to") do |n|
                args.name = n
              end

              opts.on("-h", "--help", "Prints this help") do
                puts opts
                exit
              end
            end

            opt_parser.parse!(options)
            return args
          end
        end
        options = Parser.parse %w[--help]

        #=>
           # Usage: example.rb [options]
           #     -n, --name=NAME                  Name to say hello to
           #     -h, --help                       Prints this help

      === Required Arguments

      For options that require an argument, option specification strings may include an
      option name in all caps. If an option is used without the required argument,
      an exception will be raised.

        require 'optparse'

        options = {}
        OptionParser.new do |parser|
          parser.on("-r", "--require LIBRARY",
                    "Require the LIBRARY before executing your script") do |lib|
            puts "You required #{lib}!"
          end
        end.parse!

      Used:

        $ ruby optparse-test.rb -r
        optparse-test.rb:9:in `<main>': missing argument: -r (OptionParser::MissingArgument)
        $ ruby optparse-test.rb -r my-library
        You required my-library!

      === Type Coercion

      OptionParser supports the ability to coerce command line arguments
      into objects for us.

      OptionParser comes with a few ready-to-use kinds of  type
      coercion. They are:

      - Date  -- Anything accepted by +Date.parse+
      - DateTime -- Anything accepted by +DateTime.parse+
      - Time -- Anything accepted by +Time.httpdate+ or +Time.parse+
      - URI  -- Anything accepted by +URI.parse+
      - Shellwords -- Anything accepted by +Shellwords.shellwords+
      - String -- Any non-empty string
      - Integer -- Any integer. Will convert octal. (e.g. 124, -3, 040)
      - Float -- Any float. (e.g. 10, 3.14, -100E+13)
      - Numeric -- Any integer, float, or rational (1, 3.4, 1/3)
      - DecimalInteger -- Like +Integer+, but no octal format.
      - OctalInteger -- Like +Integer+, but no decimal format.
      - DecimalNumeric -- Decimal integer or float.
      - TrueClass --  Accepts '+, yes, true, -, no, false' and
        defaults as +true+
      - FalseClass -- Same as +TrueClass+, but defaults to +false+
      - Array -- Strings separated by ',' (e.g. 1,2,3)
      - Regexp -- Regular expressions. Also includes options.

      We can also add our own coercions, which we will cover below.

      ==== Using Built-in Conversions

      As an example, the built-in +Time+ conversion is used. The other built-in
      conversions behave in the same way.
      OptionParser will attempt to parse the argument
      as a +Time+. If it succeeds, that time will be passed to the
      handler block. Otherwise, an exception will be raised.

        require 'optparse'
        require 'optparse/time'
        OptionParser.new do |parser|
          parser.on("-t", "--time [TIME]", Time, "Begin execution at given time") do |time|
            p time
          end
        end.parse!

      Used:

        $ ruby optparse-test.rb  -t nonsense
        ... invalid argument: -t nonsense (OptionParser::InvalidArgument)
        $ ruby optparse-test.rb  -t 10-11-12
        2010-11-12 00:00:00 -0500
        $ ruby optparse-test.rb  -t 9:30
        2014-08-13 09:30:00 -0400

      ==== Creating Custom Conversions

      The +accept+ method on OptionParser may be used to create converters.
      It specifies which conversion block to call whenever a class is specified.
      The example below uses it to fetch a +User+ object before the +on+ handler receives it.

        require 'optparse'

        User = Struct.new(:id, :name)

        def find_user id
          not_found = ->{ raise "No User Found for id #{id}" }
          [ User.new(1, "Sam"),
            User.new(2, "Gandalf") ].find(not_found) do |u|
            u.id == id
          end
        end

        op = OptionParser.new
        op.accept(User) do |user_id|
          find_user user_id.to_i
        end

        op.on("--user ID", User) do |user|
          puts user
        end

        op.parse!

      Used:

        $ ruby optparse-test.rb --user 1
        #<struct User id=1, name="Sam">
        $ ruby optparse-test.rb --user 2
        #<struct User id=2, name="Gandalf">
        $ ruby optparse-test.rb --user 3
        optparse-test.rb:15:in `block in find_user': No User Found for id 3 (RuntimeError)

      === Store options to a Hash

      The +into+ option of +order+, +parse+ and so on methods stores command line options into a Hash.

        require 'optparse'

        params = {}
        OptionParser.new do |opts|
          opts.on('-a')
          opts.on('-b NUM', Integer)
          opts.on('-v', '--verbose')
        end.parse!(into: params)

        p params

      Used:

        $ ruby optparse-test.rb -a
        {:a=>true}
        $ ruby optparse-test.rb -a -v
        {:a=>true, :verbose=>true}
        $ ruby optparse-test.rb -a -b 100
        {:a=>true, :b=>100}

      === Complete example

      The following example is a complete Ruby program.  You can run it and see the
      effect of specifying various options.  This is probably the best way to learn
      the features of +optparse+.

        require 'optparse'
        require 'optparse/time'
        require 'ostruct'
        require 'pp'

        class OptparseExample
          Version = '1.0.0'

          CODES = %w[iso-2022-jp shift_jis euc-jp utf8 binary]
          CODE_ALIASES = { "jis" => "iso-2022-jp", "sjis" => "shift_jis" }

          class ScriptOptions
            attr_accessor :library, :inplace, :encoding, :transfer_type,
                          :verbose, :extension, :delay, :time, :record_separator,
                          :list

            def initialize
              self.library = []
              self.inplace = false
              self.encoding = "utf8"
              self.transfer_type = :auto
              self.verbose = false
            end

            def define_options(parser)
              parser.banner = "Usage: example.rb [options]"
              parser.separator ""
              parser.separator "Specific options:"

              # add additional options
              perform_inplace_option(parser)
              delay_execution_option(parser)
              execute_at_time_option(parser)
              specify_record_separator_option(parser)
              list_example_option(parser)
              specify_encoding_option(parser)
              optional_option_argument_with_keyword_completion_option(parser)
              boolean_verbose_option(parser)

              parser.separator ""
              parser.separator "Common options:"
              # No argument, shows at tail.  This will print an options summary.
              # Try it and see!
              parser.on_tail("-h", "--help", "Show this message") do
                puts parser
                exit
              end
              # Another typical switch to print the version.
              parser.on_tail("--version", "Show version") do
                puts Version
                exit
              end
            end

            def perform_inplace_option(parser)
              # Specifies an optional option argument
              parser.on("-i", "--inplace [EXTENSION]",
                        "Edit ARGV files in place",
                        "(make backup if EXTENSION supplied)") do |ext|
                self.inplace = true
                self.extension = ext || ''
                self.extension.sub!(/\A\.?(?=.)/, ".")  # Ensure extension begins with dot.
              end
            end

            def delay_execution_option(parser)
              # Cast 'delay' argument to a Float.
              parser.on("--delay N", Float, "Delay N seconds before executing") do |n|
                self.delay = n
              end
            end

            def execute_at_time_option(parser)
              # Cast 'time' argument to a Time object.
              parser.on("-t", "--time [TIME]", Time, "Begin execution at given time") do |time|
                self.time = time
              end
            end

            def specify_record_separator_option(parser)
              # Cast to octal integer.
              parser.on("-F", "--irs [OCTAL]", OptionParser::OctalInteger,
                        "Specify record separator (default \\0)") do |rs|
                self.record_separator = rs
              end
            end

            def list_example_option(parser)
              # List of arguments.
              parser.on("--list x,y,z", Array, "Example 'list' of arguments") do |list|
                self.list = list
              end
            end

            def specify_encoding_option(parser)
              # Keyword completion.  We are specifying a specific set of arguments (CODES
              # and CODE_ALIASES - notice the latter is a Hash), and the user may provide
              # the shortest unambiguous text.
              code_list = (CODE_ALIASES.keys + CODES).join(', ')
              parser.on("--code CODE", CODES, CODE_ALIASES, "Select encoding",
                        "(#{code_list})") do |encoding|
                self.encoding = encoding
              end
            end

            def optional_option_argument_with_keyword_completion_option(parser)
              # Optional '--type' option argument with keyword completion.
              parser.on("--type [TYPE]", [:text, :binary, :auto],
                        "Select transfer type (text, binary, auto)") do |t|
                self.transfer_type = t
              end
            end

            def boolean_verbose_option(parser)
              # Boolean switch.
              parser.on("-v", "--[no-]verbose", "Run verbosely") do |v|
                self.verbose = v
              end
            end
          end

          #
          # Return a structure describing the options.
          #
          def parse(args)
            # The options specified on the command line will be collected in
            # *options*.

            @options = ScriptOptions.new
            @args = OptionParser.new do |parser|
              @options.define_options(parser)
              parser.parse!(args)
            end
            @options
          end

          attr_reader :parser, :options
        end  # class OptparseExample

        example = OptparseExample.new
        options = example.parse(ARGV)
        pp options # example.options
        pp ARGV

      === Shell Completion

      For modern shells (e.g. bash, zsh, etc.), you can use shell
      completion for command line options.

      === Further documentation

      The above examples should be enough to learn how to use this class.  If you
      have any questions, file a ticket at http://bugs.ruby-lang.org.
  OptionParser::Acceptables:
    main: |-
      Acceptable argument classes. Now contains DecimalInteger, OctalInteger
      and DecimalNumeric. See Acceptable argument classes (in source code).
  OptionParser::AmbiguousArgument:
    main: Raises when the given argument word can't be completed uniquely.
  OptionParser::AmbiguousOption:
    main: Raises when ambiguously completable string is encountered.
  OptionParser::Arguable:
    main: Extends command line arguments array (ARGV) to parse itself.
  OptionParser::CompletingHash:
    main: Hash with completion search feature. See OptionParser::Completion.
  OptionParser::Completion:
    main: |-
      Keyword completion module.  This allows partial arguments to be specified
      and resolved against a list of acceptable values.
  OptionParser::InvalidArgument:
    main: Raises when the given argument does not match required format.
  OptionParser::InvalidOption:
    main: Raises when switch is undefined.
  OptionParser::List:
    main: |-
      Simple option list providing mapping from short and/or long option
      string to OptionParser::Switch and mapping from acceptable argument to
      matching pattern and converter pair. Also provides summary feature.
  OptionParser::MissingArgument:
    main: Raises when a switch with mandatory argument has no argument.
  OptionParser::NeedlessArgument:
    main: Raises when there is an argument for a switch which takes no argument.
  OptionParser::OptionMap:
    main: Map from option/keyword string to object with completion.
  OptionParser::ParseError:
    main: Base class of exceptions from OptionParser.
  OptionParser::Switch:
    main: |-
      Individual switch class.  Not important to the user.

      Defined within Switch are several Switch-derived classes: NoArgument,
      RequiredArgument, etc.
  OptionParser::Switch::NoArgument:
    main: Switch that takes no arguments.
  OptionParser::Switch::OptionalArgument:
    main: Switch that can omit argument.
  OptionParser::Switch::PlacedArgument:
    main: Switch that takes an argument, which does not begin with '-'.
  OptionParser::Switch::RequiredArgument:
    main: Switch that takes an argument.
ostruct:
  OpenStruct:
    main: |-
      An OpenStruct is a data structure, similar to a Hash, that allows the
      definition of arbitrary attributes with their accompanying values. This is
      accomplished by using Ruby's metaprogramming to define methods on the class
      itself.

      == Examples

        require "ostruct"

        person = OpenStruct.new
        person.name = "John Smith"
        person.age  = 70

        person.name      # => "John Smith"
        person.age       # => 70
        person.address   # => nil

      An OpenStruct employs a Hash internally to store the attributes and values
      and can even be initialized with one:

        australia = OpenStruct.new(:country => "Australia", :capital => "Canberra")
          # => #<OpenStruct country="Australia", capital="Canberra">

      Hash keys with spaces or characters that could normally not be used for
      method calls (e.g. <code>()[]*</code>) will not be immediately available
      on the OpenStruct object as a method for retrieval or assignment, but can
      still be reached through the Object#send method.

        measurements = OpenStruct.new("length (in inches)" => 24)
        measurements.send("length (in inches)")   # => 24

        message = OpenStruct.new(:queued? => true)
        message.queued?                           # => true
        message.send("queued?=", false)
        message.queued?                           # => false

      Removing the presence of an attribute requires the execution of the
      delete_field method as setting the property value to +nil+ will not
      remove the attribute.

        first_pet  = OpenStruct.new(:name => "Rowdy", :owner => "John Smith")
        second_pet = OpenStruct.new(:name => "Rowdy")

        first_pet.owner = nil
        first_pet                 # => #<OpenStruct name="Rowdy", owner=nil>
        first_pet == second_pet   # => false

        first_pet.delete_field(:owner)
        first_pet                 # => #<OpenStruct name="Rowdy">
        first_pet == second_pet   # => true

      == Implementation

      An OpenStruct utilizes Ruby's method lookup structure to find and define the
      necessary methods for properties. This is accomplished through the methods
      method_missing and define_singleton_method.

      This should be a consideration if there is a concern about the performance of
      the objects that are created, as there is much more overhead in the setting
      of these properties compared to using a Hash or a Struct.
pp:
  PP:
    main: |-
      A pretty-printer for Ruby objects.

      == What PP Does

      Standard output by #p returns this:
        #<PP:0x81fedf0 @genspace=#<Proc:0x81feda0>, @group_queue=#<PrettyPrint::GroupQueue:0x81fed3c @queue=[[#<PrettyPrint::Group:0x81fed78 @breakables=[], @depth=0, @break=false>], []]>, @buffer=[], @newline="\n", @group_stack=[#<PrettyPrint::Group:0x81fed78 @breakables=[], @depth=0, @break=false>], @buffer_width=0, @indent=0, @maxwidth=79, @output_width=2, @output=#<IO:0x8114ee4>>

      Pretty-printed output returns this:
        #<PP:0x81fedf0
         @buffer=[],
         @buffer_width=0,
         @genspace=#<Proc:0x81feda0>,
         @group_queue=
          #<PrettyPrint::GroupQueue:0x81fed3c
           @queue=
            [[#<PrettyPrint::Group:0x81fed78 @break=false, @breakables=[], @depth=0>],
             []]>,
         @group_stack=
          [#<PrettyPrint::Group:0x81fed78 @break=false, @breakables=[], @depth=0>],
         @indent=0,
         @maxwidth=79,
         @newline="\n",
         @output=#<IO:0x8114ee4>,
         @output_width=2>

      == Usage

        pp(obj)             #=> obj
        pp obj              #=> obj
        pp(obj1, obj2, ...) #=> [obj1, obj2, ...]
        pp()                #=> nil

      Output <tt>obj(s)</tt> to <tt>$></tt> in pretty printed format.

      It returns <tt>obj(s)</tt>.

      == Output Customization

      To define a customized pretty printing function for your classes,
      redefine method <code>#pretty_print(pp)</code> in the class.

      <code>#pretty_print</code> takes the +pp+ argument, which is an instance of the PP class.
      The method uses #text, #breakable, #nest, #group and #pp to print the
      object.

      == Pretty-Print JSON

      To pretty-print JSON refer to JSON#pretty_generate.

      == Author
      Tanaka Akira <akr@fsij.org>
prettyprint:
  PrettyPrint:
    main: |-
      This class implements a pretty printing algorithm. It finds line breaks and
      nice indentations for grouped structure.

      By default, the class assumes that primitive elements are strings and each
      byte in the strings have single column in width. But it can be used for
      other situations by giving suitable arguments for some methods:
      * newline object and space generation block for PrettyPrint.new
      * optional width argument for PrettyPrint#text
      * PrettyPrint#breakable

      There are several candidate uses:
      * text formatting using proportional fonts
      * multibyte characters which has columns different to number of bytes
      * non-string formatting

      == Bugs
      * Box based formatting?
      * Other (better) model/algorithm?

      Report any bugs at http://bugs.ruby-lang.org

      == References
      Christian Lindig, Strictly Pretty, March 2000,
      http://www.st.cs.uni-sb.de/~lindig/papers/#pretty

      Philip Wadler, A prettier printer, March 1998,
      http://homepages.inf.ed.ac.uk/wadler/topics/language-design.html#prettier

      == Author
      Tanaka Akira <akr@fsij.org>
  PrettyPrint::SingleLine:
    main: |-
      PrettyPrint::SingleLine is used by PrettyPrint.singleline_format

      It is passed to be similar to a PrettyPrint object itself, by responding to:
      * #text
      * #breakable
      * #nest
      * #group
      * #flush
      * #first?

      but instead, the output has no line breaks
prime:
  Prime:
    main: |-
      The set of all prime numbers.

      == Example

        Prime.each(100) do |prime|
          p prime  #=> 2, 3, 5, 7, 11, ...., 97
        end

      Prime is Enumerable:

        Prime.first 5 # => [2, 3, 5, 7, 11]

      == Retrieving the instance

      For convenience, each instance method of +Prime+.instance can be accessed
      as a class method of +Prime+.

      e.g.
        Prime.instance.prime?(2)  #=> true
        Prime.prime?(2)           #=> true

      == Generators

      A "generator" provides an implementation of enumerating pseudo-prime
      numbers and it remembers the position of enumeration and upper bound.
      Furthermore, it is an external iterator of prime enumeration which is
      compatible with an Enumerator.

      +Prime+::+PseudoPrimeGenerator+ is the base class for generators.
      There are few implementations of generator.

      [+Prime+::+EratosthenesGenerator+]
        Uses eratosthenes' sieve.
      [+Prime+::+TrialDivisionGenerator+]
        Uses the trial division method.
      [+Prime+::+Generator23+]
        Generates all positive integers which are not divisible by either 2 or 3.
        This sequence is very bad as a pseudo-prime sequence. But this
        is faster and uses much less memory than the other generators. So,
        it is suitable for factorizing an integer which is not large but
        has many prime factors. e.g. for Prime#prime? .
  Prime::EratosthenesGenerator:
    main: |-
      An implementation of +PseudoPrimeGenerator+.

      Uses +EratosthenesSieve+.
  Prime::EratosthenesSieve:
    main: Internal use. An implementation of Eratosthenes' sieve
  Prime::Generator23:
    main: |-
      Generates all integers which are greater than 2 and
      are not divisible by either 2 or 3.

      This is a pseudo-prime generator, suitable on
      checking primality of an integer by brute force
      method.
  Prime::PseudoPrimeGenerator:
    main: |-
      An abstract class for enumerating pseudo-prime numbers.

      Concrete subclasses should override succ, next, rewind.
  Prime::TrialDivision:
    main: Internal use. An implementation of prime table by trial division method.
  Prime::TrialDivisionGenerator:
    main: |-
      An implementation of +PseudoPrimeGenerator+ which uses
      a prime table generated by trial division.
pstore:
  PStore:
    main: |-
      PStore implements a file based persistence mechanism based on a Hash.  User
      code can store hierarchies of Ruby objects (values) into the data store file
      by name (keys).  An object hierarchy may be just a single object.  User code
      may later read values back from the data store or even update data, as needed.

      The transactional behavior ensures that any changes succeed or fail together.
      This can be used to ensure that the data store is not left in a transitory
      state, where some values were updated but others were not.

      Behind the scenes, Ruby objects are stored to the data store file with
      Marshal.  That carries the usual limitations.  Proc objects cannot be
      marshalled, for example.

      == Usage example:

       require "pstore"

       # a mock wiki object...
       class WikiPage
         def initialize( page_name, author, contents )
           @page_name = page_name
           @revisions = Array.new

           add_revision(author, contents)
         end

         attr_reader :page_name

         def add_revision( author, contents )
           @revisions << { :created  => Time.now,
                           :author   => author,
                           :contents => contents }
         end

         def wiki_page_references
           [@page_name] + @revisions.last[:contents].scan(/\b(?:[A-Z]+[a-z]+){2,}/)
         end

         # ...
       end

       # create a new page...
       home_page = WikiPage.new( "HomePage", "James Edward Gray II",
                                 "A page about the JoysOfDocumentation..." )

       # then we want to update page data and the index together, or not at all...
       wiki = PStore.new("wiki_pages.pstore")
       wiki.transaction do  # begin transaction; do all of this or none of it
         # store page...
         wiki[home_page.page_name] = home_page
         # ensure that an index has been created...
         wiki[:wiki_index] ||= Array.new
         # update wiki index...
         wiki[:wiki_index].push(*home_page.wiki_page_references)
       end                   # commit changes to wiki data store file

       ### Some time later... ###

       # read wiki data...
       wiki.transaction(true) do  # begin read-only transaction, no changes allowed
         wiki.roots.each do |data_root_name|
           p data_root_name
           p wiki[data_root_name]
         end
       end

      == Transaction modes

      By default, file integrity is only ensured as long as the operating system
      (and the underlying hardware) doesn't raise any unexpected I/O errors. If an
      I/O error occurs while PStore is writing to its file, then the file will
      become corrupted.

      You can prevent this by setting <em>pstore.ultra_safe = true</em>.
      However, this results in a minor performance loss, and only works on platforms
      that support atomic file renames. Please consult the documentation for
      +ultra_safe+ for details.

      Needless to say, if you're storing valuable data with PStore, then you should
      backup the PStore files from time to time.
  PStore::Error:
    main: The error type thrown by all PStore methods.
racc:
  Racc:
    main: |-
      Racc is a LALR(1) parser generator.
      It is written in Ruby itself, and generates Ruby programs.

      == Command-line Reference

          racc [-o<var>filename</var>] [--output-file=<var>filename</var>]
               [-e<var>rubypath</var>] [--embedded=<var>rubypath</var>]
               [-v] [--verbose]
               [-O<var>filename</var>] [--log-file=<var>filename</var>]
               [-g] [--debug]
               [-E] [--embedded]
               [-l] [--no-line-convert]
               [-c] [--line-convert-all]
               [-a] [--no-omit-actions]
               [-C] [--check-only]
               [-S] [--output-status]
               [--version] [--copyright] [--help] <var>grammarfile</var>

      [+filename+]
        Racc grammar file. Any extension is permitted.
      [-o+outfile+, --output-file=+outfile+]
        A filename for output. default is <+filename+>.tab.rb
      [-O+filename+, --log-file=+filename+]
        Place logging output in file +filename+.
        Default log file name is <+filename+>.output.
      [-e+rubypath+, --executable=+rubypath+]
        output executable file(mode 755). where +path+ is the Ruby interpreter.
      [-v, --verbose]
        verbose mode. create +filename+.output file, like yacc's y.output file.
      [-g, --debug]
        add debug code to parser class. To display debuggin information,
        use this '-g' option and set @yydebug true in parser class.
      [-E, --embedded]
        Output parser which doesn't need runtime files (racc/parser.rb).
      [-C, --check-only]
        Check syntax of racc grammar file and quit.
      [-S, --output-status]
        Print messages time to time while compiling.
      [-l, --no-line-convert]
        turns off line number converting.
      [-c, --line-convert-all]
        Convert line number of actions, inner, header and footer.
      [-a, --no-omit-actions]
        Call all actions, even if an action is empty.
      [--version]
        print Racc version and quit.
      [--copyright]
        Print copyright and quit.
      [--help]
        Print usage and quit.

      == Generating Parser Using Racc

      To compile Racc grammar file, simply type:

        $ racc parse.y

      This creates Ruby script file "parse.tab.y". The -o option can change the output filename.

      == Writing A Racc Grammar File

      If you want your own parser, you have to write a grammar file.
      A grammar file contains the name of your parser class, grammar for the parser,
      user code, and anything else.
      When writing a grammar file, yacc's knowledge is helpful.
      If you have not used yacc before, Racc is not too difficult.

      Here's an example Racc grammar file.

        class Calcparser
        rule
          target: exp { print val[0] }

          exp: exp '+' exp
             | exp '*' exp
             | '(' exp ')'
             | NUMBER
        end

      Racc grammar files resemble yacc files.
      But (of course), this is Ruby code.
      yacc's $$ is the 'result', $0, $1... is
      an array called 'val', and $-1, $-2... is an array called '_values'.

      See the {Grammar File Reference}[rdoc-ref:lib/racc/rdoc/grammar.en.rdoc] for
      more information on grammar files.

      == Parser

      Then you must prepare the parse entry method. There are two types of
      parse methods in Racc, Racc::Parser#do_parse and Racc::Parser#yyparse

      Racc::Parser#do_parse is simple.

      It's yyparse() of yacc, and Racc::Parser#next_token is yylex().
      This method must returns an array like [TOKENSYMBOL, ITS_VALUE].
      EOF is [false, false].
      (TOKENSYMBOL is a Ruby symbol (taken from String#intern) by default.
      If you want to change this, see the grammar reference.

      Racc::Parser#yyparse is little complicated, but useful.
      It does not use Racc::Parser#next_token, instead it gets tokens from any iterator.

      For example, <code>yyparse(obj, :scan)</code> causes
      calling +obj#scan+, and you can return tokens by yielding them from +obj#scan+.

      == Debugging

      When debugging, "-v" or/and the "-g" option is helpful.

      "-v" creates verbose log file (.output).
      "-g" creates a "Verbose Parser".
      Verbose Parser prints the internal status when parsing.
      But it's _not_ automatic.
      You must use -g option and set +@yydebug+ to +true+ in order to get output.
      -g option only creates the verbose parser.

      === Racc reported syntax error.

      Isn't there too many "end"?
      grammar of racc file is changed in v0.10.

      Racc does not use '%' mark, while yacc uses huge number of '%' marks..

      === Racc reported "XXXX conflicts".

      Try "racc -v xxxx.y".
      It causes producing racc's internal log file, xxxx.output.

      === Generated parsers does not work correctly

      Try "racc -g xxxx.y".
      This command let racc generate "debugging parser".
      Then set @yydebug=true in your parser.
      It produces a working log of your parser.

      == Re-distributing Racc runtime

      A parser, which is created by Racc, requires the Racc runtime module;
      racc/parser.rb.

      Ruby 1.8.x comes with Racc runtime module,
      you need NOT distribute Racc runtime files.

      If you want to include the Racc runtime module with your parser.
      This can be done by using '-E' option:

        $ racc -E -omyparser.rb myparser.y

      This command creates myparser.rb which `includes' Racc runtime.
      Only you must do is to distribute your parser file (myparser.rb).

      Note: parser.rb is ruby license, but your parser is not.
      Your own parser is completely yours.
  Racc::ActionTable:
    main: |-
      The table of LALR actions. Actions are either of
      Shift, Reduce, Accept and Error.
  Racc::Goto:
    main: |-
      Represents a transition on the grammar.
      "Real goto" means a transition by nonterminal,
      but this class treats also terminal's.
      If one is a terminal transition, .ident returns nil.
  Racc::ISet:
    main: An "indexed" set.  All items must respond to :ident.
  Racc::Item:
    main: LALR item.  A set of rule and its lookahead tokens.
  Racc::LocationPointer:
    main: |-
      A set of rule and position in it's RHS.
      Note that the number of pointers is more than rule's RHS array,
      because pointer points right edge of the final symbol when reducing.
  Racc::State:
    main: A LALR state.
  Racc::States:
    main: A table of LALR states.
  Racc::Sym:
    main: Stands terminal and nonterminal symbols.
rdoc:
  RDoc:
    main: |-
      RDoc produces documentation for Ruby source files by parsing the source and
      extracting the definition for classes, modules, methods, includes and
      requires.  It associates these with optional documentation contained in an
      immediately preceding comment block then renders the result using an output
      formatter.

      For a simple introduction to writing or generating documentation using RDoc
      see the README.

      == Roadmap

      If you think you found a bug in RDoc see CONTRIBUTING@Bugs

      If you want to use RDoc to create documentation for your Ruby source files,
      see RDoc::Markup and refer to <tt>rdoc --help</tt> for command line usage.

      If you want to set the default markup format see
      RDoc::Markup@Supported+Formats

      If you want to store rdoc configuration in your gem (such as the default
      markup format) see RDoc::Options@Saved+Options

      If you want to write documentation for Ruby files see RDoc::Parser::Ruby

      If you want to write documentation for extensions written in C see
      RDoc::Parser::C

      If you want to generate documentation using <tt>rake</tt> see RDoc::Task.

      If you want to drive RDoc programmatically, see RDoc::RDoc.

      If you want to use the library to format text blocks into HTML or other
      formats, look at RDoc::Markup.

      If you want to make an RDoc plugin such as a generator or directive handler
      see RDoc::RDoc.

      If you want to write your own output generator see RDoc::Generator.

      If you want an overview of how RDoc works see CONTRIBUTING

      == Credits

      RDoc is currently being maintained by Eric Hodel <drbrain@segment7.net>.

      Dave Thomas <dave@pragmaticprogrammer.com> is the original author of RDoc.

      * The Ruby parser in rdoc/parse.rb is based heavily on the outstanding
        work of Keiju ISHITSUKA of Nippon Rational Inc, who produced the Ruby
        parser for irb and the rtags package.
  RDoc::Alias:
    main: |-
      Represent an alias, which is an old_name/new_name pair associated with a
      particular context
  RDoc::AnonClass:
    main: |-
      An anonymous class like:

        c = Class.new do end

      AnonClass is currently not used.
  RDoc::AnyMethod:
    main: AnyMethod is the base class for objects representing methods
  RDoc::Attr:
    main: |-
      An attribute created by \#attr, \#attr_reader, \#attr_writer or
      \#attr_accessor
  RDoc::ClassModule:
    main: |-
      ClassModule is the base class for objects representing either a class or a
      module.
  RDoc::CodeObject:
    main: |-
      Base class for the RDoc code tree.

      We contain the common stuff for contexts (which are containers) and other
      elements (methods, attributes and so on)

      Here's the tree of the CodeObject subclasses:

      * RDoc::Context
        * RDoc::TopLevel
        * RDoc::ClassModule
          * RDoc::AnonClass (never used so far)
          * RDoc::NormalClass
          * RDoc::NormalModule
          * RDoc::SingleClass
      * RDoc::MethodAttr
        * RDoc::Attr
        * RDoc::AnyMethod
          * RDoc::GhostMethod
          * RDoc::MetaMethod
      * RDoc::Alias
      * RDoc::Constant
      * RDoc::Mixin
        * RDoc::Require
        * RDoc::Include
  RDoc::Comment:
    main: |-
      A comment holds the text comment for a RDoc::CodeObject and provides a
      unified way of cleaning it up and parsing it into an RDoc::Markup::Document.

      Each comment may have a different markup format set by #format=.  By default
      'rdoc' is used.  The :markup: directive tells RDoc which format to use.

      See RDoc::Markup@Other+directives for instructions on adding an alternate
      format.
  RDoc::Constant:
    main: A constant
  RDoc::Context:
    main: |-
      A Context is something that can hold modules, classes, methods, attributes,
      aliases, requires, and includes. Classes, modules, and files are all
      Contexts.
  RDoc::CrossReference:
    main: RDoc::CrossReference is a reusable way to create cross references for names.
  RDoc::ERBIO:
    main: |-
      A subclass of ERB that writes directly to an IO.  Credit to Aaron Patterson
      and Masatoshi SEKI.

      To use:

        erbio = RDoc::ERBIO.new '<%= "hello world" %>', nil, nil

        File.open 'hello.txt', 'w' do |io|
          erbio.result binding
        end

      Note that binding must enclose the io you wish to output on.
  RDoc::ERBPartial:
    main: |-
      Allows an ERB template to be rendered in the context (binding) of an
      existing ERB template evaluation.
  RDoc::Encoding:
    main: |-
      This class is a wrapper around File IO and Encoding that helps RDoc load
      files and convert them to the correct encoding.
  RDoc::Error:
    main: Exception thrown by any rdoc error.
  RDoc::Extend:
    main: |-
      A Module extension to a class with \#extend

        RDoc::Extend.new 'Enumerable', 'comment ...'
  RDoc::Generator:
    main: |-
      RDoc uses generators to turn parsed source code in the form of an
      RDoc::CodeObject tree into some form of output.  RDoc comes with the HTML
      generator RDoc::Generator::Darkfish and an ri data generator
      RDoc::Generator::RI.

      == Registering a Generator

      Generators are registered by calling RDoc::RDoc.add_generator with the class
      of the generator:

        class My::Awesome::Generator
          RDoc::RDoc.add_generator self
        end

      == Adding Options to +rdoc+

      Before option processing in +rdoc+, RDoc::Options will call ::setup_options
      on the generator class with an RDoc::Options instance.  The generator can
      use RDoc::Options#option_parser to add command-line options to the +rdoc+
      tool.  See RDoc::Options@Custom+Options for an example and see OptionParser
      for details on how to add options.

      You can extend the RDoc::Options instance with additional accessors for your
      generator.

      == Generator Instantiation

      After parsing, RDoc::RDoc will instantiate a generator by calling
      #initialize with an RDoc::Store instance and an RDoc::Options instance.

      The RDoc::Store instance holds documentation for parsed source code.  In
      RDoc 3 and earlier the RDoc::TopLevel class held this data.  When upgrading
      a generator from RDoc 3 and earlier you should only need to replace
      RDoc::TopLevel with the store instance.

      RDoc will then call #generate on the generator instance.  You can use the
      various methods on RDoc::Store and in the RDoc::CodeObject tree to create
      your desired output format.
  RDoc::GhostMethod:
    main: GhostMethod represents a method referenced only by a comment
  RDoc::I18n:
    main: This module provides i18n related features.
  RDoc::Include:
    main: |-
      A Module included in a class with \#include

        RDoc::Include.new 'Enumerable', 'comment ...'
  RDoc::Markdown:
    main: |-
      RDoc::Markdown as described by the [markdown syntax][syntax].

      To choose Markdown as your only default format see
      RDoc::Options@Saved+Options for instructions on setting up a `.doc_options`
      file to store your project default.

      ## Usage

      Here is a brief example of using this parse to read a markdown file by hand.

          data = File.read("README.md")
          formatter = RDoc::Markup::ToHtml.new(RDoc::Options.new, nil)
          html = RDoc::Markdown.parse(data).accept(formatter)

          # do something with html

      ## Extensions

      The following markdown extensions are supported by the parser, but not all
      are used in RDoc output by default.

      ### RDoc

      The RDoc Markdown parser has the following built-in behaviors that cannot be
      disabled.

      Underscores embedded in words are never interpreted as emphasis.  (While the
      [markdown dingus][dingus] emphasizes in-word underscores, neither the
      Markdown syntax nor MarkdownTest mention this behavior.)

      For HTML output, RDoc always auto-links bare URLs.

      ### Break on Newline

      The break_on_newline extension converts all newlines into hard line breaks
      as in [Github Flavored Markdown][GFM].  This extension is disabled by
      default.

      ### CSS

      The #css extension enables CSS blocks to be included in the output, but they
      are not used for any built-in RDoc output format.  This extension is disabled
      by default.

      Example:

          <style type="text/css">
          h1 { font-size: 3em }
          </style>

      ### Definition Lists

      The definition_lists extension allows definition lists using the [PHP
      Markdown Extra syntax][PHPE], but only one label and definition are supported
      at this time.  This extension is enabled by default.

      Example:

      ```
      cat
      :   A small furry mammal
      that seems to sleep a lot

      ant
      :   A little insect that is known
      to enjoy picnics

      ```

      Produces:

      cat
      :   A small furry mammal
      that seems to sleep a lot

      ant
      :   A little insect that is known
      to enjoy picnics

      ### Strike

      Example:

      ```
      This is ~~striked~~.
      ```

      Produces:

      This is ~~striked~~.

      ### Github

      The #github extension enables a partial set of [Github Flavored Markdown]
      [GFM].  This extension is enabled by default.

      Supported github extensions include:

      #### Fenced code blocks

      Use ` ``` ` around a block of code instead of indenting it four spaces.

      #### Syntax highlighting

      Use ` ``` ruby ` as the start of a code fence to add syntax highlighting.
      (Currently only `ruby` syntax is supported).

      ### HTML

      Enables raw HTML to be included in the output.  This extension is enabled by
      default.

      Example:

          <table>
          ...
          </table>

      ### Notes

      The #notes extension enables footnote support.  This extension is enabled by
      default.

      Example:

          Here is some text[^1] including an inline footnote ^[for short footnotes]

          ...

          [^1]: With the footnote text down at the bottom

      Produces:

      Here is some text[^1] including an inline footnote ^[for short footnotes]

      [^1]: With the footnote text down at the bottom

      ## Limitations

      * Link titles are not used
      * Footnotes are collapsed into a single paragraph

      ## Author

      This markdown parser is a port to kpeg from [peg-markdown][pegmarkdown] by
      John MacFarlane.

      It is used under the MIT license:

      Permission is hereby granted, free of charge, to any person obtaining a copy
      of this software and associated documentation files (the "Software"), to deal
      in the Software without restriction, including without limitation the rights
      to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
      copies of the Software, and to permit persons to whom the Software is
      furnished to do so, subject to the following conditions:

      The above copyright notice and this permission notice shall be included in
      all copies or substantial portions of the Software.

      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
      IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
      FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
      AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
      LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
      OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
      THE SOFTWARE.

      The port to kpeg was performed by Eric Hodel and Evan Phoenix

      [dingus]: http://daringfireball.net/projects/markdown/dingus
      [GFM]: http://github.github.com/github-flavored-markdown/
      [pegmarkdown]: https://github.com/jgm/peg-markdown
      [PHPE]: http://michelf.com/projects/php-markdown/extra/#def-list
      [syntax]: http://daringfireball.net/projects/markdown/syntax
  RDoc::Markup:
    main: |-
      RDoc::Markup parses plain text documents and attempts to decompose them into
      their constituent parts.  Some of these parts are high-level: paragraphs,
      chunks of verbatim text, list entries and the like.  Other parts happen at
      the character level: a piece of bold text, a word in code font.  This markup
      is similar in spirit to that used on WikiWiki webs, where folks create web
      pages using a simple set of formatting rules.

      RDoc::Markup and other markup formats do no output formatting, this is
      handled by the RDoc::Markup::Formatter subclasses.

      = Supported Formats

      Besides the RDoc::Markup format, the following formats are built in to RDoc:

      markdown::
        The markdown format as described by
        http://daringfireball.net/projects/markdown/.  See RDoc::Markdown for
        details on the parser and supported extensions.
      rd::
        The rdtool format.  See RDoc::RD for details on the parser and format.
      tomdoc::
        The TomDoc format as described by http://tomdoc.org/.  See RDoc::TomDoc
        for details on the parser and supported extensions.

      You can choose a markup format using the following methods:

      per project::
        If you build your documentation with rake use RDoc::Task#markup.

        If you build your documentation by hand run:

           rdoc --markup your_favorite_format --write-options

        and commit <tt>.rdoc_options</tt> and ship it with your packaged gem.
      per file::
        At the top of the file use the <tt>:markup:</tt> directive to set the
        default format for the rest of the file.
      per comment::
        Use the <tt>:markup:</tt> directive at the top of a comment you want
        to write in a different format.

      = RDoc::Markup

      RDoc::Markup is extensible at runtime: you can add \new markup elements to
      be recognized in the documents that RDoc::Markup parses.

      RDoc::Markup is intended to be the basis for a family of tools which share
      the common requirement that simple, plain-text should be rendered in a
      variety of different output formats and media.  It is envisaged that
      RDoc::Markup could be the basis for formatting RDoc style comment blocks,
      Wiki entries, and online FAQs.

      == Synopsis

      This code converts +input_string+ to HTML.  The conversion takes place in
      the +convert+ method, so you can use the same RDoc::Markup converter to
      convert multiple input strings.

        require 'rdoc'

        h = RDoc::Markup::ToHtml.new(RDoc::Options.new)

        puts h.convert(input_string)

      You can extend the RDoc::Markup parser to recognize new markup
      sequences, and to add regexp handling. Here we make WikiWords significant to
      the parser, and also make the sequences {word} and \<no>text...</no> signify
      strike-through text.  We then subclass the HTML output class to deal
      with these:

        require 'rdoc'

        class WikiHtml < RDoc::Markup::ToHtml
          def handle_regexp_WIKIWORD(target)
            "<font color=red>" + target.text + "</font>"
          end
        end

        markup = RDoc::Markup.new
        markup.add_word_pair("{", "}", :STRIKE)
        markup.add_html("no", :STRIKE)

        markup.add_regexp_handling(/\b([A-Z][a-z]+[A-Z]\w+)/, :WIKIWORD)

        wh = WikiHtml.new RDoc::Options.new, markup
        wh.add_tag(:STRIKE, "<strike>", "</strike>")

        puts "<body>#{wh.convert ARGF.read}</body>"

      == Encoding

      Where Encoding support is available, RDoc will automatically convert all
      documents to the same output encoding.  The output encoding can be set via
      RDoc::Options#encoding and defaults to Encoding.default_external.

      = \RDoc Markup Reference

      == Block Markup

      === Paragraphs and Verbatim

      The markup engine looks for a document's natural left margin.  This is
      used as the initial margin for the document.

      Consecutive lines starting at this margin are considered to be a
      paragraph. Empty lines separate paragraphs.

      Any line that starts to the right of the current margin is treated
      as verbatim text.  This is useful for code listings:

        3.times { puts "Ruby" }

      In verbatim text, two or more blank lines are collapsed into one,
      and trailing blank lines are removed:

        This is the first line

        This is the second non-blank line,
        after 2 blank lines in the source markup.

      There were two trailing blank lines right above this paragraph, that
      have been removed. In addition, the verbatim text has been shifted
      left, so the amount of indentation of verbatim text is unimportant.

      For HTML output RDoc makes a small effort to determine if a verbatim section
      contains Ruby source code.  If so, the verbatim block will be marked up as
      HTML.  Triggers include "def", "class", "module", "require", the "hash
      rocket"# (=>) or a block call with a parameter.

      === Headers

      A line starting with an equal sign (=) is treated as a
      heading.  Level one headings have one equals sign, level two headings
      have two, and so on until level six, which is the maximum
      (seven hyphens or more result in a level six heading).

      For example, the above header was obtained with:

        === Headers

      In HTML output headers have an id matching their name.  The above example's
      HTML is:

        <h3 id="label-Headers">Headers</h3>

      If a heading is inside a method body the id will be prefixed with the
      method's id.  If the above header where in the documentation for a method
      such as:

        ##
        # This method does fun things
        #
        # = Example
        #
        #   Example of fun things goes here ...

        def do_fun_things
        end

      The header's id would be:

        <h1 id="method-i-do_fun_things-label-Example">Example</h1>

      The label can be linked-to using <tt>SomeClass@Headers</tt>.  See
      {Links}[RDoc::Markup@Links] for further details.

      === Rules

      A line starting with three or more hyphens (at the current indent)
      generates a horizontal rule.

        ---

      produces:

      ---

      === Simple Lists

      If a paragraph starts with a "*", "-", "<digit>." or "<letter>.",
      then it is taken to be the start of a list.  The margin is increased to be
      the first non-space following the list start flag.  Subsequent lines
      should be indented to this new margin until the list ends.  For example:

        * this is a list with three paragraphs in
          the first item.  This is the first paragraph.

          And this is the second paragraph.

          1. This is an indented, numbered list.
          2. This is the second item in that list

          This is the third conventional paragraph in the
          first list item.

        * This is the second item in the original list

      produces:

      * this is a list with three paragraphs in
        the first item.  This is the first paragraph.

        And this is the second paragraph.

        1. This is an indented, numbered list.
        2. This is the second item in that list

        This is the third conventional paragraph in the
        first list item.

      * This is the second item in the original list

      === Labeled Lists

      You can also construct labeled lists, sometimes called description
      or definition lists.  Do this by putting the label in square brackets
      and indenting the list body:

        [cat]  a small furry mammal
               that seems to sleep a lot

        [ant]  a little insect that is known
               to enjoy picnics

      produces:

      [cat]  a small furry mammal
             that seems to sleep a lot

      [ant]  a little insect that is known
             to enjoy picnics

      If you want the list bodies to line up to the left of the labels,
      use two colons:

        cat::  a small furry mammal
               that seems to sleep a lot

        ant::  a little insect that is known
               to enjoy picnics

      produces:

      cat::  a small furry mammal
             that seems to sleep a lot

      ant::  a little insect that is known
             to enjoy picnics

      Notice that blank lines right after the label are ignored in labeled lists:

        [one]

            definition 1

        [two]

            definition 2

      produces the same output as

        [one]  definition 1
        [two]  definition 2

      === Lists and Verbatim

      If you want to introduce a verbatim section right after a list, it has to be
      less indented than the list item bodies, but more indented than the list
      label, letter, digit or bullet. For instance:

        *   point 1

        *   point 2, first paragraph

            point 2, second paragraph
              verbatim text inside point 2
            point 2, third paragraph
          verbatim text outside of the list (the list is therefore closed)
        regular paragraph after the list

      produces:

      *   point 1

      *   point 2, first paragraph

          point 2, second paragraph
            verbatim text inside point 2
          point 2, third paragraph
        verbatim text outside of the list (the list is therefore closed)
      regular paragraph after the list

      == Text Markup

      === Bold, Italic, Typewriter Text

      You can use markup within text (except verbatim) to change the
      appearance of parts of that text.  Out of the box, RDoc::Markup
      supports word-based and general markup.

      Word-based markup uses flag characters around individual words:

      <tt>\*_word_\*</tt>::  displays _word_ in a *bold* font
      <tt>\__word_\_</tt>::  displays _word_ in an _emphasized_ font
      <tt>\+_word_\+</tt>::  displays _word_ in a +code+ font

      General markup affects text between a start delimiter and an end
      delimiter.  Not surprisingly, these delimiters look like HTML markup.

      <tt>\<b>_text_</b></tt>::    displays _text_ in a *bold* font
      <tt>\<em>_text_</em></tt>::  displays _text_ in an _emphasized_ font
                                   (alternate tag: <tt>\<i></tt>)
      <tt>\<tt>_text_\</tt></tt>:: displays _text_ in a +code+ font
                                   (alternate tag: <tt>\<code></tt>)

      Unlike conventional Wiki markup, general markup can cross line
      boundaries.  You can turn off the interpretation of markup by
      preceding the first character with a backslash (see <i>Escaping
      Text Markup</i>, below).

      === Links

      Links to starting with +http:+, +https:+, +mailto:+, +ftp:+ or +www.+
      are recognized.  An HTTP url that references an external image is converted
      into an inline image element.

      Classes and methods will be automatically linked to their definition.  For
      example, <tt>RDoc::Markup</tt> will link to this documentation.  By default
      methods will only be automatically linked if they contain an <tt>_</tt> (all
      methods can be automatically linked through the <tt>--hyperlink-all</tt>
      command line option).

      Single-word methods can be linked by using the <tt>#</tt> character for
      instance methods or <tt>::</tt> for class methods.  For example,
      <tt>#convert</tt> links to #convert.  A class or method may be combined like
      <tt>RDoc::Markup#convert</tt>.

      A heading inside the documentation can be linked by following the class
      or method by an <tt>@</tt> then the heading name.
      <tt>RDoc::Markup@Links</tt> will link to this section like this:
      RDoc::Markup@Links.  Spaces in headings with multiple words must be escaped
      with <tt>+</tt> like <tt>RDoc::Markup@Escaping+Text+Markup</tt>.
      Punctuation and other special characters must be escaped like CGI.escape.

      The <tt>@</tt> can also be used to link to sections.  If a section and a
      heading share the same name the section is preferred for the link.

      Links can also be of the form <tt>label[url]</tt>, in which case +label+ is
      used in the displayed text, and +url+ is used as the target.  If +label+
      contains multiple words, put it in braces: <tt>{multi word label}[url]</tt>.
      The +url+ may be an +http:+-type link or a cross-reference to a class,
      module or method with a label.

      Links with the <code>rdoc-image:</code> scheme will create an image tag for
      HTML output.  Only fully-qualified URLs are supported.

      Links with the <tt>rdoc-ref:</tt> scheme will link to the referenced class,
      module, method, file, etc.  If the referenced item is does not exist
      no link will be generated and <tt>rdoc-ref:</tt> will be removed from the
      resulting text.

      Links starting with <tt>rdoc-label:label_name</tt> will link to the
      +label_name+.  You can create a label for the current link (for
      bidirectional links) by supplying a name for the current link like
      <tt>rdoc-label:label-other:label-mine</tt>.

      Links starting with +link:+ refer to local files whose path is relative to
      the <tt>--op</tt> directory.  Use <tt>rdoc-ref:</tt> instead of
      <tt>link:</tt> to link to files generated by RDoc as the link target may
      be different across RDoc generators.

      Example links:

        https://github.com/ruby/rdoc
        mailto:user@example.com
        {RDoc Documentation}[http://rdoc.rubyforge.org]
        {RDoc Markup}[rdoc-ref:RDoc::Markup]

      === Escaping Text Markup

      Text markup can be escaped with a backslash, as in \<tt>, which was obtained
      with <tt>\\<tt></tt>.  Except in verbatim sections and between \<tt> tags,
      to produce a backslash you have to double it unless it is followed by a
      space, tab or newline. Otherwise, the HTML formatter will discard it, as it
      is used to escape potential links:

        * The \ must be doubled if not followed by white space: \\.
        * But not in \<tt> tags: in a Regexp, <tt>\S</tt> matches non-space.
        * This is a link to {ruby-lang}[www.ruby-lang.org].
        * This is not a link, however: \{ruby-lang.org}[www.ruby-lang.org].
        * This will not be linked to \RDoc::RDoc#document

      generates:

      * The \ must be doubled if not followed by white space: \\.
      * But not in \<tt> tags: in a Regexp, <tt>\S</tt> matches non-space.
      * This is a link to {ruby-lang}[www.ruby-lang.org]
      * This is not a link, however: \{ruby-lang.org}[www.ruby-lang.org]
      * This will not be linked to \RDoc::RDoc#document

      Inside \<tt> tags, more precisely, leading backslashes are removed only if
      followed by a markup character (<tt><*_+</tt>), a backslash, or a known link
      reference (a known class or method). So in the example above, the backslash
      of <tt>\S</tt> would be removed if there was a class or module named +S+ in
      the current context.

      This behavior is inherited from RDoc version 1, and has been kept for
      compatibility with existing RDoc documentation.

      === Conversion of characters

      HTML will convert two/three dashes to an em-dash. Other common characters are
      converted as well:

        em-dash::  -- or ---
        ellipsis:: ...

        single quotes:: 'text' or `text'
        double quotes:: "text" or ``text''

        copyright:: (c)
        registered trademark:: (r)

      produces:

      em-dash::  -- or ---
      ellipsis:: ...

      single quotes:: 'text' or `text'
      double quotes:: "text" or ``text''

      copyright:: (c)
      registered trademark:: (r)

      == Documenting Source Code

      Comment blocks can be written fairly naturally, either using <tt>#</tt> on
      successive lines of the comment, or by including the comment in
      a <tt>=begin</tt>/<tt>=end</tt> block.  If you use the latter form,
      the <tt>=begin</tt> line _must_ be flagged with an +rdoc+ tag:

        =begin rdoc
        Documentation to be processed by RDoc.

        ...
        =end

      RDoc stops processing comments if it finds a comment line starting
      with <tt>--</tt> right after the <tt>#</tt> character (otherwise,
      it will be treated as a rule if it has three dashes or more).
      This can be used to separate external from internal comments,
      or to stop a comment being associated with a method, class, or module.
      Commenting can be turned back on with a line that starts with <tt>++</tt>.

        ##
        # Extract the age and calculate the date-of-birth.
        #--
        # FIXME: fails if the birthday falls on February 29th
        #++
        # The DOB is returned as a Time object.

        def get_dob(person)
          # ...
        end

      Names of classes, files, and any method names containing an underscore or
      preceded by a hash character are automatically linked from comment text to
      their description. This linking works inside the current class or module,
      and with ancestor methods (in included modules or in the superclass).

      Method parameter lists are extracted and displayed with the method
      description.  If a method calls +yield+, then the parameters passed to yield
      will also be displayed:

        def fred
          ...
          yield line, address

      This will get documented as:

        fred() { |line, address| ... }

      You can override this using a comment containing ':yields: ...' immediately
      after the method definition

        def fred # :yields: index, position
          # ...

          yield line, address

      which will get documented as

         fred() { |index, position| ... }

      +:yields:+ is an example of a documentation directive.  These appear
      immediately after the start of the document element they are modifying.

      RDoc automatically cross-references words with underscores or camel-case.
      To suppress cross-references, prefix the word with a \ character.  To
      include special characters like "<tt>\n</tt>", you'll need to use
      two \ characters in normal text, but only one in \<tt> text:

        "\\n" or "<tt>\n</tt>"

      produces:

      "\\n" or "<tt>\n</tt>"

      == Directives

      Directives are keywords surrounded by ":" characters.

      === Controlling what is documented

      [+:nodoc:+ / <tt>:nodoc: all</tt>]
        This directive prevents documentation for the element from
        being generated.  For classes and modules, methods, aliases,
        constants, and attributes directly within the affected class or
        module also will be omitted.  By default, though, modules and
        classes within that class or module _will_ be documented.  This is
        turned off by adding the +all+ modifier.

          module MyModule # :nodoc:
            class Input
            end
          end

          module OtherModule # :nodoc: all
            class Output
            end
          end

        In the above code, only class <tt>MyModule::Input</tt> will be documented.

        The +:nodoc:+ directive, like +:enddoc:+, +:stopdoc:+ and +:startdoc:+
        presented below, is local to the current file: if you do not want to
        document a module that appears in several files, specify +:nodoc:+ on each
        appearance, at least once per file.

      [+:stopdoc:+ / +:startdoc:+]
        Stop and start adding new documentation elements to the current container.
        For example, if a class has a number of constants that you don't want to
        document, put a +:stopdoc:+ before the first, and a +:startdoc:+ after the
        last.  If you don't specify a +:startdoc:+ by the end of the container,
        disables documentation for the rest of the current file.

      [+:doc:+]
        Forces a method or attribute to be documented even if it wouldn't be
        otherwise.  Useful if, for example, you want to include documentation of a
        particular private method.

      [+:enddoc:+]
        Document nothing further at the current level: directives +:startdoc:+ and
        +:doc:+ that appear after this will not be honored for the current container
        (file, class or module), in the current file.

      [+:notnew:+ / +:not_new:+ / +:not-new:+ ]
        Only applicable to the +initialize+ instance method.  Normally RDoc
        assumes that the documentation and parameters for +initialize+ are
        actually for the +new+ method, and so fakes out a +new+ for the class.
        The +:notnew:+ directive stops this.  Remember that +initialize+ is private,
        so you won't see the documentation unless you use the +-a+ command line
        option.

      === Method arguments

      [+:arg:+ or +:args:+ _parameters_]
        Overrides the default argument handling with exactly these parameters.

          ##
          #  :args: a, b

          def some_method(*a)
          end

      [+:yield:+ or +:yields:+ _parameters_]
        Overrides the default yield discovery with these parameters.

          ##
          # :yields: key, value

          def each_thing &block
            @things.each(&block)
          end

      [+:call-seq:+]
        Lines up to the next blank line or lines with a common prefix in the
        comment are treated as the method's calling sequence, overriding the
        default parsing of method parameters and yield arguments.

        Multiple lines may be used.

          # :call-seq:
          #   ARGF.readlines(sep=$/)     -> array
          #   ARGF.readlines(limit)      -> array
          #   ARGF.readlines(sep, limit) -> array
          #
          #   ARGF.to_a(sep=$/)     -> array
          #   ARGF.to_a(limit)      -> array
          #   ARGF.to_a(sep, limit) -> array
          #
          # The remaining lines are documentation ...

      === Sections

      Sections allow you to group methods in a class into sensible containers.  If
      you use the sections 'Public', 'Internal' and 'Deprecated' (the three
      allowed method statuses from TomDoc) the sections will be displayed in that
      order placing the most useful methods at the top.  Otherwise, sections will
      be displayed in alphabetical order.

      [+:category:+ _section_]
        Adds this item to the named +section+ overriding the current section.  Use
        this to group methods by section in RDoc output while maintaining a
        sensible ordering (like alphabetical).

          # :category: Utility Methods
          #
          # CGI escapes +text+

          def convert_string text
            CGI.escapeHTML text
          end

        An empty category will place the item in the default category:

          # :category:
          #
          # This method is in the default category

          def some_method
            # ...
          end

        Unlike the :section: directive, :category: is not sticky.  The category
        only applies to the item immediately following the comment.

        Use the :section: directive to provide introductory text for a section of
        documentation.

      [+:section:+ _title_]
        Provides section introductory text in RDoc output.  The title following
        +:section:+ is used as the section name and the remainder of the comment
        containing the section is used as introductory text.  A section's comment
        block must be separated from following comment blocks.  Use an empty title
        to switch to the default section.

        The :section: directive is sticky, so subsequent methods, aliases,
        attributes, and classes will be contained in this section until the
        section is changed.  The :category: directive will override the :section:
        directive.

        A :section: comment block may have one or more lines before the :section:
        directive.  These will be removed, and any identical lines at the end of
        the block are also removed.  This allows you to add visual cues to the
        section.

        Example:

          # ----------------------------------------
          # :section: My Section
          # This is the section that I wrote.
          # See it glisten in the noon-day sun.
          # ----------------------------------------

          ##
          # Comment for some_method

          def some_method
            # ...
          end

      === Other directives

      [+:markup:+ _type_]
        Overrides the default markup type for this comment with the specified
        markup type.  For Ruby files, if the first comment contains this directive
        it is applied automatically to all comments in the file.

        Unless you are converting between markup formats you should use a
        <code>.rdoc_options</code> file to specify the default documentation
        format for your entire project.  See RDoc::Options@Saved+Options for
        instructions.

        At the top of a file the +:markup:+ directive applies to the entire file:

          # coding: UTF-8
          # :markup: TomDoc

          # TomDoc comment here ...

          class MyClass
            # ...

        For just one comment:

            # ...
          end

          # :markup: RDoc
          #
          # This is a comment in RDoc markup format ...

          def some_method
            # ...

        See Markup@CONTRIBUTING for instructions on adding a new markup format.

      [+:include:+ _filename_]
        Include the contents of the named file at this point. This directive
        must appear alone on one line, possibly preceded by spaces. In this
        position, it can be escaped with a \ in front of the first colon.

        The file will be searched for in the directories listed by the +--include+
        option, or in the current directory by default.  The contents of the file
        will be shifted to have the same indentation as the ':' at the start of
        the +:include:+ directive.

      [+:title:+ _text_]
        Sets the title for the document.  Equivalent to the <tt>--title</tt>
        command line parameter.  (The command line parameter overrides any :title:
        directive in the source).

      [+:main:+ _name_]
        Equivalent to the <tt>--main</tt> command line parameter.
  RDoc::MetaMethod:
    main: MetaMethod represents a meta-programmed method
  RDoc::MethodAttr:
    main: Abstract class representing either a method or an attribute.
  RDoc::Mixin:
    main: |-
      A Mixin adds features from a module into another context.  RDoc::Include and
      RDoc::Extend are both mixins.
  RDoc::NormalClass:
    main: A normal class, neither singleton nor anonymous
  RDoc::NormalModule:
    main: A normal module, like NormalClass
  RDoc::Options:
    main: |-
      RDoc::Options handles the parsing and storage of options

      == Saved Options

      You can save some options like the markup format in the
      <tt>.rdoc_options</tt> file in your gem.  The easiest way to do this is:

        rdoc --markup tomdoc --write-options

      Which will automatically create the file and fill it with the options you
      specified.

      The following options will not be saved since they interfere with the user's
      preferences or with the normal operation of RDoc:

      * +--coverage-report+
      * +--dry-run+
      * +--encoding+
      * +--force-update+
      * +--format+
      * +--pipe+
      * +--quiet+
      * +--template+
      * +--verbose+

      == Custom Options

      Generators can hook into RDoc::Options to add generator-specific command
      line options.

      When <tt>--format</tt> is encountered in ARGV, RDoc calls ::setup_options on
      the generator class to add extra options to the option parser.  Options for
      custom generators must occur after <tt>--format</tt>.  <tt>rdoc --help</tt>
      will list options for all installed generators.

      Example:

        class RDoc::Generator::Spellcheck
          RDoc::RDoc.add_generator self

          def self.setup_options rdoc_options
            op = rdoc_options.option_parser

            op.on('--spell-dictionary DICTIONARY',
                  RDoc::Options::Path) do |dictionary|
              rdoc_options.spell_dictionary = dictionary
            end
          end
        end

      Of course, RDoc::Options does not respond to +spell_dictionary+ by default
      so you will need to add it:

        class RDoc::Options

          ##
          # The spell dictionary used by the spell-checking plugin.

          attr_accessor :spell_dictionary

        end

      == Option Validators

      OptionParser validators will validate and cast user input values.  In
      addition to the validators that ship with OptionParser (String, Integer,
      Float, TrueClass, FalseClass, Array, Regexp, Date, Time, URI, etc.),
      RDoc::Options adds Path, PathArray and Template.
  RDoc::Parser:
    main: |-
      A parser is simple a class that subclasses RDoc::Parser and implements #scan
      to fill in an RDoc::TopLevel with parsed data.

      The initialize method takes an RDoc::TopLevel to fill with parsed content,
      the name of the file to be parsed, the content of the file, an RDoc::Options
      object and an RDoc::Stats object to inform the user of parsed items.  The
      scan method is then called to parse the file and must return the
      RDoc::TopLevel object.  By calling super these items will be set for you.

      In order to be used by RDoc the parser needs to register the file extensions
      it can parse.  Use ::parse_files_matching to register extensions.

        require 'rdoc'

        class RDoc::Parser::Xyz < RDoc::Parser
          parse_files_matching /\.xyz$/

          def initialize top_level, file_name, content, options, stats
            super

            # extra initialization if needed
          end

          def scan
            # parse file and fill in @top_level
          end
        end
  RDoc::Parser::C:
    main: |-
      RDoc::Parser::C attempts to parse C extension files.  It looks for
      the standard patterns that you find in extensions: +rb_define_class+,
      +rb_define_method+ and so on.  It tries to find the corresponding
      C source for the methods and extract comments, but if we fail
      we don't worry too much.

      The comments associated with a Ruby method are extracted from the C
      comment block associated with the routine that _implements_ that
      method, that is to say the method whose name is given in the
      +rb_define_method+ call. For example, you might write:

        /*
         * Returns a new array that is a one-dimensional flattening of this
         * array (recursively). That is, for every element that is an array,
         * extract its elements into the new array.
         *
         *    s = [ 1, 2, 3 ]           #=> [1, 2, 3]
         *    t = [ 4, 5, 6, [7, 8] ]   #=> [4, 5, 6, [7, 8]]
         *    a = [ s, t, 9, 10 ]       #=> [[1, 2, 3], [4, 5, 6, [7, 8]], 9, 10]
         *    a.flatten                 #=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
         */
         static VALUE
         rb_ary_flatten(VALUE ary)
         {
             ary = rb_obj_dup(ary);
             rb_ary_flatten_bang(ary);
             return ary;
         }

         ...

         void
         Init_Array(void)
         {
           ...
           rb_define_method(rb_cArray, "flatten", rb_ary_flatten, 0);

      Here RDoc will determine from the +rb_define_method+ line that there's a
      method called "flatten" in class Array, and will look for the implementation
      in the method +rb_ary_flatten+. It will then use the comment from that
      method in the HTML output. This method must be in the same source file
      as the +rb_define_method+.

      The comment blocks may include special directives:

      [Document-class: +name+]
        Documentation for the named class.

      [Document-module: +name+]
        Documentation for the named module.

      [Document-const: +name+]
        Documentation for the named +rb_define_const+.

        Constant values can be supplied on the first line of the comment like so:

          /* 300: The highest possible score in bowling */
          rb_define_const(cFoo, "PERFECT", INT2FIX(300));

        The value can contain internal colons so long as they are escaped with a \

      [Document-global: +name+]
        Documentation for the named +rb_define_global_const+

      [Document-variable: +name+]
        Documentation for the named +rb_define_variable+

      [Document-method\: +method_name+]
        Documentation for the named method.  Use this when the method name is
        unambiguous.

      [Document-method\: <tt>ClassName::method_name</tt>]
        Documentation for a singleton method in the given class.  Use this when
        the method name alone is ambiguous.

      [Document-method\: <tt>ClassName#method_name</tt>]
        Documentation for a instance method in the given class.  Use this when the
        method name alone is ambiguous.

      [Document-attr: +name+]
        Documentation for the named attribute.

      [call-seq:  <i>text up to an empty line</i>]
        Because C source doesn't give descriptive names to Ruby-level parameters,
        you need to document the calling sequence explicitly

      In addition, RDoc assumes by default that the C method implementing a
      Ruby function is in the same source file as the rb_define_method call.
      If this isn't the case, add the comment:

        rb_define_method(....);  // in filename

      As an example, we might have an extension that defines multiple classes
      in its Init_xxx method. We could document them using

        /*
         * Document-class:  MyClass
         *
         * Encapsulate the writing and reading of the configuration
         * file. ...
         */

        /*
         * Document-method: read_value
         *
         * call-seq:
         *   cfg.read_value(key)            -> value
         *   cfg.read_value(key} { |key| }  -> value
         *
         * Return the value corresponding to +key+ from the configuration.
         * In the second form, if the key isn't found, invoke the
         * block and return its value.
         */
  RDoc::Parser::ChangeLog:
    main: |-
      A ChangeLog file parser.

      This parser converts a ChangeLog into an RDoc::Markup::Document.  When
      viewed as HTML a ChangeLog page will have an entry for each day's entries in
      the sidebar table of contents.

      This parser is meant to parse the MRI ChangeLog, but can be used to parse any
      {GNU style Change
      Log}[http://www.gnu.org/prep/standards/html_node/Style-of-Change-Logs.html].
  RDoc::Parser::Markdown:
    main: |-
      Parse a Markdown format file.  The parsed RDoc::Markup::Document is attached
      as a file comment.
  RDoc::Parser::RD:
    main: |-
      Parse a RD format file.  The parsed RDoc::Markup::Document is attached as a
      file comment.
  RDoc::Parser::RubyTools:
    main: Collection of methods for writing parsers
  RDoc::Parser::Simple:
    main: |-
      Parse a non-source file. We basically take the whole thing as one big
      comment.
  RDoc::Parser::Text:
    main: |-
      Indicates this parser is text and doesn't contain code constructs.

      Include this module in a RDoc::Parser subclass to make it show up as a file,
      not as part of a class or module.
  RDoc::RD:
    main: |-
      RDoc::RD implements the RD format from the rdtool gem.

      To choose RD as your only default format see
      RDoc::Options@Saved+Options for instructions on setting up a
      <code>.doc_options</code> file to store your project default.

      == LICENSE

      The grammar that produces RDoc::RD::BlockParser and RDoc::RD::InlineParser
      is included in RDoc under the Ruby License.

      You can find the original source for rdtool at
      https://github.com/uwabami/rdtool/

      You can use, re-distribute or change these files under Ruby's License or GPL.

      1. You may make and give away verbatim copies of the source form of the
         software without restriction, provided that you duplicate all of the
         original copyright notices and associated disclaimers.

      2. You may modify your copy of the software in any way, provided that
         you do at least ONE of the following:

         a. place your modifications in the Public Domain or otherwise
            make them Freely Available, such as by posting said
            modifications to Usenet or an equivalent medium, or by allowing
            the author to include your modifications in the software.

         b. use the modified software only within your corporation or
            organization.

         c. give non-standard binaries non-standard names, with
            instructions on where to get the original software distribution.

         d. make other distribution arrangements with the author.

      3. You may distribute the software in object code or binary form,
         provided that you do at least ONE of the following:

         a. distribute the binaries and library files of the software,
            together with instructions (in the manual page or equivalent)
            on where to get the original distribution.

         b. accompany the distribution with the machine-readable source of
            the software.

         c. give non-standard binaries non-standard names, with
            instructions on where to get the original software distribution.

         d. make other distribution arrangements with the author.

      4. You may modify and include the part of the software into any other
         software (possibly commercial).  But some files in the distribution
         are not written by the author, so that they are not under these terms.

         For the list of those files and their copying conditions, see the
         file LEGAL.

      5. The scripts and library files supplied as input to or produced as
         output from the software do not automatically fall under the
         copyright of the software, but belong to whomever generated them,
         and may be sold commercially, and may be aggregated with this
         software.

      6. THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR
         IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
         WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
         PURPOSE.
  RDoc::RDoc:
    main: |-
      This is the driver for generating RDoc output.  It handles file parsing and
      generation of output.

      To use this class to generate RDoc output via the API, the recommended way
      is:

        rdoc = RDoc::RDoc.new
        options = rdoc.load_options # returns an RDoc::Options instance
        # set extra options
        rdoc.document options

      You can also generate output like the +rdoc+ executable:

        rdoc = RDoc::RDoc.new
        rdoc.document argv

      Where +argv+ is an array of strings, each corresponding to an argument you'd
      give rdoc on the command line.  See <tt>rdoc --help</tt> for details.
  RDoc::RI:
    main: |-
      Namespace for the ri command line tool's implementation.

      See <tt>ri --help</tt> for details.
  RDoc::RI::Error:
    main: Base RI error class
  RDoc::Require:
    main: A file loaded by \#require
  RDoc::RubygemsHook:
    main: |-
      Gem::RDoc provides methods to generate RDoc and ri data for installed gems
      upon gem installation.

      This file is automatically required by RubyGems 1.9 and newer.
  RDoc::Servlet:
    main: |-
      This is a WEBrick servlet that allows you to browse ri documentation.

      You can show documentation through either `ri --server` or, with RubyGems
      2.0 or newer, `gem server`.  For ri, the server runs on port 8214 by
      default.  For RubyGems the server runs on port 8808 by default.

      You can use this servlet in your own project by mounting it on a WEBrick
      server:

        require 'webrick'

        server = WEBrick::HTTPServer.new Port: 8000

        server.mount '/', RDoc::Servlet

      If you want to mount the servlet some other place than the root, provide the
      base path when mounting:

        server.mount '/rdoc', RDoc::Servlet, '/rdoc'
  RDoc::SingleClass:
    main: A singleton class
  RDoc::Stats:
    main: |-
      RDoc statistics collector which prints a summary and report of a project's
      documentation totals.
  RDoc::Store:
    main: |-
      A set of rdoc data for a single project (gem, path, etc.).

      The store manages reading and writing ri data for a project and maintains a
      cache of methods, classes and ancestors in the store.

      The store maintains a #cache of its contents for faster lookup.  After
      adding items to the store it must be flushed using #save_cache.  The cache
      contains the following structures:

         @cache = {
           :ancestors        => {}, # class name => ancestor names
           :attributes       => {}, # class name => attributes
           :class_methods    => {}, # class name => class methods
           :instance_methods => {}, # class name => instance methods
           :modules          => [], # classes and modules in this store
           :pages            => [], # page names
         }
  RDoc::Store::Error:
    main: Errors raised from loading or saving the store
  RDoc::Store::MissingFileError:
    main: Raised when a stored file for a class, module, page or method is missing.
  RDoc::Task:
    main: |-
      RDoc::Task creates the following rake tasks to generate and clean up RDoc
      output:

      [rdoc]
        Main task for this RDoc task.

      [clobber_rdoc]
        Delete all the rdoc files.  This target is automatically added to the main
        clobber target.

      [rerdoc]
        Rebuild the rdoc files from scratch, even if they are not out of date.

      Simple Example:

        require 'rdoc/task'

        RDoc::Task.new do |rdoc|
          rdoc.main = "README.rdoc"
          rdoc.rdoc_files.include("README.rdoc", "lib/**/*.rb")
        end

      The +rdoc+ object passed to the block is an RDoc::Task object. See the
      attributes list for the RDoc::Task class for available customization options.

      == Specifying different task names

      You may wish to give the task a different name, such as if you are
      generating two sets of documentation.  For instance, if you want to have a
      development set of documentation including private methods:

        require 'rdoc/task'

        RDoc::Task.new :rdoc_dev do |rdoc|
          rdoc.main = "README.doc"
          rdoc.rdoc_files.include("README.rdoc", "lib/**/*.rb")
          rdoc.options << "--all"
        end

      The tasks would then be named :<em>rdoc_dev</em>,
      :clobber_<em>rdoc_dev</em>, and :re<em>rdoc_dev</em>.

      If you wish to have completely different task names, then pass a Hash as
      first argument. With the <tt>:rdoc</tt>, <tt>:clobber_rdoc</tt> and
      <tt>:rerdoc</tt> options, you can customize the task names to your liking.

      For example:

        require 'rdoc/task'

        RDoc::Task.new(:rdoc => "rdoc", :clobber_rdoc => "rdoc:clean",
                       :rerdoc => "rdoc:force")

      This will create the tasks <tt>:rdoc</tt>, <tt>:rdoc:clean</tt> and
      <tt>:rdoc:force</tt>.
  RDoc::Text:
    main: Methods for manipulating comment text
  RDoc::TokenStream:
    main: |-
      A TokenStream is a list of tokens, gathered during the parse of some entity
      (say a method). Entities populate these streams by being registered with the
      lexer. Any class can collect tokens by including TokenStream. From the
      outside, you use such an object by calling the start_collecting_tokens
      method, followed by calls to add_token and pop_token.
  RDoc::TomDoc:
    main: |-
      A parser for TomDoc based on TomDoc 1.0.0-rc1 (02adef9b5a)

      The TomDoc specification can be found at:

      http://tomdoc.org

      The latest version of the TomDoc specification can be found at:

      https://github.com/mojombo/tomdoc/blob/master/tomdoc.md

      To choose TomDoc as your only default format see RDoc::Options@Saved+Options
      for instructions on setting up a <code>.rdoc_options</code> file to store
      your project default.

      There are a few differences between this parser and the specification.  A
      best-effort was made to follow the specification as closely as possible but
      some choices to deviate were made.

      A future version of RDoc will warn when a MUST or MUST NOT is violated and
      may warn when a SHOULD or SHOULD NOT is violated.  RDoc will always try
      to emit documentation even if given invalid TomDoc.

      Here are some implementation choices this parser currently makes:

      This parser allows rdoc-style inline markup but you should not depended on
      it.

      This parser allows a space between the comment and the method body.

      This parser does not require the default value to be described for an
      optional argument.

      This parser does not examine the order of sections.  An Examples section may
      precede the Arguments section.

      This class is documented in TomDoc format.  Since this is a subclass of the
      RDoc markup parser there isn't much to see here, unfortunately.
  RDoc::TopLevel:
    main: A TopLevel context is a representation of the contents of a single file
  RDocTask:
    main: |-
      RDoc::Task creates the following rake tasks to generate and clean up RDoc
      output:

      [rdoc]
        Main task for this RDoc task.

      [clobber_rdoc]
        Delete all the rdoc files.  This target is automatically added to the main
        clobber target.

      [rerdoc]
        Rebuild the rdoc files from scratch, even if they are not out of date.

      Simple Example:

        require 'rdoc/task'

        RDoc::Task.new do |rdoc|
          rdoc.main = "README.rdoc"
          rdoc.rdoc_files.include("README.rdoc", "lib/**/*.rb")
        end

      The +rdoc+ object passed to the block is an RDoc::Task object. See the
      attributes list for the RDoc::Task class for available customization options.

      == Specifying different task names

      You may wish to give the task a different name, such as if you are
      generating two sets of documentation.  For instance, if you want to have a
      development set of documentation including private methods:

        require 'rdoc/task'

        RDoc::Task.new :rdoc_dev do |rdoc|
          rdoc.main = "README.doc"
          rdoc.rdoc_files.include("README.rdoc", "lib/**/*.rb")
          rdoc.options << "--all"
        end

      The tasks would then be named :<em>rdoc_dev</em>,
      :clobber_<em>rdoc_dev</em>, and :re<em>rdoc_dev</em>.

      If you wish to have completely different task names, then pass a Hash as
      first argument. With the <tt>:rdoc</tt>, <tt>:clobber_rdoc</tt> and
      <tt>:rerdoc</tt> options, you can customize the task names to your liking.

      For example:

        require 'rdoc/task'

        RDoc::Task.new(:rdoc => "rdoc", :clobber_rdoc => "rdoc:clean",
                       :rerdoc => "rdoc:force")

      This will create the tasks <tt>:rdoc</tt>, <tt>:rdoc:clean</tt> and
      <tt>:rdoc:force</tt>.
readline: {}
reline: {}
resolv:
  Resolv:
    main: |-
      Resolv is a thread-aware DNS resolver library written in Ruby.  Resolv can
      handle multiple DNS requests concurrently without blocking the entire Ruby
      interpreter.

      See also resolv-replace.rb to replace the libc resolver with Resolv.

      Resolv can look up various DNS resources using the DNS module directly.

      Examples:

        p Resolv.getaddress "www.ruby-lang.org"
        p Resolv.getname "210.251.121.214"

        Resolv::DNS.open do |dns|
          ress = dns.getresources "www.ruby-lang.org", Resolv::DNS::Resource::IN::A
          p ress.map(&:address)
          ress = dns.getresources "ruby-lang.org", Resolv::DNS::Resource::IN::MX
          p ress.map { |r| [r.exchange.to_s, r.preference] }
        end

      == Bugs

      * NIS is not supported.
      * /etc/nsswitch.conf is not supported.
  Resolv::DNS:
    main: |-
      Resolv::DNS is a DNS stub resolver.

      Information taken from the following places:

      * STD0013
      * RFC 1035
      * ftp://ftp.isi.edu/in-notes/iana/assignments/dns-parameters
      * etc.
  Resolv::DNS::Config::NXDomain:
    main: Indicates no such domain was found.
  Resolv::DNS::Config::OtherResolvError:
    main: Indicates some other unhandled resolver error was encountered.
  Resolv::DNS::DecodeError:
    main: Indicates that the DNS response was unable to be decoded.
  Resolv::DNS::EncodeError:
    main: Indicates that the DNS request was unable to be encoded.
  Resolv::DNS::Name:
    main: A representation of a DNS name.
  Resolv::DNS::Query:
    main: A DNS query abstract class.
  Resolv::DNS::Requester::RequestError:
    main: Indicates a problem with the DNS request.
  Resolv::DNS::Resource:
    main: A DNS resource abstract class.
  Resolv::DNS::Resource::ANY:
    main: A Query type requesting any RR.
  Resolv::DNS::Resource::CNAME:
    main: The canonical name for an alias.
  Resolv::DNS::Resource::DomainName:
    main: Domain Name resource abstract class.
  Resolv::DNS::Resource::Generic:
    main: A generic resource abstract class.
  Resolv::DNS::Resource::HINFO:
    main: Host Information resource.
  Resolv::DNS::Resource::IN:
    main: module IN contains ARPA Internet specific RRs.
  Resolv::DNS::Resource::IN::A:
    main: IPv4 Address resource
  Resolv::DNS::Resource::IN::AAAA:
    main: An IPv6 address record.
  Resolv::DNS::Resource::IN::SRV:
    main: |-
      SRV resource record defined in RFC 2782

      These records identify the hostname and port that a service is
      available at.
  Resolv::DNS::Resource::IN::WKS:
    main: Well Known Service resource.
  Resolv::DNS::Resource::LOC:
    main: Location resource
  Resolv::DNS::Resource::MINFO:
    main: Mailing list or mailbox information.
  Resolv::DNS::Resource::MX:
    main: Mail Exchanger resource.
  Resolv::DNS::Resource::NS:
    main: An authoritative name server.
  Resolv::DNS::Resource::PTR:
    main: A Pointer to another DNS name.
  Resolv::DNS::Resource::SOA:
    main: Start Of Authority resource.
  Resolv::DNS::Resource::TXT:
    main: Unstructured text resource.
  Resolv::Hosts:
    main: Resolv::Hosts is a hostname resolver that uses the system hosts file.
  Resolv::IPv4:
    main: A Resolv::DNS IPv4 address.
  Resolv::IPv6:
    main: A Resolv::DNS IPv6 address.
  Resolv::LOC::Alt:
    main: A Resolv::LOC::Alt
  Resolv::LOC::Coord:
    main: A Resolv::LOC::Coord
  Resolv::LOC::Size:
    main: A Resolv::LOC::Size
  Resolv::MDNS:
    main: |-
      Resolv::MDNS is a one-shot Multicast DNS (mDNS) resolver.  It blindly
      makes queries to the mDNS addresses without understanding anything about
      multicast ports.

      Information taken form the following places:

      * RFC 6762
  Resolv::ResolvError:
    main: Indicates a failure to resolve a name or address.
  Resolv::ResolvTimeout:
    main: Indicates a timeout resolving a name or address.
resolv-replace: {}
rexml:
  REXML:
    main: |-
      REXML is an XML toolkit for Ruby[http://www.ruby-lang.org], in Ruby.

      REXML is a _pure_ Ruby, XML 1.0 conforming,
      non-validating[http://www.w3.org/TR/2004/REC-xml-20040204/#sec-conformance]
      toolkit with an intuitive API.  REXML passes 100% of the non-validating Oasis
      tests[http://www.oasis-open.org/committees/xml-conformance/xml-test-suite.shtml],
      and provides tree, stream, SAX2, pull, and lightweight APIs.  REXML also
      includes a full XPath[http://www.w3c.org/tr/xpath] 1.0 implementation. Since
      Ruby 1.8, REXML is included in the standard Ruby distribution.

      Main page:: http://www.germane-software.com/software/rexml
      Author:: Sean Russell <serATgermaneHYPHENsoftwareDOTcom>
      Date:: 2008/019
      Version:: 3.1.7.3

      This API documentation can be downloaded from the REXML home page, or can
      be accessed online[http://www.germane-software.com/software/rexml_doc]

      A tutorial is available in the REXML distribution in docs/tutorial.html,
      or can be accessed
      online[http://www.germane-software.com/software/rexml/docs/tutorial.html]
  REXML::AttlistDecl:
    main: |-
      This class needs:
      * Documentation
      * Work!  Not all types of attlists are intelligently parsed, so we just
      spew back out what we get in.  This works, but it would be better if
      we formatted the output ourselves.

      AttlistDecls provide *just* enough support to allow namespace
      declarations.  If you need some sort of generalized support, or have an
      interesting idea about how to map the hideous, terrible design of DTD
      AttlistDecls onto an intuitive Ruby interface, let me know.  I'm desperate
      for anything to make DTDs more palateable.
  REXML::Attribute:
    main: |-
      Defines an Element Attribute; IE, a attribute=value pair, as in:
      <element attribute="value"/>.  Attributes can be in their own
      namespaces.  General users of REXML will not interact with the
      Attribute class much.
  REXML::Attributes:
    main: |-
      A class that defines the set of Attributes of an Element and provides
      operations for accessing elements in that set.
  REXML::Child:
    main: |-
      A Child object is something contained by a parent, and this class
      contains methods to support that.  Most user code will not use this
      class directly.
  REXML::Comment:
    main: Represents an XML comment; that is, text between \<!-- ... -->
  REXML::Declaration:
    main: |-
      This is an abstract class.  You never use this directly; it serves as a
      parent class for the specific declarations.
  REXML::DocType:
    main: |-
      Represents an XML DOCTYPE declaration; that is, the contents of <!DOCTYPE
      ... >.  DOCTYPES can be used to declare the DTD of a document, as well as
      being used to declare entities used in the document.
  REXML::Document:
    main: |-
      Represents a full XML document, including PIs, a doctype, etc.  A
      Document has a single child that can be accessed by root().
      Note that if you want to have an XML declaration written for a document
      you create, you must add one; REXML documents do not write a default
      declaration for you.  See |DECLARATION| and |write|.
  REXML::Element:
    main: |-
      Represents a tagged XML element.  Elements are characterized by
      having children, attributes, and names, and can themselves be
      children.
  REXML::Elements:
    main: |-
      A class which provides filtering of children for Elements, and
      XPath search support.  You are expected to only encounter this class as
      the <tt>element.elements</tt> object.  Therefore, you are
      _not_ expected to instantiate this yourself.
  REXML::EntityConst:
    main: |-
      This is a set of entity constants -- the ones defined in the XML
      specification.  These are +gt+, +lt+, +amp+, +quot+ and +apos+.
      CAUTION: these entities does not have parent and document
  REXML::Formatters::Pretty:
    main: |-
      Pretty-prints an XML document.  This destroys whitespace in text nodes
      and will insert carriage returns and indentations.

      TODO: Add an option to print attributes on new lines
  REXML::Formatters::Transitive:
    main: |-
      The Transitive formatter writes an XML document that parses to an
      identical document as the source document.  This means that no extra
      whitespace nodes are inserted, and whitespace within text nodes is
      preserved.  Within these constraints, the document is pretty-printed,
      with whitespace inserted into the metadata to introduce formatting.

      Note that this is only useful if the original XML is not already
      formatted.  Since this formatter does not alter whitespace nodes, the
      results of formatting already formatted XML will be odd.
  REXML::Functions:
    main: |-
      If you add a method, keep in mind two things:
      (1) the first argument will always be a list of nodes from which to
      filter.  In the case of context methods (such as position), the function
      should return an array with a value for each child in the array.
      (2) all method calls from XML will have "-" replaced with "_".
      Therefore, in XML, "local-name()" is identical (and actually becomes)
      "local_name()"
  REXML::IOSource:
    main: |-
      A Source that wraps an IO.  See the Source class for method
      documentation
  REXML::Instruction:
    main: |-
      Represents an XML Instruction; IE, <? ... ?>
      TODO: Add parent arg (3rd arg) to constructor
  REXML::Light::Node:
    main: |-
      Represents a tagged XML element.  Elements are characterized by
      having children, attributes, and names, and can themselves be
      children.
  REXML::Namespace:
    main: Adds named attributes to an object.
  REXML::Node:
    main: |-
      Represents a node in the tree.  Nodes are never encountered except as
      superclasses of other objects.  Nodes have siblings.
  REXML::Parent:
    main: |-
      A parent has children, and has methods for accessing them.  The Parent
      class is never encountered except as the superclass for some other
      object.
  REXML::Parsers::BaseParser:
    main: |-
      = Using the Pull Parser
      <em>This API is experimental, and subject to change.</em>
       parser = PullParser.new( "<a>text<b att='val'/>txet</a>" )
       while parser.has_next?
         res = parser.next
         puts res[1]['att'] if res.start_tag? and res[0] == 'b'
       end
      See the PullEvent class for information on the content of the results.
      The data is identical to the arguments passed for the various events to
      the StreamListener API.

      Notice that:
       parser = PullParser.new( "<a>BAD DOCUMENT" )
       while parser.has_next?
         res = parser.next
         raise res[1] if res.error?
       end

      Nat Price gave me some good ideas for the API.
  REXML::Parsers::PullEvent:
    main: |-
      A parsing event.  The contents of the event are accessed as an +Array?,
      and the type is given either by the ...? methods, or by accessing the
      +type+ accessor.  The contents of this object vary from event to event,
      but are identical to the arguments passed to +StreamListener+s for each
      event.
  REXML::Parsers::PullParser:
    main: |-
      = Using the Pull Parser
      <em>This API is experimental, and subject to change.</em>
       parser = PullParser.new( "<a>text<b att='val'/>txet</a>" )
       while parser.has_next?
         res = parser.next
         puts res[1]['att'] if res.start_tag? and res[0] == 'b'
       end
      See the PullEvent class for information on the content of the results.
      The data is identical to the arguments passed for the various events to
      the StreamListener API.

      Notice that:
       parser = PullParser.new( "<a>BAD DOCUMENT" )
       while parser.has_next?
         res = parser.next
         raise res[1] if res.error?
       end

      Nat Price gave me some good ideas for the API.
  REXML::Parsers::SAX2Parser:
    main: SAX2Parser
  REXML::Parsers::XPathParser:
    main: |-
      You don't want to use this class.  Really.  Use XPath, which is a wrapper
      for this class.  Believe me.  You don't want to poke around in here.
      There is strange, dark magic at work in this code.  Beware.  Go back!  Go
      back while you still can!
  REXML::SAX2Listener:
    main: |-
      A template for stream parser listeners.
      Note that the declarations (attlistdecl, elementdecl, etc) are trivially
      processed; REXML doesn't yet handle doctype entity declarations, so you
      have to parse them out yourself.
      === Missing methods from SAX2
       ignorable_whitespace
      === Methods extending SAX2
      +WARNING+
      These methods are certainly going to change, until DTDs are fully
      supported.  Be aware of this.
       start_document
       end_document
       doctype
       elementdecl
       attlistdecl
       entitydecl
       notationdecl
       cdata
       xmldecl
       comment
  REXML::Source:
    main: |-
      A Source can be searched for patterns, and wraps buffers and other
      objects and provides consumption of text
  REXML::SourceFactory:
    main: Generates Source-s.  USE THIS CLASS.
  REXML::StreamListener:
    main: |-
      A template for stream parser listeners.
      Note that the declarations (attlistdecl, elementdecl, etc) are trivially
      processed; REXML doesn't yet handle doctype entity declarations, so you
      have to parse them out yourself.
  REXML::Text:
    main: Represents text nodes in an XML document
  REXML::Validation::RelaxNG:
    main: |-
      Implemented:
      * empty
      * element
      * attribute
      * text
      * optional
      * choice
      * oneOrMore
      * zeroOrMore
      * group
      * value
      * interleave
      * mixed
      * ref
      * grammar
      * start
      * define

      Not implemented:
      * data
      * param
      * include
      * externalRef
      * notAllowed
      * anyName
      * nsName
      * except
      * name
  REXML::XMLDecl:
    main: NEEDS DOCUMENTATION
  REXML::XMLTokens:
    main: |-
      Defines a number of tokens used for parsing XML.  Not for general
      consumption.
  REXML::XPath:
    main: Wrapper class.  Use this class to access the XPath functions.
  REXML::XPathNode:
    main: "@private"
  REXML::XPathParser:
    main: |-
      You don't want to use this class.  Really.  Use XPath, which is a wrapper
      for this class.  Believe me.  You don't want to poke around in here.
      There is strange, dark magic at work in this code.  Beware.  Go back!  Go
      back while you still can!
rinda:
  Rinda:
    main: |-
      A module to implement the Linda distributed computing paradigm in Ruby.

      Rinda is part of DRb (dRuby).

      == Example(s)

      See the sample/drb/ directory in the Ruby distribution, from 1.8.2 onwards.
  Rinda::DRbObjectTemplate:
    main: "<i>Documentation?</i>"
  Rinda::InvalidHashTupleKey:
    main: Raised when a hash-based tuple has an invalid key.
  Rinda::NotifyTemplateEntry:
    main: |-
      A NotifyTemplateEntry is returned by TupleSpace#notify and is notified of
      TupleSpace changes.  You may receive either your subscribed event or the
      'close' event when iterating over notifications.

      See TupleSpace#notify_event for valid notification types.

      == Example

        ts = Rinda::TupleSpace.new
        observer = ts.notify 'write', [nil]

        Thread.start do
          observer.each { |t| p t }
        end

        3.times { |i| ts.write [i] }

      Outputs:

        ['write', [0]]
        ['write', [1]]
        ['write', [2]]
  Rinda::RequestCanceledError:
    main: Raised when trying to use a canceled tuple.
  Rinda::RequestExpiredError:
    main: Raised when trying to use an expired tuple.
  Rinda::RindaError:
    main: Rinda error base class
  Rinda::RingFinger:
    main: |-
      RingFinger is used by RingServer clients to discover the RingServer's
      TupleSpace.  Typically, all a client needs to do is call
      RingFinger.primary to retrieve the remote TupleSpace, which it can then
      begin using.

      To find the first available remote TupleSpace:

        Rinda::RingFinger.primary

      To create a RingFinger that broadcasts to a custom list:

        rf = Rinda::RingFinger.new  ['localhost', '192.0.2.1']
        rf.primary

      Rinda::RingFinger also understands multicast addresses and sets them up
      properly.  This allows you to run multiple RingServers on the same host:

        rf = Rinda::RingFinger.new ['239.0.0.1']
        rf.primary

      You can set the hop count (or TTL) for multicast searches using
      #multicast_hops.

      If you use IPv6 multicast you may need to set both an address and the
      outbound interface index:

        rf = Rinda::RingFinger.new ['ff02::1']
        rf.multicast_interface = 1
        rf.primary

      At this time there is no easy way to get an interface index by name.
  Rinda::RingProvider:
    main: |-
      RingProvider uses a RingServer advertised TupleSpace as a name service.
      TupleSpace clients can register themselves with the remote TupleSpace and
      look up other provided services via the remote TupleSpace.

      Services are registered with a tuple of the format [:name, klass,
      DRbObject, description].
  Rinda::RingServer:
    main: |-
      A RingServer allows a Rinda::TupleSpace to be located via UDP broadcasts.
      Default service location uses the following steps:

      1. A RingServer begins listening on the network broadcast UDP address.
      2. A RingFinger sends a UDP packet containing the DRb URI where it will
         listen for a reply.
      3. The RingServer receives the UDP packet and connects back to the
         provided DRb URI with the DRb service.

      A RingServer requires a TupleSpace:

        ts = Rinda::TupleSpace.new
        rs = Rinda::RingServer.new

      RingServer can also listen on multicast addresses for announcements.  This
      allows multiple RingServers to run on the same host.  To use network
      broadcast and multicast:

        ts = Rinda::TupleSpace.new
        rs = Rinda::RingServer.new ts, %w[Socket::INADDR_ANY, 239.0.0.1 ff02::1]
  Rinda::SimpleRenewer:
    main: |-
      An SimpleRenewer allows a TupleSpace to check if a TupleEntry is still
      alive.
  Rinda::Template:
    main: Templates are used to match tuples in Rinda.
  Rinda::TemplateEntry:
    main: A TemplateEntry is a Template together with expiry and cancellation data.
  Rinda::Tuple:
    main: |-
      A tuple is the elementary object in Rinda programming.
      Tuples may be matched against templates if the tuple and
      the template are the same size.
  Rinda::TupleBag:
    main: |-
      TupleBag is an unordered collection of tuples. It is the basis
      of Tuplespace.
  Rinda::TupleEntry:
    main: |-
      A TupleEntry is a Tuple (i.e. a possible entry in some Tuplespace)
      together with expiry and cancellation data.
  Rinda::TupleSpace:
    main: |-
      The Tuplespace manages access to the tuples it contains,
      ensuring mutual exclusion requirements are met.

      The +sec+ option for the write, take, move, read and notify methods may
      either be a number of seconds or a Renewer object.
  Rinda::TupleSpaceProxy:
    main: TupleSpaceProxy allows a remote Tuplespace to appear as local.
  Rinda::WaitTemplateEntry:
    main: "<i>Documentation?</i>"
rss:
  RSS:
    main: |-
      = RSS reading and writing

      Really Simple Syndication (RSS) is a family of formats that describe 'feeds,'
      specially constructed XML documents that allow an interested person to
      subscribe and receive updates from a particular web service. This portion of
      the standard library provides tooling to read and create these feeds.

      The standard library supports RSS 0.91, 1.0, 2.0, and Atom, a related format.
      Here are some links to the standards documents for these formats:

      * RSS
        * 0.9.1[http://www.rssboard.org/rss-0-9-1-netscape]
        * 1.0[http://web.resource.org/rss/1.0/]
        * 2.0[http://www.rssboard.org/rss-specification]
      * Atom[http://tools.ietf.org/html/rfc4287]

      == Consuming RSS

      If you'd like to read someone's RSS feed with your Ruby code, you've come to
      the right place. It's really easy to do this, but we'll need the help of
      open-uri:

        require 'rss'
        require 'open-uri'

        url = 'http://www.ruby-lang.org/en/feeds/news.rss'
        open(url) do |rss|
          feed = RSS::Parser.parse(rss)
          puts "Title: #{feed.channel.title}"
          feed.items.each do |item|
            puts "Item: #{item.title}"
          end
        end

      As you can see, the workhorse is RSS::Parser#parse, which takes the source of
      the feed and a parameter that performs validation on the feed. We get back an
      object that has all of the data from our feed, accessible through methods.
      This example shows getting the title out of the channel element, and looping
      through the list of items.

      == Producing RSS

      Producing our own RSS feeds is easy as well. Let's make a very basic feed:

        require "rss"

        rss = RSS::Maker.make("atom") do |maker|
          maker.channel.author = "matz"
          maker.channel.updated = Time.now.to_s
          maker.channel.about = "http://www.ruby-lang.org/en/feeds/news.rss"
          maker.channel.title = "Example Feed"

          maker.items.new_item do |item|
            item.link = "http://www.ruby-lang.org/en/news/2010/12/25/ruby-1-9-2-p136-is-released/"
            item.title = "Ruby 1.9.2-p136 is released"
            item.updated = Time.now.to_s
          end
        end

        puts rss

      As you can see, this is a very Builder-like DSL. This code will spit out an
      Atom feed with one item. If we needed a second item, we'd make another block
      with maker.items.new_item and build a second one.

      == Copyright

      Copyright (c) 2003-2007 Kouhei Sutou <kou@cozmixng.org>

      You can redistribute it and/or modify it under the same terms as Ruby.

      There is an additional tutorial by the author of RSS at:
      http://www.cozmixng.org/~rwiki/?cmd=view;name=RSS+Parser%3A%3ATutorial.en
  RSS::Atom:
    main: |-
      Atom is an XML-based document format that is used to describe 'feeds' of related information.
      A typical use is in a news feed where the information is periodically updated and which users
      can subscribe to.  The Atom format is described in http://tools.ietf.org/html/rfc4287

      The Atom module provides support in reading and creating feeds.

      See the RSS module for examples consuming and creating feeds.
  RSS::Atom::DateConstruct:
    main: |-
      Element used to describe an Atom date and time in the ISO 8601 format

      Examples:
      * 2013-03-04T15:30:02Z
      * 2013-03-04T10:30:02-05:00
  RSS::Atom::Entry:
    main: |-
      Defines a top-level Atom Entry element,
      used as the document element of a stand-alone Atom Entry Document.
      It has the following attributes:

      * author
      * category
      * categories
      * content
      * contributor
      * id
      * link
      * published
      * rights
      * source
      * summary
      * title
      * updated

      Reference: https://validator.w3.org/feed/docs/rfc4287.html#element.entry]
  RSS::Atom::Feed:
    main: |-
      Defines the top-level element of an Atom Feed Document.
      It consists of a number of children Entry elements,
      and has the following attributes:

      * author
      * categories
      * category
      * content
      * contributor
      * entries (aliased as items)
      * entry
      * generator
      * icon
      * id
      * link
      * logo
      * rights
      * subtitle
      * title
      * updated

      Reference: https://validator.w3.org/feed/docs/rfc4287.html#element.feed
  RSS::Atom::Feed::Author:
    main: |-
      PersonConstruct that contains information regarding the author
      of a Feed or Entry.

      Reference: https://validator.w3.org/feed/docs/rfc4287.html#element.author
  RSS::Atom::Feed::Category:
    main: |-
      Contains information about a category associated with a Feed or Entry.
      It has the following attributes:

      * term
      * scheme
      * label

      Reference: https://validator.w3.org/feed/docs/rfc4287.html#element.category
  RSS::Atom::Feed::Contributor:
    main: |-
      PersonConstruct that contains information regarding the
      contributors of a Feed or Entry.

      Reference: https://validator.w3.org/feed/docs/rfc4287.html#element.contributor
  RSS::Atom::Feed::Entry:
    main: |-
      Defines a child Atom Entry element of an Atom Feed element.
      It has the following attributes:

      * author
      * category
      * categories
      * content
      * contributor
      * id
      * link
      * published
      * rights
      * source
      * summary
      * title
      * updated

      Reference: https://validator.w3.org/feed/docs/rfc4287.html#element.entry
  RSS::Atom::Feed::Entry::Content:
    main: |-
      Contains or links to the content of the Entry.
      It has the following attributes:

      * type
      * src

      Reference: https://validator.w3.org/feed/docs/rfc4287.html#element.content
  RSS::Atom::Feed::Entry::Published:
    main: |-
      DateConstruct that usually indicates the time of the initial
      creation of an Entry.

      Reference: https://validator.w3.org/feed/docs/rfc4287.html#element.published
  RSS::Atom::Feed::Entry::Source:
    main: |-
      Defines a Atom Source element. It has the following attributes:

      * author
      * category
      * categories
      * content
      * contributor
      * generator
      * icon
      * id
      * link
      * logo
      * rights
      * subtitle
      * title
      * updated

      Reference: https://validator.w3.org/feed/docs/rfc4287.html#element.source
  RSS::Atom::Feed::Entry::Summary:
    main: |-
      TextConstruct that describes a summary of the Entry.

      Reference: https://validator.w3.org/feed/docs/rfc4287.html#element.summary
  RSS::Atom::Feed::Generator:
    main: |-
      Contains information on the agent used to generate the feed.

      Reference: https://validator.w3.org/feed/docs/rfc4287.html#element.generator
  RSS::Atom::Feed::Icon:
    main: |-
      Defines an image that provides a visual identification for a eed.
      The image should have an aspect ratio of 1:1.

      Reference: https://validator.w3.org/feed/docs/rfc4287.html#element.icon
  RSS::Atom::Feed::Id:
    main: |-
      Defines the Universally Unique Identifier (UUID) for a Feed or Entry.

      Reference: https://validator.w3.org/feed/docs/rfc4287.html#element.id
  RSS::Atom::Feed::Link:
    main: |-
      Defines a reference to a Web resource. It has the following
      attributes:

      * href
      * rel
      * type
      * hreflang
      * title
      * length

      Reference: https://validator.w3.org/feed/docs/rfc4287.html#element.link
  RSS::Atom::Feed::Logo:
    main: |-
      Defines an image that provides a visual identification for the Feed.
      The image should have an aspect ratio of 2:1 (horizontal:vertical).

      Reference: https://validator.w3.org/feed/docs/rfc4287.html#element.logo
  RSS::Atom::Feed::Rights:
    main: |-
      TextConstruct that contains copyright information regarding
      the content in an Entry or Feed. It should not be used to
      convey machine readable licensing information.

      Reference: https://validator.w3.org/feed/docs/rfc4287.html#element.rights
  RSS::Atom::Feed::Subtitle:
    main: |-
      TextConstruct that conveys a description or subtitle for a Feed.

      Reference: https://validator.w3.org/feed/docs/rfc4287.html#element.subtitle
  RSS::Atom::Feed::Title:
    main: |-
      TextConstruct that conveys a description or title for a Feed or Entry.

      Reference: https://validator.w3.org/feed/docs/rfc4287.html#element.title
  RSS::Atom::Feed::Updated:
    main: |-
      DateConstruct indicating the most recent time when a Feed or
      Entry was modified in a way the publisher considers
      significant.

      Reference: https://validator.w3.org/feed/docs/rfc4287.html#element.updated
  RSS::Atom::PersonConstruct:
    main: |-
      The PersonConstruct module is used to define a person Atom element that can be
      used to describe a person, corporation or similar entity.

      The PersonConstruct has a Name, Uri and Email child elements.

      Reference: https://validator.w3.org/feed/docs/rfc4287.html#atomPersonConstruct
  RSS::Atom::PersonConstruct::Email:
    main: |-
      The email of the person or entity.

      Reference: https://validator.w3.org/feed/docs/rfc4287.html#element.email
  RSS::Atom::PersonConstruct::Name:
    main: |-
      The name of the person or entity.

      Reference: https://validator.w3.org/feed/docs/rfc4287.html#element.name
  RSS::Atom::PersonConstruct::Uri:
    main: |-
      The URI of the person or entity.

      Reference: https://validator.w3.org/feed/docs/rfc4287.html#element.uri
  RSS::Atom::TextConstruct:
    main: |-
      The TextConstruct module is used to define a Text construct Atom element,
      which is used to store small quantities of human-readable text.

      The TextConstruct has a type attribute, e.g. text, html, xhtml

      Reference: https://validator.w3.org/feed/docs/rfc4287.html#text.constructs
  RSS::ConversionError:
    main: Raised when a conversion failure occurs.
  RSS::Error:
    main: |-
      The basic error all other RSS errors stem from. Rescue this error if you
      want to handle any given RSS error and you don't care about the details.
  RSS::InvalidRSSError:
    main: |-
      The InvalidRSSError error is the base class for a variety of errors
      related to a poorly-formed RSS feed. Rescue this error if you only
      care that a file could be invalid, but don't care how it is invalid.
  RSS::Maker:
    main: |-
      Provides a set of builders for various RSS objects

      * Feeds
        * RSS 0.91
        * RSS 1.0
        * RSS 2.0
        * Atom 1.0

      * Elements
        * Atom::Entry
  RSS::MissingAttributeError:
    main: |-
      Certain attributes are required on specific tags in an RSS feed. If a feed
      is missing one of these attributes, a MissingAttributeError is raised.
  RSS::MissingTagError:
    main: |-
      Since RSS is based on XML, it must have opening and closing tags that
      match. If they don't, a MissingTagError will be raised.
  RSS::NotAvailableValueError:
    main: |-
      Attributes are in key-value form, and if there's no value provided for an
      attribute, a NotAvailableValueError will be raised.
  RSS::NotExpectedTagError:
    main: Raised when an unexpected tag is encountered.
  RSS::NotSetError:
    main: Raised when a required variable is not set.
  RSS::OverlappedPrefixError:
    main: |-
      RSS, being an XML-based format, has namespace support. If two namespaces are
      declared with the same name, an OverlappedPrefixError will be raised.
  RSS::RSS09:
    main: |-
      = RSS 0.9 support

      RSS has three different versions. This module contains support for version
      0.9.1[http://www.rssboard.org/rss-0-9-1-netscape].

      == Producing RSS 0.9

      Producing our own RSS feeds is easy as well. Let's make a very basic feed:

       require "rss"

       rss = RSS::Maker.make("0.91") do |maker|
         maker.channel.language = "en"
         maker.channel.author = "matz"
         maker.channel.updated = Time.now.to_s
         maker.channel.link = "http://www.ruby-lang.org/en/feeds/news.rss"
         maker.channel.title = "Example Feed"
         maker.channel.description = "A longer description of my feed."
         maker.image.url = "http://www.ruby-lang.org/images/logo.gif"
         maker.image.title = "An image"
         maker.items.new_item do |item|
           item.link = "http://www.ruby-lang.org/en/news/2010/12/25/ruby-1-9-2-p136-is-released/"
           item.title = "Ruby 1.9.2-p136 is released"
           item.updated = Time.now.to_s
         end
       end

       puts rss

      As you can see, this is a very Builder-like DSL. This code will spit out an
      RSS 0.9 feed with one item. If we needed a second item, we'd make another
      block with maker.items.new_item and build a second one.
  RSS::RSS10:
    main: |-
      = RSS 1.0 support

      RSS has three different versions. This module contains support for version
      1.0[http://web.resource.org/rss/1.0/]

      == Producing RSS 1.0

      Producing our own RSS feeds is easy as well. Let's make a very basic feed:

       require "rss"

       rss = RSS::Maker.make("1.0") do |maker|
         maker.channel.language = "en"
         maker.channel.author = "matz"
         maker.channel.about = "About my feed."
         maker.channel.updated = Time.now.to_s
         maker.channel.link = "http://www.ruby-lang.org/en/feeds/news.rss"
         maker.channel.title = "Example Feed"
         maker.channel.description = "A longer description of my feed."
         maker.items.new_item do |item|
           item.link = "http://www.ruby-lang.org/en/news/2010/12/25/ruby-1-9-2-p136-is-released/"
           item.title = "Ruby 1.9.2-p136 is released"
           item.updated = Time.now.to_s
         end
       end

       puts rss

      As you can see, this is a very Builder-like DSL. This code will spit out an
      RSS 1.0 feed with one item. If we needed a second item, we'd make another
      block with maker.items.new_item and build a second one.
  RSS::Rss:
    main: |-
      = RSS 2.0 support

      RSS has three different versions. This module contains support for version
      2.0[http://www.rssboard.org/rss-specification]

      == Producing RSS 2.0

      Producing our own RSS feeds is easy as well. Let's make a very basic feed:

       require "rss"

       rss = RSS::Maker.make("2.0") do |maker|
         maker.channel.language = "en"
         maker.channel.author = "matz"
         maker.channel.updated = Time.now.to_s
         maker.channel.link = "http://www.ruby-lang.org/en/feeds/news.rss"
         maker.channel.title = "Example Feed"
         maker.channel.description = "A longer description of my feed."
         maker.items.new_item do |item|
           item.link = "http://www.ruby-lang.org/en/news/2010/12/25/ruby-1-9-2-p136-is-released/"
           item.title = "Ruby 1.9.2-p136 is released"
           item.updated = Time.now.to_s
         end
       end

       puts rss

      As you can see, this is a very Builder-like DSL. This code will spit out an
      RSS 2.0 feed with one item. If we needed a second item, we'd make another
      block with maker.items.new_item and build a second one.
  RSS::TooMuchTagError:
    main: |-
      Some tags must only exist a specific number of times in a given RSS feed.
      If a feed has too many occurrences of one of these tags, a TooMuchTagError
      will be raised.
  RSS::UnknownConversionMethodError:
    main: Raised when an unknown conversion error occurs.
  RSS::UnknownTagError:
    main: |-
      RSS does not allow for free-form tag names, so if an RSS feed contains a
      tag that we don't know about, an UnknownTagError is raised.
  RSS::UnsupportedMakerVersionError:
    main: Raised when a RSS::Maker attempts to use an unknown maker.
  RSS::Utils:
    main: |-
      RSS::Utils is a module that holds various utility functions that are used
      across many parts of the rest of the RSS library. Like most modules named
      some variant of 'util', its methods are probably not particularly useful
      to those who aren't developing the library itself.
rubygems:
  Gem:
    main: |-
      RubyGems is the Ruby standard for publishing and managing third party
      libraries.

      For user documentation, see:

      * <tt>gem help</tt> and <tt>gem help [command]</tt>
      * {RubyGems User Guide}[http://guides.rubygems.org/]
      * {Frequently Asked Questions}[http://guides.rubygems.org/faqs]

      For gem developer documentation see:

      * {Creating Gems}[http://guides.rubygems.org/make-your-own-gem]
      * Gem::Specification
      * Gem::Version for version dependency notes

      Further RubyGems documentation can be found at:

      * {RubyGems Guides}[http://guides.rubygems.org]
      * {RubyGems API}[http://www.rubydoc.info/github/rubygems/rubygems] (also available from
        <tt>gem server</tt>)

      == RubyGems Plugins

      As of RubyGems 1.3.2, RubyGems will load plugins installed in gems or
      $LOAD_PATH.  Plugins must be named 'rubygems_plugin' (.rb, .so, etc) and
      placed at the root of your gem's #require_path.  Plugins are discovered via
      Gem::find_files and then loaded.

      For an example plugin, see the {Graph gem}[https://github.com/seattlerb/graph]
      which adds a `gem graph` command.

      == RubyGems Defaults, Packaging

      RubyGems defaults are stored in lib/rubygems/defaults.rb.  If you're packaging
      RubyGems or implementing Ruby you can change RubyGems' defaults.

      For RubyGems packagers, provide lib/rubygems/defaults/operating_system.rb
      and override any defaults from lib/rubygems/defaults.rb.

      For Ruby implementers, provide lib/rubygems/defaults/#{RUBY_ENGINE}.rb and
      override any defaults from lib/rubygems/defaults.rb.

      If you need RubyGems to perform extra work on install or uninstall, your
      defaults override file can set pre/post install and uninstall hooks.
      See Gem::pre_install, Gem::pre_uninstall, Gem::post_install,
      Gem::post_uninstall.

      == Bugs

      You can submit bugs to the
      {RubyGems bug tracker}[https://github.com/rubygems/rubygems/issues]
      on GitHub

      == Credits

      RubyGems is currently maintained by Eric Hodel.

      RubyGems was originally developed at RubyConf 2003 by:

      * Rich Kilmer  -- rich(at)infoether.com
      * Chad Fowler  -- chad(at)chadfowler.com
      * David Black  -- dblack(at)wobblini.net
      * Paul Brannan -- paul(at)atdesk.com
      * Jim Weirich   -- jim(at)weirichhouse.org

      Contributors:

      * Gavin Sinclair     -- gsinclair(at)soyabean.com.au
      * George Marrows     -- george.marrows(at)ntlworld.com
      * Dick Davies        -- rasputnik(at)hellooperator.net
      * Mauricio Fernandez -- batsman.geo(at)yahoo.com
      * Simon Strandgaard  -- neoneye(at)adslhome.dk
      * Dave Glasser       -- glasser(at)mit.edu
      * Paul Duncan        -- pabs(at)pablotron.org
      * Ville Aine         -- vaine(at)cs.helsinki.fi
      * Eric Hodel         -- drbrain(at)segment7.net
      * Daniel Berger      -- djberg96(at)gmail.com
      * Phil Hagelberg     -- technomancy(at)gmail.com
      * Ryan Davis         -- ryand-ruby(at)zenspider.com
      * Evan Phoenix       -- evan(at)fallingsnow.net
      * Steve Klabnik      -- steve(at)steveklabnik.com

      (If your name is missing, PLEASE let us know!)

      == License

      See {LICENSE.txt}[rdoc-ref:lib/rubygems/LICENSE.txt] for permissions.

      Thanks!

      -The RubyGems Team
  Gem::BasicSpecification:
    main: |-
      BasicSpecification is an abstract class which implements some common code
      used by both Specification and StubSpecification.
  Gem::Command:
    main: |-
      Base class for all Gem commands.  When creating a new gem command, define
      #initialize, #execute, #arguments, #defaults_str, #description and #usage
      (as appropriate).  See the above mentioned methods for details.

      A very good example to look at is Gem::Commands::ContentsCommand
  Gem::CommandManager:
    main: |-
      The command manager registers and installs all the individual sub-commands
      supported by the gem command.

      Extra commands can be provided by writing a rubygems_plugin.rb
      file in an installed gem.  You should register your command against the
      Gem::CommandManager instance, like this:

        # file rubygems_plugin.rb
        require 'rubygems/command_manager'

        Gem::CommandManager.instance.register_command :edit

      You should put the implementation of your command in rubygems/commands.

        # file rubygems/commands/edit_command.rb
        class Gem::Commands::EditCommand < Gem::Command
          # ...
        end

      See Gem::Command for instructions on writing gem commands.
  Gem::Commands:
    main: "\\Commands will be placed in this namespace"
  Gem::Commands::GenerateIndexCommand:
    main: |-
      Generates a index files for use as a gem server.

      See `gem help generate_index`
  Gem::Commands::InstallCommand:
    main: |-
      Gem installer command line tool

      See `gem help install`
  Gem::Commands::ListCommand:
    main: |-
      An alternate to Gem::Commands::QueryCommand that searches for gems starting
      with the supplied argument.
  Gem::Commands::SetupCommand:
    main: |-
      Installs RubyGems itself.  This command is ordinarily only available from a
      RubyGems checkout or tarball.
  Gem::Commands::UninstallCommand:
    main: |-
      Gem uninstaller command line tool

      See `gem help uninstall`
  Gem::ConfigFile:
    main: |-
      Gem::ConfigFile RubyGems options and gem command options from gemrc.

      gemrc is a YAML file that uses strings to match gem command arguments and
      symbols to match RubyGems options.

      Gem command arguments use a String key that matches the command name and
      allow you to specify default arguments:

        install: --no-rdoc --no-ri
        update: --no-rdoc --no-ri

      You can use <tt>gem:</tt> to set default arguments for all commands.

      RubyGems options use symbol keys.  Valid options are:

      +:backtrace+:: See #backtrace
      +:sources+:: Sets Gem::sources
      +:verbose+:: See #verbose
      +:concurrent_downloads+:: See #concurrent_downloads

      gemrc files may exist in various locations and are read and merged in
      the following order:

      - system wide (/etc/gemrc)
      - per user (~/.gemrc)
      - per environment (gemrc files listed in the GEMRC environment variable)
  Gem::ConflictError:
    main: Raised when there are conflicting gem specs loaded
  Gem::ConsoleUI:
    main: |-
      Subclass of StreamUI that instantiates the user interaction using STDIN,
      STDOUT, and STDERR.
  Gem::DefaultUserInteraction:
    main: |-
      Module that defines the default UserInteraction.  Any class including this
      module will have access to the +ui+ method that returns the default UI.
  Gem::DependencyInstaller:
    main: Installs a gem along with all its dependencies from local and remote gems.
  Gem::DependencyList:
    main: |-
      Gem::DependencyList is used for installing and uninstalling gems in the
      correct order to avoid conflicts.
  Gem::DependencyResolutionError:
    main: |-
      Raised by Gem::Resolver when a Gem::Dependency::Conflict reaches the
      toplevel.  Indicates which dependencies were incompatible through #conflict
      and #conflicting_dependencies
  Gem::Deprecate:
    main: |-
      Provides a single method +deprecate+ to be used to declare when
      something is going away.

          class Legacy
            def self.klass_method
              # ...
            end

            def instance_method
              # ...
            end

            extend Gem::Deprecate
            deprecate :instance_method, "X.z", 2011, 4

            class << self
              extend Gem::Deprecate
              deprecate :klass_method, :none, 2011, 4
            end
          end
  Gem::Doctor:
    main: |-
      Cleans up after a partially-failed uninstall or for an invalid
      Gem::Specification.

      If a specification was removed by hand this will remove any remaining files.

      If a corrupt specification was installed this will clean up warnings by
      removing the bogus specification.
  Gem::EndOfYAMLException:
    main: Potentially raised when a specification is validated.
  Gem::Exception:
    main: |-
      Base exception class for RubyGems.  All exception raised by RubyGems are a
      subclass of this one.
  Gem::Ext:
    main: Classes for building C extensions live here.
  Gem::Ext::BuildError:
    main: Raised when there is an error while building extensions.
  Gem::FakeFetcher:
    main: |-
      A fake Gem::RemoteFetcher for use in tests or to avoid real live HTTP
      requests when testing code that uses RubyGems.

      Example:

        @fetcher = Gem::FakeFetcher.new
        @fetcher.data['http://gems.example.com/yaml'] = source_index.to_yaml
        Gem::RemoteFetcher.fetcher = @fetcher

        use nested array if multiple response is needed

        @fetcher.data['http://gems.example.com/sequence'] = [['Success', 200, 'OK'], ['Failed', 401, 'Unauthorized']]

        @fetcher.fetch_path('http://gems.example.com/sequence') # => ['Success', 200, 'OK']
        @fetcher.fetch_path('http://gems.example.com/sequence') # => ['Failed', 401, 'Unauthorized']

        # invoke RubyGems code

        paths = @fetcher.paths
        assert_equal 'http://gems.example.com/yaml', paths.shift
        assert paths.empty?, paths.join(', ')

      See RubyGems' tests for more examples of FakeFetcher.
  Gem::FilePermissionError:
    main: |-
      Signals that a file permission error is preventing the user from
      operating on the given directory.
  Gem::FormatException:
    main: Used to raise parsing and loading errors
  Gem::GemNotInHomeException:
    main: Raised when attempting to uninstall a gem that isn't in GEM_HOME.
  Gem::GemRunner:
    main: |-
      Run an instance of the gem program.

      Gem::GemRunner is only intended for internal use by RubyGems itself.  It
      does not form any public API and may change at any time for any reason.

      If you would like to duplicate functionality of `gem` commands, use the
      classes they call directly.
  Gem::GemcutterUtilities:
    main: Utility methods for using the RubyGems API.
  Gem::ImpossibleDependenciesError:
    main: |-
      Raised by Gem::Resolver when dependencies conflict and create the
      inability to find a valid possible spec for a request.
  Gem::Indexer:
    main: Top level class for building the gem repository index.
  Gem::InstallUpdateOptions:
    main: Mixin methods for install and update options for Gem::Commands
  Gem::Installer:
    main: |-
      The installer installs the files contained in the .gem into the Gem.home.

      Gem::Installer does the work of putting files in all the right places on the
      filesystem including unpacking the gem into its gem dir, installing the
      gemspec in the specifications dir, storing the cached gem in the cache dir,
      and installing either wrappers or symlinks for executables.

      The installer invokes pre and post install hooks.  Hooks can be added either
      through a rubygems_plugin.rb file in an installed gem or via a
      rubygems/defaults/#{RUBY_ENGINE}.rb or rubygems/defaults/operating_system.rb
      file.  See Gem.pre_install and Gem.post_install for details.
  Gem::InstallerTestCase:
    main: A test case for Gem::Installer.
  Gem::InvalidSpecificationException:
    main: Potentially raised when a specification is validated.
  Gem::LoadError:
    main: |-
      Raised when RubyGems is unable to load or activate a gem.  Contains the
      name and version requirements of the gem that either conflicts with
      already activated gems or that RubyGems is otherwise unable to activate.
  Gem::LocalRemoteOptions:
    main: Mixin methods for local and remote Gem::Command options.
  Gem::MissingSpecError:
    main: |-
      Raised when trying to activate a gem, and that gem does not exist on the
      system.  Instead of rescuing from this class, make sure to rescue from the
      superclass Gem::LoadError to catch all types of load errors.
  Gem::MissingSpecVersionError:
    main: |-
      Raised when trying to activate a gem, and the gem exists on the system, but
      not the requested version. Instead of rescuing from this class, make sure to
      rescue from the superclass Gem::LoadError to catch all types of load errors.
  Gem::MockGemUi:
    main: |-
      This Gem::StreamUI subclass records input and output to StringIO for
      retrieval during tests.
  Gem::MockGemUi::InputEOFError:
    main: Raised when you haven't provided enough input to your MockGemUi
  Gem::Package::DigestIO:
    main: IO wrapper that creates digests of contents written to the IO it wraps.
  Gem::Package::Old:
    main: |-
      The format class knows the guts of the ancient .gem file format and provides
      the capability to read such ancient gems.

      Please pretend this doesn't exist.
  Gem::Package::TarHeader:
    main: A header for a tar file
  Gem::Package::TarInvalidError:
    main: Raised when a tar file is corrupt
  Gem::Package::TarReader:
    main: TarReader reads tar files and allows iteration over their items
  Gem::Package::TarReader::Entry:
    main: Class for reading entries out of a tar file
  Gem::Package::TarReader::UnexpectedEOF:
    main: Raised if the tar IO is not seekable
  Gem::Package::TarTestCase:
    main: A test case for Gem::Package::Tar* classes
  Gem::Package::TarWriter:
    main: Allows writing of tar files
  Gem::Package::TarWriter::BoundedStream:
    main: IO wrapper that allows writing a limited amount of data
  Gem::Package::TarWriter::RestrictedStream:
    main: 'IO wrapper that provides only #write'
  Gem::PackageTask:
    main: |-
      Create a package based upon a Gem::Specification.  Gem packages, as well as
      zip files and tar/gzipped packages can be produced by this task.

      In addition to the Rake targets generated by Rake::PackageTask, a
      Gem::PackageTask will also generate the following tasks:

      [<b>"<em>package_dir</em>/<em>name</em>-<em>version</em>.gem"</b>]
        Create a RubyGems package with the given name and version.

      Example using a Gem::Specification:

        require 'rubygems'
        require 'rubygems/package_task'

        spec = Gem::Specification.new do |s|
          s.summary = "Ruby based make-like utility."
          s.name = 'rake'
          s.version = PKG_VERSION
          s.requirements << 'none'
          s.files = PKG_FILES
          s.description = <<-EOF
        Rake is a Make-like program implemented in Ruby. Tasks
        and dependencies are specified in standard Ruby syntax.
          EOF
        end

        Gem::PackageTask.new(spec) do |pkg|
          pkg.need_zip = true
          pkg.need_tar = true
        end
  Gem::PathSupport:
    main: |-
      Gem::PathSupport facilitates the GEM_HOME and GEM_PATH environment settings
      to the rest of RubyGems.
  Gem::Platform:
    main: |-
      Available list of platforms for targeting Gem installations.

      See `gem help platform` for information on platform matching.
  Gem::PlatformMismatch:
    main: |-
      Generated when trying to lookup a gem to indicate that the gem
      was found, but that it isn't usable on the current platform.

      fetch and install read these and report them to the user to aid
      in figuring out why a gem couldn't be installed.
  Gem::RemoteError:
    main: |-
      Signals that a remote operation cannot be conducted, probably due to not
      being connected (or just not finding host).
  Gem::RemoteFetcher:
    main: |-
      RemoteFetcher handles the details of fetching gems and gem information from
      a remote source.
  Gem::RemoteFetcher::FetchError:
    main: |-
      A FetchError exception wraps up the various possible IO and HTTP failures
      that could happen while downloading from the internet.
  Gem::RemoteFetcher::UnknownHostError:
    main: |-
      A FetchError that indicates that the reason for not being
      able to fetch data was that the host could not be contacted
  Gem::RemoteSourceException:
    main: Represents an error communicating via HTTP.
  Gem::RequestSet:
    main: |-
      A RequestSet groups a request to activate a set of dependencies.

        nokogiri = Gem::Dependency.new 'nokogiri', '~> 1.6'
        pg = Gem::Dependency.new 'pg', '~> 0.14'

        set = Gem::RequestSet.new nokogiri, pg

        requests = set.resolve

        p requests.map { |r| r.full_name }
        #=> ["nokogiri-1.6.0", "mini_portile-0.5.1", "pg-0.17.0"]
  Gem::RequestSet::GemDependencyAPI:
    main: |-
      A semi-compatible DSL for the Bundler Gemfile and Isolate gem dependencies
      files.

      To work with both the Bundler Gemfile and Isolate formats this
      implementation takes some liberties to allow compatibility with each, most
      notably in #source.

      A basic gem dependencies file will look like the following:

        source 'https://rubygems.org'

        gem 'rails', '3.2.14a
        gem 'devise', '~> 2.1', '>= 2.1.3'
        gem 'cancan'
        gem 'airbrake'
        gem 'pg'

      RubyGems recommends saving this as gem.deps.rb over Gemfile or Isolate.

      To install the gems in this Gemfile use `gem install -g` to install it and
      create a lockfile.  The lockfile will ensure that when you make changes to
      your gem dependencies file a minimum amount of change is made to the
      dependencies of your gems.

      RubyGems can activate all the gems in your dependencies file at startup
      using the RUBYGEMS_GEMDEPS environment variable or through Gem.use_gemdeps.
      See Gem.use_gemdeps for details and warnings.

      See `gem help install` and `gem help gem_dependencies` for further details.
  Gem::RequestSet::Lockfile:
    main: |-
      Parses a gem.deps.rb.lock file and constructs a LockSet containing the
      dependencies found inside.  If the lock file is missing no LockSet is
      constructed.
  Gem::RequestSet::Lockfile::ParseError:
    main: Raised when a lockfile cannot be parsed
  Gem::Requirement:
    main: |-
      A Requirement is a set of one or more version restrictions. It supports a
      few (<tt>=, !=, >, <, >=, <=, ~></tt>) different restriction operators.

      See Gem::Version for a description on how versions and requirements work
      together in RubyGems.
  Gem::Requirement::BadRequirementError:
    main: Raised when a bad requirement is encountered
  Gem::Resolver:
    main: |-
      Given a set of Gem::Dependency objects as +needed+ and a way to query the
      set of available specs via +set+, calculates a set of ActivationRequest
      objects which indicate all the specs that should be activated to meet the
      all the requirements.
  Gem::Resolver::APISet:
    main: |-
      The global rubygems pool, available via the rubygems.org API.
      Returns instances of APISpecification.
  Gem::Resolver::APISpecification:
    main: |-
      Represents a specification retrieved via the rubygems.org API.

      This is used to avoid loading the full Specification object when all we need
      is the name, version, and dependencies.
  Gem::Resolver::ActivationRequest:
    main: |-
      Specifies a Specification object that should be activated.  Also contains a
      dependency that was used to introduce this activation.
  Gem::Resolver::BestSet:
    main: |-
      The BestSet chooses the best available method to query a remote index.

      It combines IndexSet and APISet
  Gem::Resolver::ComposedSet:
    main: |-
      A ComposedSet allows multiple sets to be queried like a single set.

      To create a composed set with any number of sets use:

        Gem::Resolver.compose_sets set1, set2

      This method will eliminate nesting of composed sets.
  Gem::Resolver::Conflict:
    main: |-
      Used internally to indicate that a dependency conflicted
      with a spec that would be activated.
  Gem::Resolver::CurrentSet:
    main: |-
      A set which represents the installed gems. Respects
      all the normal settings that control where to look
      for installed gems.
  Gem::Resolver::DependencyRequest:
    main: |-
      Used Internally. Wraps a Dependency object to also track which spec
      contained the Dependency.
  Gem::Resolver::GitSet:
    main: |-
      A GitSet represents gems that are sourced from git repositories.

      This is used for gem dependency file support.

      Example:

        set = Gem::Resolver::GitSet.new
        set.add_git_gem 'rake', 'git://example/rake.git', tag: 'rake-10.1.0'
  Gem::Resolver::GitSpecification:
    main: |-
      A GitSpecification represents a gem that is sourced from a git repository
      and is being loaded through a gem dependencies file through the +git:+
      option.
  Gem::Resolver::IndexSet:
    main: |-
      The global rubygems pool represented via the traditional
      source index.
  Gem::Resolver::IndexSpecification:
    main: |-
      Represents a possible Specification object returned from IndexSet.  Used to
      delay needed to download full Specification objects when only the +name+
      and +version+ are needed.
  Gem::Resolver::InstalledSpecification:
    main: |-
      An InstalledSpecification represents a gem that is already installed
      locally.
  Gem::Resolver::InstallerSet:
    main: |-
      A set of gems for installation sourced from remote sources and local .gem
      files
  Gem::Resolver::LocalSpecification:
    main: A LocalSpecification comes from a .gem file on the local filesystem.
  Gem::Resolver::LockSet:
    main: A set of gems from a gem dependencies lockfile.
  Gem::Resolver::LockSpecification:
    main: |-
      The LockSpecification comes from a lockfile (Gem::RequestSet::Lockfile).

      A LockSpecification's dependency information is pre-filled from the
      lockfile.
  Gem::Resolver::Molinillo:
    main: Gem::Resolver::Molinillo is a generic dependency resolution algorithm.
  Gem::Resolver::Molinillo::CircularDependencyError:
    main: |-
      An error caused by attempting to fulfil a dependency that was circular

      @note This exception will be thrown iff a {Vertex} is added to a
        {DependencyGraph} that has a {DependencyGraph::Vertex#path_to?} an
        existing {DependencyGraph::Vertex}
  Gem::Resolver::Molinillo::Delegates:
    main: "@!visibility private"
  Gem::Resolver::Molinillo::Delegates::ResolutionState:
    main: Delegates all {Gem::Resolver::Molinillo::ResolutionState} methods to a `#state`
      property.
  Gem::Resolver::Molinillo::Delegates::SpecificationProvider:
    main: |-
      Delegates all {Gem::Resolver::Molinillo::SpecificationProvider} methods to a
      `#specification_provider` property.
  Gem::Resolver::Molinillo::DependencyGraph:
    main: A directed acyclic graph that is tuned to hold named dependencies
  Gem::Resolver::Molinillo::DependencyGraph::Action:
    main: |-
      An action that modifies a {DependencyGraph} that is reversible.
      @abstract
  Gem::Resolver::Molinillo::DependencyGraph::AddEdgeNoCircular:
    main: |-
      @!visibility private
      (see DependencyGraph#add_edge_no_circular)
  Gem::Resolver::Molinillo::DependencyGraph::DeleteEdge:
    main: |-
      @!visibility private
      (see DependencyGraph#delete_edge)
  Gem::Resolver::Molinillo::DependencyGraph::DetachVertexNamed:
    main: |-
      @!visibility private
      @see DependencyGraph#detach_vertex_named
  Gem::Resolver::Molinillo::DependencyGraph::Log:
    main: A log for dependency graph actions
  Gem::Resolver::Molinillo::DependencyGraph::Tag:
    main: |-
      @!visibility private
      @see DependencyGraph#tag
  Gem::Resolver::Molinillo::DependencyGraph::Vertex:
    main: |-
      A vertex in a {DependencyGraph} that encapsulates a {#name} and a
      {#payload}
  Gem::Resolver::Molinillo::DependencyState:
    main: |-
      A state that encapsulates a set of {#requirements} with an {Array} of
      possibilities
  Gem::Resolver::Molinillo::NoSuchDependencyError:
    main: |-
      An error caused by searching for a dependency that is completely unknown,
      i.e. has no versions available whatsoever.
  Gem::Resolver::Molinillo::PossibilityState:
    main: |-
      A state that encapsulates a single possibility to fulfill the given
      {#requirement}
  Gem::Resolver::Molinillo::Resolver:
    main: |-
      This class encapsulates a dependency resolver.
      The resolver is responsible for determining which set of dependencies to
      activate, with feedback from the {#specification_provider}
  Gem::Resolver::Molinillo::Resolver::Resolution:
    main: A specific resolution from a given {Resolver}
  Gem::Resolver::Molinillo::ResolverError:
    main: An error that occurred during the resolution process
  Gem::Resolver::Molinillo::SpecificationProvider:
    main: |-
      Provides information about specifcations and dependencies to the resolver,
      allowing the {Resolver} class to remain generic while still providing power
      and flexibility.

      This module contains the methods that users of Gem::Resolver::Molinillo must to implement,
      using knowledge of their own model classes.
  Gem::Resolver::Molinillo::UI:
    main: Conveys information about the resolution process to a user.
  Gem::Resolver::Molinillo::VersionConflict:
    main: An error caused by conflicts in version
  Gem::Resolver::RequirementList:
    main: |-
      The RequirementList is used to hold the requirements being considered
      while resolving a set of gems.

      The RequirementList acts like a queue where the oldest items are removed
      first.
  Gem::Resolver::Set:
    main: |-
      Resolver sets are used to look up specifications (and their
      dependencies) used in resolution.  This set is abstract.
  Gem::Resolver::SourceSet:
    main: |-
      The SourceSet chooses the best available method to query a remote index.

      Kind off like BestSet but filters the sources for gems
  Gem::Resolver::SpecSpecification:
    main: |-
      The Resolver::SpecSpecification contains common functionality for
      Resolver specifications that are backed by a Gem::Specification.
  Gem::Resolver::Specification:
    main: |-
      A Resolver::Specification contains a subset of the information
      contained in a Gem::Specification.  Only the information necessary for
      dependency resolution in the resolver is included.
  Gem::Resolver::VendorSet:
    main: |-
      A VendorSet represents gems that have been unpacked into a specific
      directory that contains a gemspec.

      This is used for gem dependency file support.

      Example:

        set = Gem::Resolver::VendorSet.new

        set.add_vendor_gem 'rake', 'vendor/rake'

      The directory vendor/rake must contain an unpacked rake gem along with a
      rake.gemspec (watching the given name).
  Gem::Resolver::VendorSpecification:
    main: |-
      A VendorSpecification represents a gem that has been unpacked into a project
      and is being loaded through a gem dependencies file through the +path:+
      option.
  Gem::RubyVersionMismatch:
    main: |-
      Raised when a gem dependencies file specifies a ruby version that does not
      match the current version.
  Gem::S3URISigner:
    main: |-
      S3URISigner implements AWS SigV4 for S3 Source to avoid a dependency on the aws-sdk-* gems
      More on AWS SigV4: https://docs.aws.amazon.com/AmazonS3/latest/API/sig-v4-authenticating-requests.html
  Gem::SafeYAML:
    main: |-
      This module is used for safely loading YAML specs from a gem.  The
      `safe_load` method defined on this module is specifically designed for
      loading Gem specifications.  For loading other YAML safely, please see
      Psych.safe_load
  Gem::Security:
    main: |-
      = Signing gems

      The Gem::Security implements cryptographic signatures for gems.  The section
      below is a step-by-step guide to using signed gems and generating your own.

      == Walkthrough

      === Building your certificate

      In order to start signing your gems, you'll need to build a private key and
      a self-signed certificate.  Here's how:

        # build a private key and certificate for yourself:
        $ gem cert --build you@example.com

      This could take anywhere from a few seconds to a minute or two, depending on
      the speed of your computer (public key algorithms aren't exactly the
      speediest crypto algorithms in the world).  When it's finished, you'll see
      the files "gem-private_key.pem" and "gem-public_cert.pem" in the current
      directory.

      First things first: Move both files to ~/.gem if you don't already have a
      key and certificate in that directory.  Ensure the file permissions make the
      key unreadable by others (by default the file is saved securely).

      Keep your private key hidden; if it's compromised, someone can sign packages
      as you (note: PKI has ways of mitigating the risk of stolen keys; more on
      that later).

      === Signing Gems

      In RubyGems 2 and newer there is no extra work to sign a gem.  RubyGems will
      automatically find your key and certificate in your home directory and use
      them to sign newly packaged gems.

      If your certificate is not self-signed (signed by a third party) RubyGems
      will attempt to load the certificate chain from the trusted certificates.
      Use <code>gem cert --add signing_cert.pem</code> to add your signers as
      trusted certificates.  See below for further information on certificate
      chains.

      If you build your gem it will automatically be signed.  If you peek inside
      your gem file, you'll see a couple of new files have been added:

        $ tar tf your-gem-1.0.gem
        metadata.gz
        metadata.gz.sum
        metadata.gz.sig # metadata signature
        data.tar.gz
        data.tar.gz.sum
        data.tar.gz.sig # data signature

      === Manually signing gems

      If you wish to store your key in a separate secure location you'll need to
      set your gems up for signing by hand.  To do this, set the
      <code>signing_key</code> and <code>cert_chain</code> in the gemspec before
      packaging your gem:

        s.signing_key = '/secure/path/to/gem-private_key.pem'
        s.cert_chain = %w[/secure/path/to/gem-public_cert.pem]

      When you package your gem with these options set RubyGems will automatically
      load your key and certificate from the secure paths.

      === Signed gems and security policies

      Now let's verify the signature.  Go ahead and install the gem, but add the
      following options: <code>-P HighSecurity</code>, like this:

        # install the gem with using the security policy "HighSecurity"
        $ sudo gem install your.gem -P HighSecurity

      The <code>-P</code> option sets your security policy -- we'll talk about
      that in just a minute.  Eh, what's this?

        $ gem install -P HighSecurity your-gem-1.0.gem
        ERROR:  While executing gem ... (Gem::Security::Exception)
            root cert /CN=you/DC=example is not trusted

      The culprit here is the security policy.  RubyGems has several different
      security policies.  Let's take a short break and go over the security
      policies.  Here's a list of the available security policies, and a brief
      description of each one:

      * NoSecurity - Well, no security at all.  Signed packages are treated like
        unsigned packages.
      * LowSecurity - Pretty much no security.  If a package is signed then
        RubyGems will make sure the signature matches the signing
        certificate, and that the signing certificate hasn't expired, but
        that's it.  A malicious user could easily circumvent this kind of
        security.
      * MediumSecurity - Better than LowSecurity and NoSecurity, but still
        fallible.  Package contents are verified against the signing
        certificate, and the signing certificate is checked for validity,
        and checked against the rest of the certificate chain (if you don't
        know what a certificate chain is, stay tuned, we'll get to that).
        The biggest improvement over LowSecurity is that MediumSecurity
        won't install packages that are signed by untrusted sources.
        Unfortunately, MediumSecurity still isn't totally secure -- a
        malicious user can still unpack the gem, strip the signatures, and
        distribute the gem unsigned.
      * HighSecurity - Here's the bugger that got us into this mess.
        The HighSecurity policy is identical to the MediumSecurity policy,
        except that it does not allow unsigned gems.  A malicious user
        doesn't have a whole lot of options here; they can't modify the
        package contents without invalidating the signature, and they can't
        modify or remove signature or the signing certificate chain, or
        RubyGems will simply refuse to install the package.  Oh well, maybe
        they'll have better luck causing problems for CPAN users instead :).

      The reason RubyGems refused to install your shiny new signed gem was because
      it was from an untrusted source.  Well, your code is infallible (naturally),
      so you need to add yourself as a trusted source:

        # add trusted certificate
        gem cert --add ~/.gem/gem-public_cert.pem

      You've now added your public certificate as a trusted source.  Now you can
      install packages signed by your private key without any hassle.  Let's try
      the install command above again:

        # install the gem with using the HighSecurity policy (and this time
        # without any shenanigans)
        $ gem install -P HighSecurity your-gem-1.0.gem
        Successfully installed your-gem-1.0
        1 gem installed

      This time RubyGems will accept your signed package and begin installing.

      While you're waiting for RubyGems to work it's magic, have a look at some of
      the other security commands by running <code>gem help cert</code>:

        Options:
          -a, --add CERT                   Add a trusted certificate.
          -l, --list [FILTER]              List trusted certificates where the
                                           subject contains FILTER
          -r, --remove FILTER              Remove trusted certificates where the
                                           subject contains FILTER
          -b, --build EMAIL_ADDR           Build private key and self-signed
                                           certificate for EMAIL_ADDR
          -C, --certificate CERT           Signing certificate for --sign
          -K, --private-key KEY            Key for --sign or --build
          -s, --sign CERT                  Signs CERT with the key from -K
                                           and the certificate from -C

      We've already covered the <code>--build</code> option, and the
      <code>--add</code>, <code>--list</code>, and <code>--remove</code> commands
      seem fairly straightforward; they allow you to add, list, and remove the
      certificates in your trusted certificate list.  But what's with this
      <code>--sign</code> option?

      === Certificate chains

      To answer that question, let's take a look at "certificate chains", a
      concept I mentioned earlier.  There are a couple of problems with
      self-signed certificates: first of all, self-signed certificates don't offer
      a whole lot of security.  Sure, the certificate says Yukihiro Matsumoto, but
      how do I know it was actually generated and signed by matz himself unless he
      gave me the certificate in person?

      The second problem is scalability.  Sure, if there are 50 gem authors, then
      I have 50 trusted certificates, no problem.  What if there are 500 gem
      authors?  1000?  Having to constantly add new trusted certificates is a
      pain, and it actually makes the trust system less secure by encouraging
      RubyGems users to blindly trust new certificates.

      Here's where certificate chains come in.  A certificate chain establishes an
      arbitrarily long chain of trust between an issuing certificate and a child
      certificate.  So instead of trusting certificates on a per-developer basis,
      we use the PKI concept of certificate chains to build a logical hierarchy of
      trust.  Here's a hypothetical example of a trust hierarchy based (roughly)
      on geography:

                              --------------------------
                              | rubygems@rubygems.org |
                              --------------------------
                                          |
                        -----------------------------------
                        |                                 |
            ----------------------------    -----------------------------
            |  seattlerb@seattlerb.org |    | dcrubyists@richkilmer.com |
            ----------------------------    -----------------------------
                 |                |                 |             |
          ---------------   ----------------   -----------   --------------
          |   drbrain   |   |   zenspider  |   | pabs@dc |   | tomcope@dc |
          ---------------   ----------------   -----------   --------------

      Now, rather than having 4 trusted certificates (one for drbrain, zenspider,
      pabs@dc, and tomecope@dc), a user could actually get by with one
      certificate, the "rubygems@rubygems.org" certificate.

      Here's how it works:

      I install "rdoc-3.12.gem", a package signed by "drbrain".  I've never heard
      of "drbrain", but his certificate has a valid signature from the
      "seattle.rb@seattlerb.org" certificate, which in turn has a valid signature
      from the "rubygems@rubygems.org" certificate.  Voila!  At this point, it's
      much more reasonable for me to trust a package signed by "drbrain", because
      I can establish a chain to "rubygems@rubygems.org", which I do trust.

      === Signing certificates

      The <code>--sign</code> option allows all this to happen.  A developer
      creates their build certificate with the <code>--build</code> option, then
      has their certificate signed by taking it with them to their next regional
      Ruby meetup (in our hypothetical example), and it's signed there by the
      person holding the regional RubyGems signing certificate, which is signed at
      the next RubyConf by the holder of the top-level RubyGems certificate.  At
      each point the issuer runs the same command:

        # sign a certificate with the specified key and certificate
        # (note that this modifies client_cert.pem!)
        $ gem cert -K /mnt/floppy/issuer-priv_key.pem -C issuer-pub_cert.pem
           --sign client_cert.pem

      Then the holder of issued certificate (in this case, your buddy "drbrain"),
      can start using this signed certificate to sign RubyGems.  By the way, in
      order to let everyone else know about his new fancy signed certificate,
      "drbrain" would save his newly signed certificate as
      <code>~/.gem/gem-public_cert.pem</code>

      Obviously this RubyGems trust infrastructure doesn't exist yet.  Also, in
      the "real world", issuers actually generate the child certificate from a
      certificate request, rather than sign an existing certificate.  And our
      hypothetical infrastructure is missing a certificate revocation system.
      These are that can be fixed in the future...

      At this point you should know how to do all of these new and interesting
      things:

      * build a gem signing key and certificate
      * adjust your security policy
      * modify your trusted certificate list
      * sign a certificate

      == Manually verifying signatures

      In case you don't trust RubyGems you can verify gem signatures manually:

      1. Fetch and unpack the gem

           gem fetch some_signed_gem
           tar -xf some_signed_gem-1.0.gem

      2. Grab the public key from the gemspec

           gem spec some_signed_gem-1.0.gem cert_chain | \
             ruby -ryaml -e 'puts YAML.load_documents($stdin)' > public_key.crt

      3. Generate a SHA1 hash of the data.tar.gz

           openssl dgst -sha1 < data.tar.gz > my.hash

      4. Verify the signature

           openssl rsautl -verify -inkey public_key.crt -certin \
             -in data.tar.gz.sig > verified.hash

      5. Compare your hash to the verified hash

           diff -s verified.hash my.hash

      6. Repeat 5 and 6 with metadata.gz

      == OpenSSL Reference

      The .pem files generated by --build and --sign are PEM files.  Here's a
      couple of useful OpenSSL commands for manipulating them:

        # convert a PEM format X509 certificate into DER format:
        # (note: Windows .cer files are X509 certificates in DER format)
        $ openssl x509 -in input.pem -outform der -out output.der

        # print out the certificate in a human-readable format:
        $ openssl x509 -in input.pem -noout -text

      And you can do the same thing with the private key file as well:

        # convert a PEM format RSA key into DER format:
        $ openssl rsa -in input_key.pem -outform der -out output_key.der

        # print out the key in a human readable format:
        $ openssl rsa -in input_key.pem -noout -text

      == Bugs/TODO

      * There's no way to define a system-wide trust list.
      * custom security policies (from a YAML file, etc)
      * Simple method to generate a signed certificate request
      * Support for OCSP, SCVP, CRLs, or some other form of cert status check
        (list is in order of preference)
      * Support for encrypted private keys
      * Some sort of semi-formal trust hierarchy (see long-winded explanation
        above)
      * Path discovery (for gem certificate chains that don't have a self-signed
        root) -- by the way, since we don't have this, THE ROOT OF THE CERTIFICATE
        CHAIN MUST BE SELF SIGNED if Policy#verify_root is true (and it is for the
        MediumSecurity and HighSecurity policies)
      * Better explanation of X509 naming (ie, we don't have to use email
        addresses)
      * Honor AIA field (see note about OCSP above)
      * Honor extension restrictions
      * Might be better to store the certificate chain as a PKCS#7 or PKCS#12
        file, instead of an array embedded in the metadata.
      * Flexible signature and key algorithms, not hard-coded to RSA and SHA1.

      == Original author

      Paul Duncan <pabs@pablotron.org>
      http://pablotron.org/
  Gem::Security::Exception:
    main: Gem::Security default exception type
  Gem::Security::Policy:
    main: |-
      A Gem::Security::Policy object encapsulates the settings for verifying
      signed gem files.  This is the base class.  You can either declare an
      instance of this or use one of the preset security policies in
      Gem::Security::Policies.
  Gem::Security::TrustDir:
    main: |-
      The TrustDir manages the trusted certificates for gem signature
      verification.
  Gem::SecurityOption:
    main: Mixin methods for security option for Gem::Commands
  Gem::Server:
    main: |-
      Gem::Server and allows users to serve gems for consumption by
      `gem --remote-install`.

      gem_server starts an HTTP server on the given port and serves the following:
      * "/" - Browsing of gem spec files for installed gems
      * "/specs.#{Gem.marshal_version}.gz" - specs name/version/platform index
      * "/latest_specs.#{Gem.marshal_version}.gz" - latest specs
        name/version/platform index
      * "/quick/" - Individual gemspecs
      * "/gems" - Direct access to download the installable gems
      * "/rdoc?q=" - Search for installed rdoc documentation

      == Usage

        gem_server = Gem::Server.new Gem.dir, 8089, false
        gem_server.run
  Gem::SilentUI:
    main: SilentUI is a UI choice that is absolutely silent.
  Gem::Source:
    main: |-
      A Source knows how to list and fetch gems from a RubyGems marshal index.

      There are other Source subclasses for installed gems, local gems, the
      bundler dependency API and so-forth.
  Gem::Source::Git:
    main: |-
      A git gem for use in a gem dependencies file.

      Example:

        source =
          Gem::Source::Git.new 'rake', 'git@example:rake.git', 'rake-10.1.0', false

        source.specs
  Gem::Source::Installed:
    main: Represents an installed gem.  This is used for dependency resolution.
  Gem::Source::Local:
    main: |-
      The local source finds gems in the current directory for fulfilling
      dependencies.
  Gem::Source::Lock:
    main: |-
      A Lock source wraps an installed gem's source and sorts before other sources
      during dependency resolution.  This allows RubyGems to prefer gems from
      dependency lock files.
  Gem::Source::SpecificFile:
    main: |-
      A source representing a single .gem file.  This is used for installation of
      local gems.
  Gem::Source::Vendor:
    main: This represents a vendored source that is similar to an installed gem.
  Gem::SourceFetchProblem:
    main: |-
      An error that indicates we weren't able to fetch some
      data from a source
  Gem::SourceList:
    main: |-
      The SourceList represents the sources rubygems has been configured to use.
      A source may be created from an array of sources:

        Gem::SourceList.from %w[https://rubygems.example https://internal.example]

      Or by adding them:

        sources = Gem::SourceList.new
        sources << 'https://rubygems.example'

      The most common way to get a SourceList is Gem.sources.
  Gem::SpecFetcher:
    main: SpecFetcher handles metadata updates from remote gem repositories.
  Gem::SpecificGemNotFoundException:
    main: Raised by the DependencyInstaller when a specific gem cannot be found
  Gem::Specification:
    main: |-
      The Specification class contains the information for a gem.  Typically
      defined in a .gemspec file or a Rakefile, and looks like this:

        Gem::Specification.new do |s|
          s.name        = 'example'
          s.version     = '0.1.0'
          s.licenses    = ['MIT']
          s.summary     = "This is an example!"
          s.description = "Much longer explanation of the example!"
          s.authors     = ["Ruby Coder"]
          s.email       = 'rubycoder@example.com'
          s.files       = ["lib/example.rb"]
          s.homepage    = 'https://rubygems.org/gems/example'
          s.metadata    = { "source_code_uri" => "https://github.com/example/example" }
        end

      Starting in RubyGems 2.0, a Specification can hold arbitrary
      metadata.  See #metadata for restrictions on the format and size of metadata
      items you may add to a specification.
  Gem::StreamUI:
    main: Gem::StreamUI implements a simple stream based user interface.
  Gem::StreamUI::SilentDownloadReporter:
    main: An absolutely silent download reporter.
  Gem::StreamUI::SilentProgressReporter:
    main: An absolutely silent progress reporter.
  Gem::StreamUI::SimpleProgressReporter:
    main: A basic dotted progress reporter.
  Gem::StreamUI::ThreadedDownloadReporter:
    main: A progress reporter that behaves nicely with threaded downloading.
  Gem::StreamUI::VerboseProgressReporter:
    main: A progress reporter that prints out messages about the current progress.
  Gem::StubSpecification:
    main: |-
      Gem::StubSpecification reads the stub: line from the gemspec.  This prevents
      us having to eval the entire gemspec in order to find out certain
      information.
  Gem::SystemExitException:
    main: |-
      Raised to indicate that a system exit should occur with the specified
      exit_code
  Gem::TestCase:
    main: |-
      RubyGemTestCase provides a variety of methods for testing rubygems and
      gem-related behavior in a sandbox.  Through RubyGemTestCase you can install
      and uninstall gems, fetch remote gems through a stub fetcher and be assured
      your normal set of gems is not affected.
  Gem::TestCase::SpecFetcherSetup:
    main: |-
      The SpecFetcherSetup allows easy setup of a remote source in RubyGems tests:

        spec_fetcher do |f|
          f.gem  'a', 1
          f.spec 'a', 2
          f.gem  'b', 1' 'a' => '~> 1.0'
        end

      The above declaration creates two gems, a-1 and b-1, with a dependency from
      b to a.  The declaration creates an additional spec a-2, but no gem for it
      (so it cannot be installed).

      After the gems are created they are removed from Gem.dir.
  Gem::TestCase::StaticSet:
    main: |-
      The StaticSet is a static set of gem specifications used for testing only.
      It is available by requiring Gem::TestCase.
  Gem::Text:
    main: A collection of text-wrangling methods
  Gem::UninstallError:
    main: Raised when removing a gem with the uninstall command fails
  Gem::Uninstaller:
    main: |-
      An Uninstaller.

      The uninstaller fires pre and post uninstall hooks.  Hooks can be added
      either through a rubygems_plugin.rb file in an installed gem or via a
      rubygems/defaults/#{RUBY_ENGINE}.rb or rubygems/defaults/operating_system.rb
      file.  See Gem.pre_uninstall and Gem.post_uninstall for details.
  Gem::UnsatisfiableDependencyError:
    main: |-
      Raised by Resolver when a dependency requests a gem for which
      there is no spec.
  Gem::UriFormatter:
    main: |-
      The UriFormatter handles URIs from user-input and escaping.

        uf = Gem::UriFormatter.new 'example.com'

        p uf.normalize #=> 'http://example.com'
  Gem::UriParser:
    main: The UriParser handles parsing URIs.
  Gem::UserInteraction:
    main: |-
      UserInteraction allows RubyGems to interact with the user through standard
      methods that can be replaced with more-specific UI methods for different
      displays.

      Since UserInteraction dispatches to a concrete UI class you may need to
      reference other classes for specific behavior such as Gem::ConsoleUI or
      Gem::SilentUI.

      Example:

        class X
          include Gem::UserInteraction

          def get_answer
            n = ask("What is the meaning of life?")
          end
        end
  Gem::Util:
    main: This module contains various utility methods as module methods.
  Gem::Validator:
    main: Validator performs various gem file and gem database validation
  Gem::VerificationError:
    main: Raised by Gem::Validator when something is not right in a gem.
  Gem::Version:
    main: |-
      The Version class processes string versions into comparable
      values. A version string should normally be a series of numbers
      separated by periods. Each part (digits separated by periods) is
      considered its own number, and these are used for sorting. So for
      instance, 3.10 sorts higher than 3.2 because ten is greater than
      two.

      If any part contains letters (currently only a-z are supported) then
      that version is considered prerelease. Versions with a prerelease
      part in the Nth part sort less than versions with N-1
      parts. Prerelease parts are sorted alphabetically using the normal
      Ruby string sorting rules. If a prerelease part contains both
      letters and numbers, it will be broken into multiple parts to
      provide expected sort behavior (1.0.a10 becomes 1.0.a.10, and is
      greater than 1.0.a9).

      Prereleases sort between real releases (newest to oldest):

      1. 1.0
      2. 1.0.b1
      3. 1.0.a.2
      4. 0.9

      If you want to specify a version restriction that includes both prereleases
      and regular releases of the 1.x series this is the best way:

        s.add_dependency 'example', '>= 1.0.0.a', '< 2.0.0'

      == How Software Changes

      Users expect to be able to specify a version constraint that gives them
      some reasonable expectation that new versions of a library will work with
      their software if the version constraint is true, and not work with their
      software if the version constraint is false.  In other words, the perfect
      system will accept all compatible versions of the library and reject all
      incompatible versions.

      Libraries change in 3 ways (well, more than 3, but stay focused here!).

      1. The change may be an implementation detail only and have no effect on
         the client software.
      2. The change may add new features, but do so in a way that client software
         written to an earlier version is still compatible.
      3. The change may change the public interface of the library in such a way
         that old software is no longer compatible.

      Some examples are appropriate at this point.  Suppose I have a Stack class
      that supports a <tt>push</tt> and a <tt>pop</tt> method.

      === Examples of Category 1 changes:

      * Switch from an array based implementation to a linked-list based
        implementation.
      * Provide an automatic (and transparent) backing store for large stacks.

      === Examples of Category 2 changes might be:

      * Add a <tt>depth</tt> method to return the current depth of the stack.
      * Add a <tt>top</tt> method that returns the current top of stack (without
        changing the stack).
      * Change <tt>push</tt> so that it returns the item pushed (previously it
        had no usable return value).

      === Examples of Category 3 changes might be:

      * Changes <tt>pop</tt> so that it no longer returns a value (you must use
        <tt>top</tt> to get the top of the stack).
      * Rename the methods to <tt>push_item</tt> and <tt>pop_item</tt>.

      == RubyGems Rational Versioning

      * Versions shall be represented by three non-negative integers, separated
        by periods (e.g. 3.1.4).  The first integers is the "major" version
        number, the second integer is the "minor" version number, and the third
        integer is the "build" number.

      * A category 1 change (implementation detail) will increment the build
        number.

      * A category 2 change (backwards compatible) will increment the minor
        version number and reset the build number.

      * A category 3 change (incompatible) will increment the major build number
        and reset the minor and build numbers.

      * Any "public" release of a gem should have a different version.  Normally
        that means incrementing the build number.  This means a developer can
        generate builds all day long, but as soon as they make a public release,
        the version must be updated.

      === Examples

      Let's work through a project lifecycle using our Stack example from above.

      Version 0.0.1:: The initial Stack class is release.
      Version 0.0.2:: Switched to a linked=list implementation because it is
                      cooler.
      Version 0.1.0:: Added a <tt>depth</tt> method.
      Version 1.0.0:: Added <tt>top</tt> and made <tt>pop</tt> return nil
                      (<tt>pop</tt> used to return the  old top item).
      Version 1.1.0:: <tt>push</tt> now returns the value pushed (it used it
                      return nil).
      Version 1.1.1:: Fixed a bug in the linked list implementation.
      Version 1.1.2:: Fixed a bug introduced in the last fix.

      Client A needs a stack with basic push/pop capability.  They write to the
      original interface (no <tt>top</tt>), so their version constraint looks like:

        gem 'stack', '>= 0.0'

      Essentially, any version is OK with Client A.  An incompatible change to
      the library will cause them grief, but they are willing to take the chance
      (we call Client A optimistic).

      Client B is just like Client A except for two things: (1) They use the
      <tt>depth</tt> method and (2) they are worried about future
      incompatibilities, so they write their version constraint like this:

        gem 'stack', '~> 0.1'

      The <tt>depth</tt> method was introduced in version 0.1.0, so that version
      or anything later is fine, as long as the version stays below version 1.0
      where incompatibilities are introduced.  We call Client B pessimistic
      because they are worried about incompatible future changes (it is OK to be
      pessimistic!).

      == Preventing Version Catastrophe:

      From: http://blog.zenspider.com/2008/10/rubygems-howto-preventing-cata.html

      Let's say you're depending on the fnord gem version 2.y.z. If you
      specify your dependency as ">= 2.0.0" then, you're good, right? What
      happens if fnord 3.0 comes out and it isn't backwards compatible
      with 2.y.z? Your stuff will break as a result of using ">=". The
      better route is to specify your dependency with an "approximate" version
      specifier ("~>"). They're a tad confusing, so here is how the dependency
      specifiers work:

        Specification From  ... To (exclusive)
        ">= 3.0"      3.0   ... &infin;
        "~> 3.0"      3.0   ... 4.0
        "~> 3.0.0"    3.0.0 ... 3.1
        "~> 3.5"      3.5   ... 4.0
        "~> 3.5.0"    3.5.0 ... 3.6
        "~> 3"        3.0   ... 4.0

      For the last example, single-digit versions are automatically extended with
      a zero to give a sensible result.
  Gem::VersionOption:
    main: Mixin methods for --version and --platform Gem::Command options.
  Kernel:
    main: |-
      RubyGems adds the #gem method to allow activation of specific gem versions
      and overrides the #require method on Kernel to make gems appear as if they
      live on the <code>$LOAD_PATH</code>.  See the documentation of these methods
      for further detail.
  TempIO:
    main: |-
      A StringIO duck-typed class that uses Tempfile instead of String as the
      backing store.

      This is available when rubygems/test_utilities is required.
  YAML::Syck:
    main: |-
      Now that we've got something that is always here, define #to_s
      so when code tries to use this, it at least just shows up like it
      should.
securerandom:
  SecureRandom:
    main: |-
      == Secure random number generator interface.

      This library is an interface to secure random number generators which are
      suitable for generating session keys in HTTP cookies, etc.

      You can use this library in your application by requiring it:

        require 'securerandom'

      It supports the following secure random number generators:

      * openssl
      * /dev/urandom
      * Win32

      SecureRandom is extended by the Random::Formatter module which
      defines the following methods:

      * alphanumeric
      * base64
      * choose
      * gen_random
      * hex
      * rand
      * random_bytes
      * random_number
      * urlsafe_base64
      * uuid

      These methods are usable as class methods of SecureRandom such as
      `SecureRandom.hex`.

      === Examples

      Generate random hexadecimal strings:

        require 'securerandom'

        SecureRandom.hex(10) #=> "52750b30ffbc7de3b362"
        SecureRandom.hex(10) #=> "92b15d6c8dc4beb5f559"
        SecureRandom.hex(13) #=> "39b290146bea6ce975c37cfc23"

      Generate random base64 strings:

        SecureRandom.base64(10) #=> "EcmTPZwWRAozdA=="
        SecureRandom.base64(10) #=> "KO1nIU+p9DKxGg=="
        SecureRandom.base64(12) #=> "7kJSM/MzBJI+75j8"

      Generate random binary strings:

        SecureRandom.random_bytes(10) #=> "\016\t{\370g\310pbr\301"
        SecureRandom.random_bytes(10) #=> "\323U\030TO\234\357\020\a\337"

      Generate alphanumeric strings:

        SecureRandom.alphanumeric(10) #=> "S8baxMJnPl"
        SecureRandom.alphanumeric(10) #=> "aOxAg8BAJe"

      Generate UUIDs:

        SecureRandom.uuid #=> "2d931510-d99f-494a-8c67-87feb05e1594"
        SecureRandom.uuid #=> "bad85eb9-0713-4da7-8d36-07a8e4b00eab"
set:
  Set:
    main: |-
      Set implements a collection of unordered values with no duplicates.
      This is a hybrid of Array's intuitive inter-operation facilities and
      Hash's fast lookup.

      Set is easy to use with Enumerable objects (implementing +each+).
      Most of the initializer methods and binary operators accept generic
      Enumerable objects besides sets and arrays.  An Enumerable object
      can be converted to Set using the +to_set+ method.

      Set uses Hash as storage, so you must note the following points:

      * Equality of elements is determined according to Object#eql? and
        Object#hash.  Use Set#compare_by_identity to make a set compare
        its elements by their identity.
      * Set assumes that the identity of each element does not change
        while it is stored.  Modifying an element of a set will render the
        set to an unreliable state.
      * When a string is to be stored, a frozen copy of the string is
        stored instead unless the original string is already frozen.

      == Comparison

      The comparison operators <, >, <=, and >= are implemented as
      shorthand for the {proper_,}{subset?,superset?} methods.  However,
      the <=> operator is intentionally left out because not every pair of
      sets is comparable ({x, y} vs. {x, z} for example).

      == Example

        require 'set'
        s1 = Set[1, 2]                        #=> #<Set: {1, 2}>
        s2 = [1, 2].to_set                    #=> #<Set: {1, 2}>
        s1 == s2                              #=> true
        s1.add("foo")                         #=> #<Set: {1, 2, "foo"}>
        s1.merge([2, 6])                      #=> #<Set: {1, 2, "foo", 6}>
        s1.subset?(s2)                        #=> false
        s2.subset?(s1)                        #=> true

      == Contact

        - Akinori MUSHA <knu@iDaemons.org> (current maintainer)
  SortedSet:
    main: |-
      SortedSet implements a Set that guarantees that its elements are
      yielded in sorted order (according to the return values of their
      #<=> methods) when iterating over them.

      All elements that are added to a SortedSet must respond to the <=>
      method for comparison.

      Also, all elements must be <em>mutually comparable</em>: <tt>el1 <=>
      el2</tt> must not return <tt>nil</tt> for any elements <tt>el1</tt>
      and <tt>el2</tt>, else an ArgumentError will be raised when
      iterating over the SortedSet.

      == Example

        require "set"

        set = SortedSet.new([2, 1, 5, 6, 4, 5, 3, 3, 3])
        ary = []

        set.each do |obj|
          ary << obj
        end

        p ary # => [1, 2, 3, 4, 5, 6]

        set2 = SortedSet.new([1, 2, "3"])
        set2.each { |obj| } # => raises ArgumentError: comparison of Fixnum with String failed
shellwords:
  Shellwords:
    main: |-
      == Manipulates strings like the UNIX Bourne shell

      This module manipulates strings according to the word parsing rules
      of the UNIX Bourne shell.

      The shellwords() function was originally a port of shellwords.pl,
      but modified to conform to the Shell & Utilities volume of the IEEE
      Std 1003.1-2008, 2016 Edition [1].

      === Usage

      You can use Shellwords to parse a string into a Bourne shell friendly Array.

        require 'shellwords'

        argv = Shellwords.split('three blind "mice"')
        argv #=> ["three", "blind", "mice"]

      Once you've required Shellwords, you can use the #split alias
      String#shellsplit.

        argv = "see how they run".shellsplit
        argv #=> ["see", "how", "they", "run"]

      Be careful you don't leave a quote unmatched.

        argv = "they all ran after the farmer's wife".shellsplit
             #=> ArgumentError: Unmatched double quote: ...

      In this case, you might want to use Shellwords.escape, or its alias
      String#shellescape.

      This method will escape the String for you to safely use with a Bourne shell.

        argv = Shellwords.escape("special's.txt")
        argv #=> "special\\'s.txt"
        system("cat " + argv)

      Shellwords also comes with a core extension for Array, Array#shelljoin.

        argv = %w{ls -lta lib}
        system(argv.shelljoin)

      You can use this method to create an escaped string out of an array of tokens
      separated by a space. In this example we used the literal shortcut for
      Array.new.

      === Authors
      * Wakou Aoyama
      * Akinori MUSHA <knu@iDaemons.org>

      === Contact
      * Akinori MUSHA <knu@iDaemons.org> (current maintainer)

      === Resources

      1: {IEEE Std 1003.1-2008, 2016 Edition, the Shell & Utilities volume}[http://pubs.opengroup.org/onlinepubs/9699919799/utilities/contents.html]
singleton:
  Singleton:
    main: |-
      The Singleton module implements the Singleton pattern.

      == Usage

      To use Singleton, include the module in your class.

         class Klass
            include Singleton
            # ...
         end

      This ensures that only one instance of Klass can be created.

           a,b  = Klass.instance, Klass.instance

           a == b
           # => true

           Klass.new
           # => NoMethodError - new is private ...

      The instance is created at upon the first call of Klass.instance().

           class OtherKlass
             include Singleton
             # ...
           end

           ObjectSpace.each_object(OtherKlass){}
           # => 0

           OtherKlass.instance
           ObjectSpace.each_object(OtherKlass){}
           # => 1

      This behavior is preserved under inheritance and cloning.

      == Implementation

      This above is achieved by:

      *  Making Klass.new and Klass.allocate private.

      *  Overriding Klass.inherited(sub_klass) and Klass.clone() to ensure that the
         Singleton properties are kept when inherited and cloned.

      *  Providing the Klass.instance() method that returns the same object each
         time it is called.

      *  Overriding Klass._load(str) to call Klass.instance().

      *  Overriding Klass#clone and Klass#dup to raise TypeErrors to prevent
         cloning or duping.

      == Singleton and Marshal

      By default Singleton's #_dump(depth) returns the empty string. Marshalling by
      default will strip state information, e.g. instance variables from the instance.
      Classes using Singleton can provide custom _load(str) and _dump(depth) methods
      to retain some of the previous state of the instance.

         require 'singleton'

         class Example
           include Singleton
           attr_accessor :keep, :strip
           def _dump(depth)
             # this strips the @strip information from the instance
             Marshal.dump(@keep, depth)
           end

           def self._load(str)
             instance.keep = Marshal.load(str)
             instance
           end
         end

         a = Example.instance
         a.keep = "keep this"
         a.strip = "get rid of this"

         stored_state = Marshal.dump(a)

         a.keep = nil
         a.strip = nil
         b = Marshal.load(stored_state)
         p a == b  #  => true
         p a.keep  #  => "keep this"
         p a.strip #  => nil
tempfile:
  Tempfile:
    main: |-
      A utility class for managing temporary files. When you create a Tempfile
      object, it will create a temporary file with a unique filename. A Tempfile
      objects behaves just like a File object, and you can perform all the usual
      file operations on it: reading data, writing data, changing its permissions,
      etc. So although this class does not explicitly document all instance methods
      supported by File, you can in fact call any File instance method on a
      Tempfile object.

      == Synopsis

        require 'tempfile'

        file = Tempfile.new('foo')
        file.path      # => A unique filename in the OS's temp directory,
                       #    e.g.: "/tmp/foo.24722.0"
                       #    This filename contains 'foo' in its basename.
        file.write("hello world")
        file.rewind
        file.read      # => "hello world"
        file.close
        file.unlink    # deletes the temp file

      == Good practices

      === Explicit close

      When a Tempfile object is garbage collected, or when the Ruby interpreter
      exits, its associated temporary file is automatically deleted. This means
      that's it's unnecessary to explicitly delete a Tempfile after use, though
      it's good practice to do so: not explicitly deleting unused Tempfiles can
      potentially leave behind large amounts of tempfiles on the filesystem
      until they're garbage collected. The existence of these temp files can make
      it harder to determine a new Tempfile filename.

      Therefore, one should always call #unlink or close in an ensure block, like
      this:

        file = Tempfile.new('foo')
        begin
           # ...do something with file...
        ensure
           file.close
           file.unlink   # deletes the temp file
        end

      === Unlink after creation

      On POSIX systems, it's possible to unlink a file right after creating it,
      and before closing it. This removes the filesystem entry without closing
      the file handle, so it ensures that only the processes that already had
      the file handle open can access the file's contents. It's strongly
      recommended that you do this if you do not want any other processes to
      be able to read from or write to the Tempfile, and you do not need to
      know the Tempfile's filename either.

      For example, a practical use case for unlink-after-creation would be this:
      you need a large byte buffer that's too large to comfortably fit in RAM,
      e.g. when you're writing a web server and you want to buffer the client's
      file upload data.

      Please refer to #unlink for more information and a code example.

      == Minor notes

      Tempfile's filename picking method is both thread-safe and inter-process-safe:
      it guarantees that no other threads or processes will pick the same filename.

      Tempfile itself however may not be entirely thread-safe. If you access the
      same Tempfile object from multiple threads then you should protect it with a
      mutex.
time:
  Time:
    main: |-
      = time.rb

      When 'time' is required, Time is extended with additional methods for parsing
      and converting Times.

      == Features

      This library extends the Time class with the following conversions between
      date strings and Time objects:

      * date-time defined by {RFC 2822}[http://www.ietf.org/rfc/rfc2822.txt]
      * HTTP-date defined by {RFC 2616}[http://www.ietf.org/rfc/rfc2616.txt]
      * dateTime defined by XML Schema Part 2: Datatypes ({ISO
        8601}[http://www.iso.org/iso/date_and_time_format])
      * various formats handled by Date._parse
      * custom formats handled by Date._strptime
timeout:
  Timeout:
    main: |-
      Timeout long-running blocks

      == Synopsis

        require 'timeout'
        status = Timeout::timeout(5) {
          # Something that should be interrupted if it takes more than 5 seconds...
        }

      == Description

      Timeout provides a way to auto-terminate a potentially long-running
      operation if it hasn't finished in a fixed amount of time.

      Previous versions didn't use a module for namespacing, however
      #timeout is provided for backwards compatibility.  You
      should prefer Timeout.timeout instead.

      == Copyright

      Copyright:: (C) 2000  Network Applied Communication Laboratory, Inc.
      Copyright:: (C) 2000  Information-technology Promotion Agency, Japan
  Timeout::Error:
    main: Raised by Timeout.timeout when the block times out.
  Timeout::TimeoutError:
    main: Raised by Timeout.timeout when the block times out.
tmpdir: {}
tracer:
  Tracer:
    main: |-
      Outputs a source level execution trace of a Ruby program.

      It does this by registering an event handler with Kernel#set_trace_func for
      processing incoming events.  It also provides methods for filtering unwanted
      trace output (see Tracer.add_filter, Tracer.on, and Tracer.off).

      == Example

      Consider the following Ruby script

        class A
          def square(a)
            return a*a
          end
        end

        a = A.new
        a.square(5)

      Running the above script using <code>ruby -r tracer example.rb</code> will
      output the following trace to STDOUT (Note you can also explicitly
      <code>require 'tracer'</code>)

        #0:<internal:lib/rubygems/custom_require>:38:Kernel:<: -
        #0:example.rb:3::-: class A
        #0:example.rb:3::C: class A
        #0:example.rb:4::-:   def square(a)
        #0:example.rb:7::E: end
        #0:example.rb:9::-: a = A.new
        #0:example.rb:10::-: a.square(5)
        #0:example.rb:4:A:>:   def square(a)
        #0:example.rb:5:A:-:     return a*a
        #0:example.rb:6:A:<:   end
         |  |         | |  |
         |  |         | |   ---------------------+ event
         |  |         |  ------------------------+ class
         |  |          --------------------------+ line
         |   ------------------------------------+ filename
          ---------------------------------------+ thread

      Symbol table used for displaying incoming events:

      +}+:: call a C-language routine
      +{+:: return from a C-language routine
      +>+:: call a Ruby method
      +C+:: start a class or module definition
      +E+:: finish a class or module definition
      +-+:: execute code on a new line
      +^+:: raise an exception
      +<+:: return from a Ruby method

      == Copyright

      by Keiju ISHITSUKA(keiju@ishitsuka.com)
tsort:
  TSort:
    main: |-
      TSort implements topological sorting using Tarjan's algorithm for
      strongly connected components.

      TSort is designed to be able to be used with any object which can be
      interpreted as a directed graph.

      TSort requires two methods to interpret an object as a graph,
      tsort_each_node and tsort_each_child.

      * tsort_each_node is used to iterate for all nodes over a graph.
      * tsort_each_child is used to iterate for child nodes of a given node.

      The equality of nodes are defined by eql? and hash since
      TSort uses Hash internally.

      == A Simple Example

      The following example demonstrates how to mix the TSort module into an
      existing class (in this case, Hash). Here, we're treating each key in
      the hash as a node in the graph, and so we simply alias the required
      #tsort_each_node method to Hash's #each_key method. For each key in the
      hash, the associated value is an array of the node's child nodes. This
      choice in turn leads to our implementation of the required #tsort_each_child
      method, which fetches the array of child nodes and then iterates over that
      array using the user-supplied block.

        require 'tsort'

        class Hash
          include TSort
          alias tsort_each_node each_key
          def tsort_each_child(node, &block)
            fetch(node).each(&block)
          end
        end

        {1=>[2, 3], 2=>[3], 3=>[], 4=>[]}.tsort
        #=> [3, 2, 1, 4]

        {1=>[2], 2=>[3, 4], 3=>[2], 4=>[]}.strongly_connected_components
        #=> [[4], [2, 3], [1]]

      == A More Realistic Example

      A very simple `make' like tool can be implemented as follows:

        require 'tsort'

        class Make
          def initialize
            @dep = {}
            @dep.default = []
          end

          def rule(outputs, inputs=[], &block)
            triple = [outputs, inputs, block]
            outputs.each {|f| @dep[f] = [triple]}
            @dep[triple] = inputs
          end

          def build(target)
            each_strongly_connected_component_from(target) {|ns|
              if ns.length != 1
                fs = ns.delete_if {|n| Array === n}
                raise TSort::Cyclic.new("cyclic dependencies: #{fs.join ', '}")
              end
              n = ns.first
              if Array === n
                outputs, inputs, block = n
                inputs_time = inputs.map {|f| File.mtime f}.max
                begin
                  outputs_time = outputs.map {|f| File.mtime f}.min
                rescue Errno::ENOENT
                  outputs_time = nil
                end
                if outputs_time == nil ||
                   inputs_time != nil && outputs_time <= inputs_time
                  sleep 1 if inputs_time != nil && inputs_time.to_i == Time.now.to_i
                  block.call
                end
              end
            }
          end

          def tsort_each_child(node, &block)
            @dep[node].each(&block)
          end
          include TSort
        end

        def command(arg)
          print arg, "\n"
          system arg
        end

        m = Make.new
        m.rule(%w[t1]) { command 'date > t1' }
        m.rule(%w[t2]) { command 'date > t2' }
        m.rule(%w[t3]) { command 'date > t3' }
        m.rule(%w[t4], %w[t1 t3]) { command 'cat t1 t3 > t4' }
        m.rule(%w[t5], %w[t4 t2]) { command 'cat t4 t2 > t5' }
        m.build('t5')

      == Bugs

      * 'tsort.rb' is wrong name because this library uses
        Tarjan's algorithm for strongly connected components.
        Although 'strongly_connected_components.rb' is correct but too long.

      == References

      R. E. Tarjan, "Depth First Search and Linear Graph Algorithms",
      <em>SIAM Journal on Computing</em>, Vol. 1, No. 2, pp. 146-160, June 1972.
un: {}
unicode_normalize: {}
uri:
  URI:
    main: |-
      URI is a module providing classes to handle Uniform Resource Identifiers
      (RFC2396[http://tools.ietf.org/html/rfc2396]).

      == Features

      * Uniform way of handling URIs.
      * Flexibility to introduce custom URI schemes.
      * Flexibility to have an alternate URI::Parser (or just different patterns
        and regexp's).

      == Basic example

        require 'uri'

        uri = URI("http://foo.com/posts?id=30&limit=5#time=1305298413")
        #=> #<URI::HTTP http://foo.com/posts?id=30&limit=5#time=1305298413>

        uri.scheme    #=> "http"
        uri.host      #=> "foo.com"
        uri.path      #=> "/posts"
        uri.query     #=> "id=30&limit=5"
        uri.fragment  #=> "time=1305298413"

        uri.to_s      #=> "http://foo.com/posts?id=30&limit=5#time=1305298413"

      == Adding custom URIs

        module URI
          class RSYNC < Generic
            DEFAULT_PORT = 873
          end
          @@schemes['RSYNC'] = RSYNC
        end
        #=> URI::RSYNC

        URI.scheme_list
        #=> {"FILE"=>URI::File, "FTP"=>URI::FTP, "HTTP"=>URI::HTTP,
        #    "HTTPS"=>URI::HTTPS, "LDAP"=>URI::LDAP, "LDAPS"=>URI::LDAPS,
        #    "MAILTO"=>URI::MailTo, "RSYNC"=>URI::RSYNC}

        uri = URI("rsync://rsync.foo.com")
        #=> #<URI::RSYNC rsync://rsync.foo.com>

      == RFC References

      A good place to view an RFC spec is http://www.ietf.org/rfc.html.

      Here is a list of all related RFC's:
      - RFC822[http://tools.ietf.org/html/rfc822]
      - RFC1738[http://tools.ietf.org/html/rfc1738]
      - RFC2255[http://tools.ietf.org/html/rfc2255]
      - RFC2368[http://tools.ietf.org/html/rfc2368]
      - RFC2373[http://tools.ietf.org/html/rfc2373]
      - RFC2396[http://tools.ietf.org/html/rfc2396]
      - RFC2732[http://tools.ietf.org/html/rfc2732]
      - RFC3986[http://tools.ietf.org/html/rfc3986]

      == Class tree

      - URI::Generic (in uri/generic.rb)
        - URI::File - (in uri/file.rb)
        - URI::FTP - (in uri/ftp.rb)
        - URI::HTTP - (in uri/http.rb)
          - URI::HTTPS - (in uri/https.rb)
        - URI::LDAP - (in uri/ldap.rb)
          - URI::LDAPS - (in uri/ldaps.rb)
        - URI::MailTo - (in uri/mailto.rb)
      - URI::Parser - (in uri/common.rb)
      - URI::REGEXP - (in uri/common.rb)
        - URI::REGEXP::PATTERN - (in uri/common.rb)
      - URI::Util - (in uri/common.rb)
      - URI::Escape - (in uri/common.rb)
      - URI::Error - (in uri/common.rb)
        - URI::InvalidURIError - (in uri/common.rb)
        - URI::InvalidComponentError - (in uri/common.rb)
        - URI::BadURIError - (in uri/common.rb)

      == Copyright Info

      Author:: Akira Yamada <akira@ruby-lang.org>
      Documentation::
        Akira Yamada <akira@ruby-lang.org>
        Dmitry V. Sabanin <sdmitry@lrn.ru>
        Vincent Batts <vbatts@hashbangbash.com>
      License::
       Copyright (c) 2001 akira yamada <akira@ruby-lang.org>
       You can redistribute it and/or modify it under the same term as Ruby.
      Revision:: $Id$
  URI::BadURIError:
    main: URI is valid, bad usage is not.
  URI::Error:
    main: Base class for all URI exceptions.
  URI::Escape:
    main: Module for escaping unsafe characters with codes.
  URI::FTP:
    main: |-
      FTP URI syntax is defined by RFC1738 section 3.2.

      This class will be redesigned because of difference of implementations;
      the structure of its path. draft-hoffman-ftp-uri-04 is a draft but it
      is a good summary about the de facto spec.
      http://tools.ietf.org/html/draft-hoffman-ftp-uri-04
  URI::File:
    main: The "file" URI is defined by RFC8089.
  URI::Generic:
    main: |-
      Base class for all URI classes.
      Implements generic URI syntax as per RFC 2396.
  URI::HTTP:
    main: |-
      The syntax of HTTP URIs is defined in RFC1738 section 3.3.

      Note that the Ruby URI library allows HTTP URLs containing usernames and
      passwords. This is not legal as per the RFC, but used to be
      supported in Internet Explorer 5 and 6, before the MS04-004 security
      update. See <URL:http://support.microsoft.com/kb/834489>.
  URI::HTTPS:
    main: |-
      The default port for HTTPS URIs is 443, and the scheme is 'https:' rather
      than 'http:'. Other than that, HTTPS URIs are identical to HTTP URIs;
      see URI::HTTP.
  URI::InvalidComponentError:
    main: Not a URI component.
  URI::InvalidURIError:
    main: Not a URI.
  URI::LDAP:
    main: LDAP URI SCHEMA (described in RFC2255).
  URI::LDAPS:
    main: |-
      The default port for LDAPS URIs is 636, and the scheme is 'ldaps:' rather
      than 'ldap:'. Other than that, LDAPS URIs are identical to LDAP URIs;
      see URI::LDAP.
  URI::MailTo:
    main: RFC6068, the mailto URL scheme.
  URI::Parser:
    main: |-
      Class that parses String's into URI's.

      It contains a Hash set of patterns and Regexp's that match and validate.
  URI::REGEXP:
    main: Includes URI::REGEXP::PATTERN
  URI::RFC2396_Parser:
    main: |-
      Class that parses String's into URI's.

      It contains a Hash set of patterns and Regexp's that match and validate.
  URI::RFC2396_REGEXP:
    main: Includes URI::REGEXP::PATTERN
  URI::RFC2396_REGEXP::PATTERN:
    main: Patterns used to parse URI's
weakref:
  WeakRef:
    main: |-
      Weak Reference class that allows a referenced object to be
      garbage-collected.

      A WeakRef may be used exactly like the object it references.

      Usage:

        foo = Object.new            # create a new object instance
        p foo.to_s                  # original's class
        foo = WeakRef.new(foo)      # reassign foo with WeakRef instance
        p foo.to_s                  # should be same class
        GC.start                    # start the garbage collector
        p foo.to_s                  # should raise exception (recycled)
  WeakRef::RefError:
    main: |-
      RefError is raised when a referenced object has been recycled by the
      garbage collector
webrick:
  Errno:
    main: |-
      System call error module used by webrick for cross platform compatibility.

      EPROTO:: protocol error
      ECONNRESET:: remote host reset the connection request
      ECONNABORTED:: Client sent TCP reset (RST) before server has accepted the
                     connection requested by client.
  Errno::ECONNABORTED:
    main: |-
      Client sent TCP reset (RST) before server has accepted the connection
      requested by client.
  Errno::ECONNRESET:
    main: Remote host reset the connection request.
  Errno::EPROTO:
    main: Protocol error.
  WEBrick:
    main: |-
      = WEB server toolkit.

      WEBrick is an HTTP server toolkit that can be configured as an HTTPS server,
      a proxy server, and a virtual-host server.  WEBrick features complete
      logging of both server operations and HTTP access.  WEBrick supports both
      basic and digest authentication in addition to algorithms not in RFC 2617.

      A WEBrick server can be composed of multiple WEBrick servers or servlets to
      provide differing behavior on a per-host or per-path basis.  WEBrick
      includes servlets for handling CGI scripts, ERB pages, Ruby blocks and
      directory listings.

      WEBrick also includes tools for daemonizing a process and starting a process
      at a higher privilege level and dropping permissions.

      == Starting an HTTP server

      To create a new WEBrick::HTTPServer that will listen to connections on port
      8000 and serve documents from the current user's public_html folder:

        require 'webrick'

        root = File.expand_path '~/public_html'
        server = WEBrick::HTTPServer.new :Port => 8000, :DocumentRoot => root

      To run the server you will need to provide a suitable shutdown hook as
      starting the server blocks the current thread:

        trap 'INT' do server.shutdown end

        server.start

      == Custom Behavior

      The easiest way to have a server perform custom operations is through
      WEBrick::HTTPServer#mount_proc.  The block given will be called with a
      WEBrick::HTTPRequest with request info and a WEBrick::HTTPResponse which
      must be filled in appropriately:

        server.mount_proc '/' do |req, res|
          res.body = 'Hello, world!'
        end

      Remember that +server.mount_proc+ must precede +server.start+.

      == Servlets

      Advanced custom behavior can be obtained through mounting a subclass of
      WEBrick::HTTPServlet::AbstractServlet.  Servlets provide more modularity
      when writing an HTTP server than mount_proc allows.  Here is a simple
      servlet:

        class Simple < WEBrick::HTTPServlet::AbstractServlet
          def do_GET request, response
            status, content_type, body = do_stuff_with request

            response.status = 200
            response['Content-Type'] = 'text/plain'
            response.body = 'Hello, World!'
          end
        end

      To initialize the servlet you mount it on the server:

        server.mount '/simple', Simple

      See WEBrick::HTTPServlet::AbstractServlet for more details.

      == Virtual Hosts

      A server can act as a virtual host for multiple host names.  After creating
      the listening host, additional hosts that do not listen can be created and
      attached as virtual hosts:

        server = WEBrick::HTTPServer.new # ...

        vhost = WEBrick::HTTPServer.new :ServerName => 'vhost.example',
                                        :DoNotListen => true, # ...
        vhost.mount '/', ...

        server.virtual_host vhost

      If no +:DocumentRoot+ is provided and no servlets or procs are mounted on the
      main server it will return 404 for all URLs.

      == HTTPS

      To create an HTTPS server you only need to enable SSL and provide an SSL
      certificate name:

        require 'webrick'
        require 'webrick/https'

        cert_name = [
          %w[CN localhost],
        ]

        server = WEBrick::HTTPServer.new(:Port => 8000,
                                         :SSLEnable => true,
                                         :SSLCertName => cert_name)

      This will start the server with a self-generated self-signed certificate.
      The certificate will be changed every time the server is restarted.

      To create a server with a pre-determined key and certificate you can provide
      them:

        require 'webrick'
        require 'webrick/https'
        require 'openssl'

        cert = OpenSSL::X509::Certificate.new File.read '/path/to/cert.pem'
        pkey = OpenSSL::PKey::RSA.new File.read '/path/to/pkey.pem'

        server = WEBrick::HTTPServer.new(:Port => 8000,
                                         :SSLEnable => true,
                                         :SSLCertificate => cert,
                                         :SSLPrivateKey => pkey)

      == Proxy Server

      WEBrick can act as a proxy server:

        require 'webrick'
        require 'webrick/httpproxy'

        proxy = WEBrick::HTTPProxyServer.new :Port => 8000

        trap 'INT' do proxy.shutdown end

      See WEBrick::HTTPProxy for further details including modifying proxied
      responses.

      == Basic and Digest authentication

      WEBrick provides both Basic and Digest authentication for regular and proxy
      servers.  See WEBrick::HTTPAuth, WEBrick::HTTPAuth::BasicAuth and
      WEBrick::HTTPAuth::DigestAuth.

      == WEBrick as a Production Web Server

      WEBrick can be run as a production server for small loads.

      === Daemonizing

      To start a WEBrick server as a daemon simple run WEBrick::Daemon.start
      before starting the server.

      === Dropping Permissions

      WEBrick can be started as one user to gain permission to bind to port 80 or
      443 for serving HTTP or HTTPS traffic then can drop these permissions for
      regular operation.  To listen on all interfaces for HTTP traffic:

        sockets = WEBrick::Utils.create_listeners nil, 80

      Then drop privileges:

        WEBrick::Utils.su 'www'

      Then create a server that does not listen by default:

        server = WEBrick::HTTPServer.new :DoNotListen => true, # ...

      Then overwrite the listening sockets with the port 80 sockets:

        server.listeners.replace sockets

      === Logging

      WEBrick can separately log server operations and end-user access.  For
      server operations:

        log_file = File.open '/var/log/webrick.log', 'a+'
        log = WEBrick::Log.new log_file

      For user access logging:

        access_log = [
          [log_file, WEBrick::AccessLog::COMBINED_LOG_FORMAT],
        ]

        server = WEBrick::HTTPServer.new :Logger => log, :AccessLog => access_log

      See WEBrick::AccessLog for further log formats.

      === Log Rotation

      To rotate logs in WEBrick on a HUP signal (like syslogd can send), open the
      log file in 'a+' mode (as above) and trap 'HUP' to reopen the log file:

        trap 'HUP' do log_file.reopen '/path/to/webrick.log', 'a+'

      == Copyright

      Author: IPR -- Internet Programming with Ruby -- writers

      Copyright (c) 2000 TAKAHASHI Masayoshi, GOTOU YUUZOU
      Copyright (c) 2002 Internet Programming with Ruby writers. All rights
      reserved.
  WEBrick::AccessLog:
    main: |-
      AccessLog provides logging to various files in various formats.

      Multiple logs may be written to at the same time:

        access_log = [
          [$stderr, WEBrick::AccessLog::COMMON_LOG_FORMAT],
          [$stderr, WEBrick::AccessLog::REFERER_LOG_FORMAT],
        ]

        server = WEBrick::HTTPServer.new :AccessLog => access_log

      Custom log formats may be defined.  WEBrick::AccessLog provides a subset
      of the formatting from Apache's mod_log_config
      http://httpd.apache.org/docs/mod/mod_log_config.html#formats.  See
      AccessLog::setup_params for a list of supported options
  WEBrick::AccessLog::AccessLogError:
    main: |-
      Raised if a parameter such as %e, %i, %o or %n is used without fetching
      a specific field.
  WEBrick::BasicLog:
    main: A generic logging class
  WEBrick::CGI:
    main: |-
      A CGI library using WEBrick requests and responses.

      Example:

        class MyCGI < WEBrick::CGI
          def do_GET req, res
            res.body = 'it worked!'
            res.status = 200
          end
        end

        MyCGI.new.start
  WEBrick::Cookie:
    main: Processes HTTP cookies
  WEBrick::Daemon:
    main: A generic module for daemonizing a process
  WEBrick::GenericServer:
    main: |-
      Base TCP server class.  You must subclass GenericServer and provide a #run
      method.
  WEBrick::HTTPAuth:
    main: |-
      HTTPAuth provides both basic and digest authentication.

      To enable authentication for requests in WEBrick you will need a user
      database and an authenticator.  To start, here's an Htpasswd database for
      use with a DigestAuth authenticator:

        config = { :Realm => 'DigestAuth example realm' }

        htpasswd = WEBrick::HTTPAuth::Htpasswd.new 'my_password_file'
        htpasswd.auth_type = WEBrick::HTTPAuth::DigestAuth
        htpasswd.set_passwd config[:Realm], 'username', 'password'
        htpasswd.flush

      The +:Realm+ is used to provide different access to different groups
      across several resources on a server.  Typically you'll need only one
      realm for a server.

      This database can be used to create an authenticator:

        config[:UserDB] = htpasswd

        digest_auth = WEBrick::HTTPAuth::DigestAuth.new config

      To authenticate a request call #authenticate with a request and response
      object in a servlet:

        def do_GET req, res
          @authenticator.authenticate req, res
        end

      For digest authentication the authenticator must not be created every
      request, it must be passed in as an option via WEBrick::HTTPServer#mount.
  WEBrick::HTTPAuth::Authenticator:
    main: |-
      Module providing generic support for both Digest and Basic
      authentication schemes.
  WEBrick::HTTPAuth::BasicAuth:
    main: |-
      Basic Authentication for WEBrick

      Use this class to add basic authentication to a WEBrick servlet.

      Here is an example of how to set up a BasicAuth:

        config = { :Realm => 'BasicAuth example realm' }

        htpasswd = WEBrick::HTTPAuth::Htpasswd.new 'my_password_file', password_hash: :bcrypt
        htpasswd.set_passwd config[:Realm], 'username', 'password'
        htpasswd.flush

        config[:UserDB] = htpasswd

        basic_auth = WEBrick::HTTPAuth::BasicAuth.new config
  WEBrick::HTTPAuth::DigestAuth:
    main: |-
      RFC 2617 Digest Access Authentication for WEBrick

      Use this class to add digest authentication to a WEBrick servlet.

      Here is an example of how to set up DigestAuth:

        config = { :Realm => 'DigestAuth example realm' }

        htdigest = WEBrick::HTTPAuth::Htdigest.new 'my_password_file'
        htdigest.set_passwd config[:Realm], 'username', 'password'
        htdigest.flush

        config[:UserDB] = htdigest

        digest_auth = WEBrick::HTTPAuth::DigestAuth.new config

      When using this as with a servlet be sure not to create a new DigestAuth
      object in the servlet's #initialize.  By default WEBrick creates a new
      servlet instance for every request and the DigestAuth object must be
      used across requests.
  WEBrick::HTTPAuth::Htdigest:
    main: |-
      Htdigest accesses apache-compatible digest password files.  Passwords are
      matched to a realm where they are valid.  For security, the path for a
      digest password database should be stored outside of the paths available
      to the HTTP server.

      Htdigest is intended for use with WEBrick::HTTPAuth::DigestAuth and
      stores passwords using cryptographic hashes.

        htpasswd = WEBrick::HTTPAuth::Htdigest.new 'my_password_file'
        htpasswd.set_passwd 'my realm', 'username', 'password'
        htpasswd.flush
  WEBrick::HTTPAuth::Htgroup:
    main: |-
      Htgroup accesses apache-compatible group files.  Htgroup can be used to
      provide group-based authentication for users.  Currently Htgroup is not
      directly integrated with any authenticators in WEBrick.  For security,
      the path for a digest password database should be stored outside of the
      paths available to the HTTP server.

      Example:

        htgroup = WEBrick::HTTPAuth::Htgroup.new 'my_group_file'
        htgroup.add 'superheroes', %w[spiderman batman]

        htgroup.members('superheroes').include? 'magneto' # => false
  WEBrick::HTTPAuth::Htpasswd:
    main: |-
      Htpasswd accesses apache-compatible password files.  Passwords are
      matched to a realm where they are valid.  For security, the path for a
      password database should be stored outside of the paths available to the
      HTTP server.

      Htpasswd is intended for use with WEBrick::HTTPAuth::BasicAuth.

      To create an Htpasswd database with a single user:

        htpasswd = WEBrick::HTTPAuth::Htpasswd.new 'my_password_file'
        htpasswd.set_passwd 'my realm', 'username', 'password'
        htpasswd.flush
  WEBrick::HTTPAuth::ProxyAuthenticator:
    main: |-
      Module providing generic support for both Digest and Basic
      authentication schemes for proxies.
  WEBrick::HTTPAuth::ProxyBasicAuth:
    main: Basic authentication for proxy servers.  See BasicAuth for details.
  WEBrick::HTTPAuth::ProxyDigestAuth:
    main: Digest authentication for proxy servers.  See DigestAuth for details.
  WEBrick::HTTPAuth::UserDB:
    main: |-
      User database mixin for HTTPAuth.  This mixin dispatches user record
      access to the underlying auth_type for this database.
  WEBrick::HTTPProxyServer:
    main: |-
      An HTTP Proxy server which proxies GET, HEAD and POST requests.

      To create a simple proxy server:

        require 'webrick'
        require 'webrick/httpproxy'

        proxy = WEBrick::HTTPProxyServer.new Port: 8000

        trap 'INT'  do proxy.shutdown end
        trap 'TERM' do proxy.shutdown end

        proxy.start

      See ::new for proxy-specific configuration items.

      == Modifying proxied responses

      To modify content the proxy server returns use the +:ProxyContentHandler+
      option:

        handler = proc do |req, res|
          if res['content-type'] == 'text/plain' then
            res.body << "\nThis content was proxied!\n"
          end
        end

        proxy =
          WEBrick::HTTPProxyServer.new Port: 8000, ProxyContentHandler: handler
  WEBrick::HTTPRequest:
    main: |-
      An HTTP request.  This is consumed by service and do_* methods in
      WEBrick servlets
  WEBrick::HTTPResponse:
    main: |-
      An HTTP response.  This is filled in by the service or do_* methods of a
      WEBrick HTTP Servlet.
  WEBrick::HTTPServer:
    main: An HTTP Server
  WEBrick::HTTPServlet::AbstractServlet:
    main: |-
      AbstractServlet allows HTTP server modules to be reused across multiple
      servers and allows encapsulation of functionality.

      By default a servlet will respond to GET, HEAD (through an alias to GET)
      and OPTIONS requests.

      By default a new servlet is initialized for every request.  A servlet
      instance can be reused by overriding ::get_instance in the
      AbstractServlet subclass.

      == A Simple Servlet

       class Simple < WEBrick::HTTPServlet::AbstractServlet
         def do_GET request, response
           status, content_type, body = do_stuff_with request

           response.status = status
           response['Content-Type'] = content_type
           response.body = body
         end

         def do_stuff_with request
           return 200, 'text/plain', 'you got a page'
         end
       end

      This servlet can be mounted on a server at a given path:

        server.mount '/simple', Simple

      == Servlet Configuration

      Servlets can be configured via initialize.  The first argument is the
      HTTP server the servlet is being initialized for.

       class Configurable < Simple
         def initialize server, color, size
           super server
           @color = color
           @size = size
         end

         def do_stuff_with request
           content = "<p " \
                     %q{style="color: #{@color}; font-size: #{@size}"} \
                     ">Hello, World!"

           return 200, "text/html", content
         end
       end

      This servlet must be provided two arguments at mount time:

        server.mount '/configurable', Configurable, 'red', '2em'
  WEBrick::HTTPServlet::CGIHandler:
    main: |-
      Servlet for handling CGI scripts

      Example:

       server.mount('/cgi/my_script', WEBrick::HTTPServlet::CGIHandler,
                    '/path/to/my_script')
  WEBrick::HTTPServlet::DefaultFileHandler:
    main: |-
      Servlet for serving a single file.  You probably want to use the
      FileHandler servlet instead as it handles directories and fancy indexes.

      Example:

        server.mount('/my_page.txt', WEBrick::HTTPServlet::DefaultFileHandler,
                     '/path/to/my_page.txt')

      This servlet handles If-Modified-Since and Range requests.
  WEBrick::HTTPServlet::ERBHandler:
    main: |-
      ERBHandler evaluates an ERB file and returns the result.  This handler
      is automatically used if there are .rhtml files in a directory served by
      the FileHandler.

      ERBHandler supports GET and POST methods.

      The ERB file is evaluated with the local variables +servlet_request+ and
      +servlet_response+ which are a WEBrick::HTTPRequest and
      WEBrick::HTTPResponse respectively.

      Example .rhtml file:

        Request to <%= servlet_request.request_uri %>

        Query params <%= servlet_request.query.inspect %>
  WEBrick::HTTPServlet::FileHandler:
    main: |-
      Serves a directory including fancy indexing and a variety of other
      options.

      Example:

        server.mount('/assets', WEBrick::HTTPServlet::FileHandler,
                     '/path/to/assets')
  WEBrick::HTTPServlet::ProcHandler:
    main: |-
      Mounts a proc at a path that accepts a request and response.

      Instead of mounting this servlet with WEBrick::HTTPServer#mount use
      WEBrick::HTTPServer#mount_proc:

        server.mount_proc '/' do |req, res|
          res.body = 'it worked!'
          res.status = 200
        end
  WEBrick::HTTPStatus:
    main: |-
      This module is used to manager HTTP status codes.

      See http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html for more
      information.
  WEBrick::HTTPStatus::ClientError:
    main: Root of the HTTP client error statuses
  WEBrick::HTTPStatus::Error:
    main: Root of the HTTP error statuses
  WEBrick::HTTPStatus::Info:
    main: Root of the HTTP info statuses
  WEBrick::HTTPStatus::Redirect:
    main: Root of the HTTP redirect statuses
  WEBrick::HTTPStatus::ServerError:
    main: Root of the HTTP server error statuses
  WEBrick::HTTPStatus::Status:
    main: Root of the HTTP status class hierarchy
  WEBrick::HTTPStatus::Success:
    main: Root of the HTTP success statuses
  WEBrick::HTTPUtils:
    main: |-
      HTTPUtils provides utility methods for working with the HTTP protocol.

      This module is generally used internally by WEBrick
  WEBrick::HTTPUtils::FormData:
    main: |-
      Stores multipart form data.  FormData objects are created when
      WEBrick::HTTPUtils.parse_form_data is called.
  WEBrick::HTTPVersion:
    main: Represents an HTTP protocol version
  WEBrick::Log:
    main: A logging class that prepends a timestamp to each message.
  WEBrick::ServerError:
    main: Server error exception
  WEBrick::SimpleServer:
    main: Base server class
  WEBrick::Utils::TimeoutHandler:
    main: |-
      Class used to manage timeout handlers across multiple threads.

      Timeout handlers should be managed by using the class methods which are
      synchronized.

        id = TimeoutHandler.register(10, Timeout::Error)
        begin
          sleep 20
          puts 'foo'
        ensure
          TimeoutHandler.cancel(id)
        end

      will raise Timeout::Error

        id = TimeoutHandler.register(10, Timeout::Error)
        begin
          sleep 5
          puts 'foo'
        ensure
          TimeoutHandler.cancel(id)
        end

      will print 'foo'
yaml:
  YAML:
    main: |-
      YAML Ain't Markup Language

      This module provides a Ruby interface for data serialization in YAML format.

      The YAML module is an alias of Psych, the YAML engine for Ruby.

      == Usage

      Working with YAML can be very simple, for example:

          require 'yaml'
          # Parse a YAML string
          YAML.load("--- foo") #=> "foo"

          # Emit some YAML
          YAML.dump("foo")     # => "--- foo\n...\n"
          { :a => 'b'}.to_yaml  # => "---\n:a: b\n"

      As the implementation is provided by the Psych library, detailed documentation
      can be found in that library's docs (also part of standard library).

      == Security

      Do not use YAML to load untrusted data. Doing so is unsafe and could allow
      malicious input to execute arbitrary code inside your application. Please see
      doc/security.rdoc for more information.

      == History

      Syck was the original for YAML implementation in Ruby's standard library
      developed by why the lucky stiff.

      You can still use Syck, if you prefer, for parsing and emitting YAML, but you
      must install the 'syck' gem now in order to use it.

      In older Ruby versions, ie. <= 1.9, Syck is still provided, however it was
      completely removed with the release of Ruby 2.0.0.

      == More info

      For more advanced details on the implementation see Psych, and also check out
      http://yaml.org for spec details and other helpful information.

      Psych is maintained by Aaron Patterson on github: https://github.com/ruby/psych

      Syck can also be found on github: https://github.com/ruby/syck
  YAML::DBM:
    main: |-
      YAML + DBM = YDBM

      YAML::DBM provides the same interface as ::DBM.

      However, while DBM only allows strings for both keys and values,
      this library allows one to use most Ruby objects for values
      by first converting them to YAML. Keys must be strings.

      Conversion to and from YAML is performed automatically.

      See the documentation for ::DBM and ::YAML for more information.
  YAML::Store:
    main: |-
      YAML::Store provides the same functionality as PStore, except it uses YAML
      to dump objects instead of Marshal.

      == Example

        require 'yaml/store'

        Person = Struct.new :first_name, :last_name

        people = [Person.new("Bob", "Smith"), Person.new("Mary", "Johnson")]

        store = YAML::Store.new "test.store"

        store.transaction do
          store["people"] = people
          store["greeting"] = { "hello" => "world" }
        end

      After running the above code, the contents of "test.store" will be:

        ---
        people:
        - !ruby/struct:Person
          first_name: Bob
          last_name: Smith
        - !ruby/struct:Person
          first_name: Mary
          last_name: Johnson
        greeting:
          hello: world
