---
Array: |-
  Arrays are ordered, integer-indexed collections of any object.

  Array indexing starts at 0, as in C or Java.  A negative index is assumed
  to be relative to the end of the array---that is, an index of -1 indicates
  the last element of the array, -2 is the next to last element in the
  array, and so on.

  == Creating Arrays

  A new array can be created by using the literal constructor
  <code>[]</code>.  Arrays can contain different types of objects.  For
  example, the array below contains an Integer, a String and a Float:

     ary = [1, "two", 3.0] #=> [1, "two", 3.0]

  An array can also be created by explicitly calling Array.new with zero, one
  (the initial size of the Array) or two arguments (the initial size and a
  default object).

     ary = Array.new    #=> []
     Array.new(3)       #=> [nil, nil, nil]
     Array.new(3, true) #=> [true, true, true]

  Note that the second argument populates the array with references to the
  same object.  Therefore, it is only recommended in cases when you need to
  instantiate arrays with natively immutable objects such as Symbols,
  numbers, true or false.

  To create an array with separate objects a block can be passed instead.
  This method is safe to use with mutable objects such as hashes, strings or
  other arrays:

     Array.new(4) {Hash.new}    #=> [{}, {}, {}, {}]
     Array.new(4) {|i| i.to_s } #=> ["0", "1", "2", "3"]

  This is also a quick way to build up multi-dimensional arrays:

     empty_table = Array.new(3) {Array.new(3)}
     #=> [[nil, nil, nil], [nil, nil, nil], [nil, nil, nil]]

  An array can also be created by using the Array() method, provided by
  Kernel, which tries to call #to_ary, then #to_a on its argument.

      Array({:a => "a", :b => "b"}) #=> [[:a, "a"], [:b, "b"]]

  == Example Usage

  In addition to the methods it mixes in through the Enumerable module, the
  Array class has proprietary methods for accessing, searching and otherwise
  manipulating arrays.

  Some of the more common ones are illustrated below.

  == Accessing Elements

  Elements in an array can be retrieved using the Array#[] method.  It can
  take a single integer argument (a numeric index), a pair of arguments
  (start and length) or a range. Negative indices start counting from the end,
  with -1 being the last element.

     arr = [1, 2, 3, 4, 5, 6]
     arr[2]    #=> 3
     arr[100]  #=> nil
     arr[-3]   #=> 4
     arr[2, 3] #=> [3, 4, 5]
     arr[1..4] #=> [2, 3, 4, 5]
     arr[1..-3] #=> [2, 3, 4]

  Another way to access a particular array element is by using the #at method

     arr.at(0) #=> 1

  The #slice method works in an identical manner to Array#[].

  To raise an error for indices outside of the array bounds or else to
  provide a default value when that happens, you can use #fetch.

     arr = ['a', 'b', 'c', 'd', 'e', 'f']
     arr.fetch(100) #=> IndexError: index 100 outside of array bounds: -6...6
     arr.fetch(100, "oops") #=> "oops"

  The special methods #first and #last will return the first and last
  elements of an array, respectively.

     arr.first #=> 1
     arr.last  #=> 6

  To return the first +n+ elements of an array, use #take

     arr.take(3) #=> [1, 2, 3]

  #drop does the opposite of #take, by returning the elements after +n+
  elements have been dropped:

     arr.drop(3) #=> [4, 5, 6]

  == Obtaining Information about an Array

  Arrays keep track of their own length at all times.  To query an array
  about the number of elements it contains, use #length, #count or #size.

    browsers = ['Chrome', 'Firefox', 'Safari', 'Opera', 'IE']
    browsers.length #=> 5
    browsers.count #=> 5

  To check whether an array contains any elements at all

    browsers.empty? #=> false

  To check whether a particular item is included in the array

    browsers.include?('Konqueror') #=> false

  == Adding Items to Arrays

  Items can be added to the end of an array by using either #push or #<<

    arr = [1, 2, 3, 4]
    arr.push(5) #=> [1, 2, 3, 4, 5]
    arr << 6    #=> [1, 2, 3, 4, 5, 6]

  #unshift will add a new item to the beginning of an array.

     arr.unshift(0) #=> [0, 1, 2, 3, 4, 5, 6]

  With #insert you can add a new element to an array at any position.

     arr.insert(3, 'apple')  #=> [0, 1, 2, 'apple', 3, 4, 5, 6]

  Using the #insert method, you can also insert multiple values at once:

     arr.insert(3, 'orange', 'pear', 'grapefruit')
     #=> [0, 1, 2, "orange", "pear", "grapefruit", "apple", 3, 4, 5, 6]

  == Removing Items from an Array

  The method #pop removes the last element in an array and returns it:

     arr =  [1, 2, 3, 4, 5, 6]
     arr.pop #=> 6
     arr #=> [1, 2, 3, 4, 5]

  To retrieve and at the same time remove the first item, use #shift:

     arr.shift #=> 1
     arr #=> [2, 3, 4, 5]

  To delete an element at a particular index:

     arr.delete_at(2) #=> 4
     arr #=> [2, 3, 5]

  To delete a particular element anywhere in an array, use #delete:

     arr = [1, 2, 2, 3]
     arr.delete(2) #=> 2
     arr #=> [1,3]

  A useful method if you need to remove +nil+ values from an array is
  #compact:

     arr = ['foo', 0, nil, 'bar', 7, 'baz', nil]
     arr.compact  #=> ['foo', 0, 'bar', 7, 'baz']
     arr          #=> ['foo', 0, nil, 'bar', 7, 'baz', nil]
     arr.compact! #=> ['foo', 0, 'bar', 7, 'baz']
     arr          #=> ['foo', 0, 'bar', 7, 'baz']

  Another common need is to remove duplicate elements from an array.

  It has the non-destructive #uniq, and destructive method #uniq!

     arr = [2, 5, 6, 556, 6, 6, 8, 9, 0, 123, 556]
     arr.uniq #=> [2, 5, 6, 556, 8, 9, 0, 123]

  == Iterating over Arrays

  Like all classes that include the Enumerable module, Array has an each
  method, which defines what elements should be iterated over and how.  In
  case of Array's #each, all elements in the Array instance are yielded to
  the supplied block in sequence.

  Note that this operation leaves the array unchanged.

     arr = [1, 2, 3, 4, 5]
     arr.each {|a| print a -= 10, " "}
     # prints: -9 -8 -7 -6 -5
     #=> [1, 2, 3, 4, 5]

  Another sometimes useful iterator is #reverse_each which will iterate over
  the elements in the array in reverse order.

     words = %w[first second third fourth fifth sixth]
     str = ""
     words.reverse_each {|word| str += "#{word} "}
     p str #=> "sixth fifth fourth third second first "

  The #map method can be used to create a new array based on the original
  array, but with the values modified by the supplied block:

     arr.map {|a| 2*a}     #=> [2, 4, 6, 8, 10]
     arr                   #=> [1, 2, 3, 4, 5]
     arr.map! {|a| a**2}   #=> [1, 4, 9, 16, 25]
     arr                   #=> [1, 4, 9, 16, 25]

  == Selecting Items from an Array

  Elements can be selected from an array according to criteria defined in a
  block.  The selection can happen in a destructive or a non-destructive
  manner.  While the destructive operations will modify the array they were
  called on, the non-destructive methods usually return a new array with the
  selected elements, but leave the original array unchanged.

  === Non-destructive Selection

     arr = [1, 2, 3, 4, 5, 6]
     arr.select {|a| a > 3}       #=> [4, 5, 6]
     arr.reject {|a| a < 3}       #=> [3, 4, 5, 6]
     arr.drop_while {|a| a < 4}   #=> [4, 5, 6]
     arr                          #=> [1, 2, 3, 4, 5, 6]

  === Destructive Selection

  #select! and #reject! are the corresponding destructive methods to #select
  and #reject

  Similar to #select vs. #reject, #delete_if and #keep_if have the exact
  opposite result when supplied with the same block:

     arr.delete_if {|a| a < 4}   #=> [4, 5, 6]
     arr                         #=> [4, 5, 6]

     arr = [1, 2, 3, 4, 5, 6]
     arr.keep_if {|a| a < 4}   #=> [1, 2, 3]
     arr                       #=> [1, 2, 3]
RubyVM: |-
  The RubyVM module only exists on MRI. +RubyVM+ is not defined in
  other Ruby implementations such as JRuby and TruffleRuby.

  The RubyVM module provides some access to MRI internals.
  This module is for very limited purposes, such as debugging,
  prototyping, and research.  Normal users must not use it.
  This module is not portable between Ruby implementations.
RubyVM::InstructionSequence: |-
  The InstructionSequence class represents a compiled sequence of
  instructions for the Virtual Machine used in MRI. Not all implementations of Ruby
  may implement this class, and for the implementations that implement it,
  the methods defined and behavior of the methods can change in any version.

  With it, you can get a handle to the instructions that make up a method or
  a proc, compile strings of Ruby code down to VM instructions, and
  disassemble instruction sequences to strings for easy inspection. It is
  mostly useful if you want to learn how YARV works, but it also lets
  you control various settings for the Ruby iseq compiler.

  You can find the source for the VM instructions in +insns.def+ in the Ruby
  source.

  The instruction sequence results will almost certainly change as Ruby
  changes, so example output in this documentation may be different from what
  you see.

  Of course, this class is MRI specific.
RubyVM::AbstractSyntaxTree: |-
  AbstractSyntaxTree provides methods to parse Ruby code into
  abstract syntax trees. The nodes in the tree
  are instances of RubyVM::AbstractSyntaxTree::Node.

  This class is MRI specific as it exposes implementation details
  of the MRI abstract syntax tree.

  This class is experimental and its API is not stable, therefore it might
  change without notice. As examples, the order of children nodes is not
  guaranteed, the number of children nodes might change, there is no way to
  access children nodes by name, etc.

  If you are looking for a stable API or an API working under multiple Ruby
  implementations, consider using the _parser_ gem or Ripper. If you would
  like to make RubyVM::AbstractSyntaxTree stable, please join the discussion
  at https://bugs.ruby-lang.org/issues/14844.
RubyVM::AbstractSyntaxTree::Node: |-
  RubyVM::AbstractSyntaxTree::Node instances are created by parse methods in
  RubyVM::AbstractSyntaxTree.

  This class is MRI specific.
RubyVM::MJIT: |-
  ::RubyVM::MJIT
      Provides access to the Method JIT compiler of MRI.
      Of course, this module is MRI specific.
Object: |-
  Object is the default root of all Ruby objects.  Object inherits from
  BasicObject which allows creating alternate object hierarchies.  Methods
  on Object are available to all classes unless explicitly overridden.

  Object mixes in the Kernel module, making the built-in kernel functions
  globally accessible.  Although the instance methods of Object are defined
  by the Kernel module, we have chosen to document them here for clarity.

  When referencing constants in classes inheriting from Object you do not
  need to use the full namespace.  For example, referencing +File+ inside
  +YourClass+ will find the top-level File class.

  In the descriptions of Object's methods, the parameter <i>symbol</i> refers
  to a symbol, which is either a quoted string or a Symbol (such as
  <code>:name</code>).
Integer: |-
  Holds Integer values.  You cannot add a singleton method to an
  Integer object, any attempt to do so will raise a TypeError.
Comparable: |-
  The Comparable mixin is used by classes whose objects may be
  ordered. The class must define the <code><=></code> operator,
  which compares the receiver against another object, returning a
  value less than 0, returning 0, or returning a value greater than 0,
  depending on whether the receiver is less than, equal to,
  or greater than the other object. If the other object is not
  comparable then the <code><=></code> operator should return +nil+.
  Comparable uses <code><=></code> to implement the conventional
  comparison operators (<code><</code>, <code><=</code>,
  <code>==</code>, <code>>=</code>, and <code>></code>) and the
  method <code>between?</code>.

     class SizeMatters
       include Comparable
       attr :str
       def <=>(other)
         str.size <=> other.str.size
       end
       def initialize(str)
         @str = str
       end
       def inspect
         @str
       end
     end

     s1 = SizeMatters.new("Z")
     s2 = SizeMatters.new("YY")
     s3 = SizeMatters.new("XXX")
     s4 = SizeMatters.new("WWWW")
     s5 = SizeMatters.new("VVVVV")

     s1 < s2                       #=> true
     s4.between?(s1, s3)           #=> false
     s4.between?(s3, s5)           #=> true
     [ s3, s2, s5, s4, s1 ].sort   #=> [Z, YY, XXX, WWWW, VVVVV]
Complex: |-
  A complex number can be represented as a paired real number with
  imaginary unit; a+bi.  Where a is real part, b is imaginary part
  and i is imaginary unit.  Real a equals complex a+0i
  mathematically.

  Complex object can be created as literal, and also by using
  Kernel#Complex, Complex::rect, Complex::polar or to_c method.

     2+1i                 #=> (2+1i)
     Complex(1)           #=> (1+0i)
     Complex(2, 3)        #=> (2+3i)
     Complex.polar(2, 3)  #=> (-1.9799849932008908+0.2822400161197344i)
     3.to_c               #=> (3+0i)

  You can also create complex object from floating-point numbers or
  strings.

     Complex(0.3)         #=> (0.3+0i)
     Complex('0.3-0.5i')  #=> (0.3-0.5i)
     Complex('2/3+3/4i')  #=> ((2/3)+(3/4)*i)
     Complex('1@2')       #=> (-0.4161468365471424+0.9092974268256817i)

     0.3.to_c             #=> (0.3+0i)
     '0.3-0.5i'.to_c      #=> (0.3-0.5i)
     '2/3+3/4i'.to_c      #=> ((2/3)+(3/4)*i)
     '1@2'.to_c           #=> (-0.4161468365471424+0.9092974268256817i)

  A complex object is either an exact or an inexact number.

     Complex(1, 1) / 2    #=> ((1/2)+(1/2)*i)
     Complex(1, 1) / 2.0  #=> (0.5+0.5i)
NilClass: The class of the singleton object <code>nil</code>.
Numeric: |-
  Numeric is the class from which all higher-level numeric classes should inherit.

  Numeric allows instantiation of heap-allocated objects. Other core numeric classes such as
  Integer are implemented as immediates, which means that each Integer is a single immutable
  object which is always passed by value.

    a = 1
    1.object_id == a.object_id   #=> true

  There can only ever be one instance of the integer +1+, for example. Ruby ensures this
  by preventing instantiation. If duplication is attempted, the same instance is returned.

    Integer.new(1)                   #=> NoMethodError: undefined method `new' for Integer:Class
    1.dup                            #=> 1
    1.object_id == 1.dup.object_id   #=> true

  For this reason, Numeric should be used when defining other numeric classes.

  Classes which inherit from Numeric must implement +coerce+, which returns a two-member
  Array containing an object that has been coerced into an instance of the new class
  and +self+ (see #coerce).

  Inheriting classes should also implement arithmetic operator methods (<code>+</code>,
  <code>-</code>, <code>*</code> and <code>/</code>) and the <code><=></code> operator (see
  Comparable). These methods may rely on +coerce+ to ensure interoperability with
  instances of other numeric classes.

    class Tally < Numeric
      def initialize(string)
        @string = string
      end

      def to_s
        @string
      end

      def to_i
        @string.size
      end

      def coerce(other)
        [self.class.new('|' * other.to_i), self]
      end

      def <=>(other)
        to_i <=> other.to_i
      end

      def +(other)
        self.class.new('|' * (to_i + other.to_i))
      end

      def -(other)
        self.class.new('|' * (to_i - other.to_i))
      end

      def *(other)
        self.class.new('|' * (to_i * other.to_i))
      end

      def /(other)
        self.class.new('|' * (to_i / other.to_i))
      end
    end

    tally = Tally.new('||')
    puts tally * 2            #=> "||||"
    puts tally > 1            #=> true
String: |-
  A String object holds and manipulates an arbitrary sequence of
  bytes, typically representing characters. String objects may be created
  using String::new or as literals.

  Because of aliasing issues, users of strings should be aware of the methods
  that modify the contents of a String object.  Typically,
  methods with names ending in ``!'' modify their receiver, while those
  without a ``!'' return a new String.  However, there are
  exceptions, such as String#[]=.
Float: |-
  Float objects represent inexact real numbers using the native
  architecture's double-precision floating point representation.

  Floating point has a different arithmetic and is an inexact number.
  So you should know its esoteric system. See following:

  - http://docs.sun.com/source/806-3568/ncg_goldberg.html
  - https://github.com/rdp/ruby_tutorials_core/wiki/Ruby-Talk-FAQ#floats_imprecise
  - http://en.wikipedia.org/wiki/Floating_point#Accuracy_problems
Kernel: |-
  The Kernel module is included by class Object, so its methods are
  available in every Ruby object.

  The Kernel instance methods are documented in class Object while the
  module methods are documented here.  These methods are called without a
  receiver and thus can be called in functional form:

    sprintf "%.1f", 1.234 #=> "1.2"
Fiber: |-
  Fibers are primitives for implementing light weight cooperative
  concurrency in Ruby. Basically they are a means of creating code blocks
  that can be paused and resumed, much like threads. The main difference
  is that they are never preempted and that the scheduling must be done by
  the programmer and not the VM.

  As opposed to other stackless light weight concurrency models, each fiber
  comes with a stack.  This enables the fiber to be paused from deeply
  nested function calls within the fiber block.  See the ruby(1)
  manpage to configure the size of the fiber stack(s).

  When a fiber is created it will not run automatically. Rather it must
  be explicitly asked to run using the Fiber#resume method.
  The code running inside the fiber can give up control by calling
  Fiber.yield in which case it yields control back to caller (the
  caller of the Fiber#resume).

  Upon yielding or termination the Fiber returns the value of the last
  executed expression

  For instance:

    fiber = Fiber.new do
      Fiber.yield 1
      2
    end

    puts fiber.resume
    puts fiber.resume
    puts fiber.resume

  <em>produces</em>

    1
    2
    FiberError: dead fiber called

  The Fiber#resume method accepts an arbitrary number of parameters,
  if it is the first call to #resume then they will be passed as
  block arguments. Otherwise they will be the return value of the
  call to Fiber.yield

  Example:

    fiber = Fiber.new do |first|
      second = Fiber.yield first + 2
    end

    puts fiber.resume 10
    puts fiber.resume 1_000_000
    puts fiber.resume "The fiber will be dead before I can cause trouble"

  <em>produces</em>

    12
    1000000
    FiberError: dead fiber called
FiberError: |-
  Raised when an invalid operation is attempted on a Fiber, in
  particular when attempting to call/resume a dead fiber,
  attempting to yield from the root fiber, or calling a fiber across
  threads.

     fiber = Fiber.new{}
     fiber.resume #=> nil
     fiber.resume #=> FiberError: dead fiber called
Continuation: |-
  Continuation objects are generated by Kernel#callcc,
  after having +require+d <i>continuation</i>. They hold
  a return address and execution context, allowing a nonlocal return
  to the end of the #callcc block from anywhere within a
  program. Continuations are somewhat analogous to a structured
  version of C's <code>setjmp/longjmp</code> (although they contain
  more state, so you might consider them closer to threads).

  For instance:

     require "continuation"
     arr = [ "Freddie", "Herbie", "Ron", "Max", "Ringo" ]
     callcc{|cc| $cc = cc}
     puts(message = arr.shift)
     $cc.call unless message =~ /Max/

  <em>produces:</em>

     Freddie
     Herbie
     Ron
     Max

  Also you can call callcc in other methods:

     require "continuation"

     def g
       arr = [ "Freddie", "Herbie", "Ron", "Max", "Ringo" ]
       cc = callcc { |cc| cc }
       puts arr.shift
       return cc, arr.size
     end

     def f
       c, size = g
       c.call(c) if size > 1
     end

     f

  This (somewhat contrived) example allows the inner loop to abandon
  processing early:

     require "continuation"
     callcc {|cont|
       for i in 0..4
         print "#{i}: "
         for j in i*5...(i+1)*5
           cont.call() if j == 17
           printf "%3d", j
         end
       end
     }
     puts

  <em>produces:</em>

     0:   0  1  2  3  4
     1:   5  6  7  8  9
     2:  10 11 12 13 14
     3:  15 16
Dir: |-
  Objects of class Dir are directory streams representing
  directories in the underlying file system. They provide a variety
  of ways to list directories and their contents. See also File.

  The directory used in these examples contains the two regular files
  (<code>config.h</code> and <code>main.rb</code>), the parent
  directory (<code>..</code>), and the directory itself
  (<code>.</code>).
File: |-
  A File is an abstraction of any file object accessible by the
  program and is closely associated with class IO.  File includes
  the methods of module FileTest as class methods, allowing you to
  write (for example) <code>File.exist?("foo")</code>.

  In the description of File methods,
  <em>permission bits</em> are a platform-specific
  set of bits that indicate permissions of a file. On Unix-based
  systems, permissions are viewed as a set of three octets, for the
  owner, the group, and the rest of the world. For each of these
  entities, permissions may be set to read, write, or execute the
  file:

  The permission bits <code>0644</code> (in octal) would thus be
  interpreted as read/write for owner, and read-only for group and
  other. Higher-order bits may also be used to indicate the type of
  file (plain, directory, pipe, socket, and so on) and various other
  special features. If the permissions are for a directory, the
  meaning of the execute bit changes; when set the directory can be
  searched.

  On non-Posix operating systems, there may be only the ability to
  make a file read-only or read-write. In this case, the remaining
  permission bits will be synthesized to resemble typical values. For
  instance, on Windows NT the default permission bits are
  <code>0644</code>, which means read/write for owner, read-only for
  all others. The only change that can be made is to make the file
  read-only, which is reported as <code>0444</code>.

  Various constants for the methods in File can be found in File::Constants.
File::Stat: |-
  Objects of class File::Stat encapsulate common status information
  for File objects. The information is recorded at the moment the
  File::Stat object is created; changes made to the file after that
  point will not be reflected. File::Stat objects are returned by
  IO#stat, File::stat, File#lstat, and File::lstat. Many of these
  methods return platform-specific values, and not all values are
  meaningful on all systems. See also Kernel#test.
File::File::Constants: |-
  Document-module: File::Constants

  File::Constants provides file-related constants.  All possible
  file constants are listed in the documentation but they may not all
  be present on your platform.

  If the underlying platform doesn't define a constant the corresponding
  Ruby constant is not defined.

  Your platform documentations (e.g. man open(2)) may describe more
  detailed information.
Encoding: |-
  An Encoding instance represents a character encoding usable in Ruby. It is
  defined as a constant under the Encoding namespace. It has a name and
  optionally, aliases:

    Encoding::ISO_8859_1.name
    #=> "ISO-8859-1"

    Encoding::ISO_8859_1.names
    #=> ["ISO-8859-1", "ISO8859-1"]

  Ruby methods dealing with encodings return or accept Encoding instances as
  arguments (when a method accepts an Encoding instance as an argument, it
  can be passed an Encoding name or alias instead).

    "some string".encoding
    #=> #<Encoding:UTF-8>

    string = "some string".encode(Encoding::ISO_8859_1)
    #=> "some string"
    string.encoding
    #=> #<Encoding:ISO-8859-1>

    "some string".encode "ISO-8859-1"
    #=> "some string"

  Encoding::ASCII_8BIT is a special encoding that is usually used for
  a byte string, not a character string. But as the name insists, its
  characters in the range of ASCII are considered as ASCII
  characters.  This is useful when you use ASCII-8BIT characters with
  other ASCII compatible characters.

  == Changing an encoding

  The associated Encoding of a String can be changed in two different ways.

  First, it is possible to set the Encoding of a string to a new Encoding
  without changing the internal byte representation of the string, with
  String#force_encoding. This is how you can tell Ruby the correct encoding
  of a string.

    string
    #=> "R\xC3\xA9sum\xC3\xA9"
    string.encoding
    #=> #<Encoding:ISO-8859-1>
    string.force_encoding(Encoding::UTF_8)
    #=> "R\u00E9sum\u00E9"

  Second, it is possible to transcode a string, i.e. translate its internal
  byte representation to another encoding. Its associated encoding is also
  set to the other encoding. See String#encode for the various forms of
  transcoding, and the Encoding::Converter class for additional control over
  the transcoding process.

    string
    #=> "R\u00E9sum\u00E9"
    string.encoding
    #=> #<Encoding:UTF-8>
    string = string.encode!(Encoding::ISO_8859_1)
    #=> "R\xE9sum\xE9"
    string.encoding
    #=> #<Encoding::ISO-8859-1>

  == Script encoding

  All Ruby script code has an associated Encoding which any String literal
  created in the source code will be associated to.

  The default script encoding is Encoding::UTF_8 after v2.0, but it
  can be changed by a magic comment on the first line of the source
  code file (or second line, if there is a shebang line on the
  first). The comment must contain the word <code>coding</code> or
  <code>encoding</code>, followed by a colon, space and the Encoding
  name or alias:

    # encoding: UTF-8

    "some string".encoding
    #=> #<Encoding:UTF-8>

  The <code>__ENCODING__</code> keyword returns the script encoding of the file
  which the keyword is written:

    # encoding: ISO-8859-1

    __ENCODING__
    #=> #<Encoding:ISO-8859-1>

  <code>ruby -K</code> will change the default locale encoding, but this is
  not recommended. Ruby source files should declare its script encoding by a
  magic comment even when they only depend on US-ASCII strings or regular
  expressions.

  == Locale encoding

  The default encoding of the environment. Usually derived from locale.

  see Encoding.locale_charmap, Encoding.find('locale')

  == Filesystem encoding

  The default encoding of strings from the filesystem of the environment.
  This is used for strings of file names or paths.

  see Encoding.find('filesystem')

  == External encoding

  Each IO object has an external encoding which indicates the encoding that
  Ruby will use to read its data. By default Ruby sets the external encoding
  of an IO object to the default external encoding. The default external
  encoding is set by locale encoding or the interpreter <code>-E</code> option.
  Encoding.default_external returns the current value of the external
  encoding.

    ENV["LANG"]
    #=> "UTF-8"
    Encoding.default_external
    #=> #<Encoding:UTF-8>

    $ ruby -E ISO-8859-1 -e "p Encoding.default_external"
    #<Encoding:ISO-8859-1>

    $ LANG=C ruby -e 'p Encoding.default_external'
    #<Encoding:US-ASCII>

  The default external encoding may also be set through
  Encoding.default_external=, but you should not do this as strings created
  before and after the change will have inconsistent encodings.  Instead use
  <code>ruby -E</code> to invoke ruby with the correct external encoding.

  When you know that the actual encoding of the data of an IO object is not
  the default external encoding, you can reset its external encoding with
  IO#set_encoding or set it at IO object creation (see IO.new options).

  == Internal encoding

  To process the data of an IO object which has an encoding different
  from its external encoding, you can set its internal encoding. Ruby will use
  this internal encoding to transcode the data when it is read from the IO
  object.

  Conversely, when data is written to the IO object it is transcoded from the
  internal encoding to the external encoding of the IO object.

  The internal encoding of an IO object can be set with
  IO#set_encoding or at IO object creation (see IO.new options).

  The internal encoding is optional and when not set, the Ruby default
  internal encoding is used. If not explicitly set this default internal
  encoding is +nil+ meaning that by default, no transcoding occurs.

  The default internal encoding can be set with the interpreter option
  <code>-E</code>. Encoding.default_internal returns the current internal
  encoding.

     $ ruby -e 'p Encoding.default_internal'
     nil

     $ ruby -E ISO-8859-1:UTF-8 -e "p [Encoding.default_external, \
       Encoding.default_internal]"
     [#<Encoding:ISO-8859-1>, #<Encoding:UTF-8>]

  The default internal encoding may also be set through
  Encoding.default_internal=, but you should not do this as strings created
  before and after the change will have inconsistent encodings.  Instead use
  <code>ruby -E</code> to invoke ruby with the correct internal encoding.

  == IO encoding example

  In the following example a UTF-8 encoded string "R\u00E9sum\u00E9" is transcoded for
  output to ISO-8859-1 encoding, then read back in and transcoded to UTF-8:

    string = "R\u00E9sum\u00E9"

    open("transcoded.txt", "w:ISO-8859-1") do |io|
      io.write(string)
    end

    puts "raw text:"
    p File.binread("transcoded.txt")
    puts

    open("transcoded.txt", "r:ISO-8859-1:UTF-8") do |io|
      puts "transcoded text:"
      p io.read
    end

  While writing the file, the internal encoding is not specified as it is
  only necessary for reading.  While reading the file both the internal and
  external encoding must be specified to obtain the correct result.

    $ ruby t.rb
    raw text:
    "R\xE9sum\xE9"

    transcoded text:
    "R\u00E9sum\u00E9"
Encoding::CompatibilityError: |-
  Raised by Encoding and String methods when the source encoding is
  incompatible with the target encoding.
Encoding::UndefinedConversionError: |-
  Raised by Encoding and String methods when a transcoding operation
  fails.
Encoding::InvalidByteSequenceError: |-
  Raised by Encoding and String methods when the string being
  transcoded contains a byte invalid for the either the source or
  target encoding.
Encoding::ConverterNotFoundError: |-
  Raised by transcoding methods when a named encoding does not
  correspond with a known converter.
Encoding::Converter: Encoding conversion class.
Enumerable: |-
  The Enumerable mixin provides collection classes with several
  traversal and searching methods, and with the ability to sort. The
  class must provide a method #each, which yields
  successive members of the collection. If Enumerable#max, #min, or
  #sort is used, the objects in the collection must also implement a
  meaningful <code><=></code> operator, as these methods rely on an
  ordering between members of the collection.
Enumerator: |-
  A class which allows both internal and external iteration.

  An Enumerator can be created by the following methods.
  - Object#to_enum
  - Object#enum_for
  - Enumerator.new

  Most methods have two forms: a block form where the contents
  are evaluated for each item in the enumeration, and a non-block form
  which returns a new Enumerator wrapping the iteration.

    enumerator = %w(one two three).each
    puts enumerator.class # => Enumerator

    enumerator.each_with_object("foo") do |item, obj|
      puts "#{obj}: #{item}"
    end

    # foo: one
    # foo: two
    # foo: three

    enum_with_obj = enumerator.each_with_object("foo")
    puts enum_with_obj.class # => Enumerator

    enum_with_obj.each do |item, obj|
      puts "#{obj}: #{item}"
    end

    # foo: one
    # foo: two
    # foo: three

  This allows you to chain Enumerators together.  For example, you
  can map a list's elements to strings containing the index
  and the element as a string via:

    puts %w[foo bar baz].map.with_index { |w, i| "#{i}:#{w}" }
    # => ["0:foo", "1:bar", "2:baz"]

  An Enumerator can also be used as an external iterator.
  For example, Enumerator#next returns the next value of the iterator
  or raises StopIteration if the Enumerator is at the end.

    e = [1,2,3].each   # returns an enumerator object.
    puts e.next   # => 1
    puts e.next   # => 2
    puts e.next   # => 3
    puts e.next   # raises StopIteration

  You can use this to implement an internal iterator as follows:

    def ext_each(e)
      while true
        begin
          vs = e.next_values
        rescue StopIteration
          return $!.result
        end
        y = yield(*vs)
        e.feed y
      end
    end

    o = Object.new

    def o.each
      puts yield
      puts yield(1)
      puts yield(1, 2)
      3
    end

    # use o.each as an internal iterator directly.
    puts o.each {|*x| puts x; [:b, *x] }
    # => [], [:b], [1], [:b, 1], [1, 2], [:b, 1, 2], 3

    # convert o.each to an external iterator for
    # implementing an internal iterator.
    puts ext_each(o.to_enum) {|*x| puts x; [:b, *x] }
    # => [], [:b], [1], [:b, 1], [1, 2], [:b, 1, 2], 3
Enumerator::Lazy: |-
  Enumerator::Lazy is a special type of Enumerator, that allows constructing
  chains of operations without evaluating them immediately, and evaluating
  values on as-needed basis. In order to do so it redefines most of Enumerable
  methods so that they just construct another lazy enumerator.

  Enumerator::Lazy can be constructed from any Enumerable with the
  Enumerable#lazy method.

     lazy = (1..Float::INFINITY).lazy.select(&:odd?).drop(10).take_while { |i| i < 30 }
     # => #<Enumerator::Lazy: #<Enumerator::Lazy: #<Enumerator::Lazy: #<Enumerator::Lazy: 1..Infinity>:select>:drop(10)>:take_while>

  The real enumeration is performed when any non-redefined Enumerable method
  is called, like Enumerable#first or Enumerable#to_a (the latter is aliased
  as #force for more semantic code):

     lazy.first(2)
     #=> [21, 23]

     lazy.force
     #=> [21, 23, 25, 27, 29]

  Note that most Enumerable methods that could be called with or without
  a block, on Enumerator::Lazy will always require a block:

     [1, 2, 3].map       #=> #<Enumerator: [1, 2, 3]:map>
     [1, 2, 3].lazy.map  # ArgumentError: tried to call lazy map without a block

  This class allows idiomatic calculations on long or infinite sequences, as well
  as chaining of calculations without constructing intermediate arrays.

  Example for working with a slowly calculated sequence:

     require 'open-uri'

     # This will fetch all URLs before selecting
     # necessary data
     URLS.map { |u| JSON.parse(open(u).read) }
       .select { |data| data.key?('stats') }
       .first(5)

     # This will fetch URLs one-by-one, only till
     # there is enough data to satisfy the condition
     URLS.lazy.map { |u| JSON.parse(open(u).read) }
       .select { |data| data.key?('stats') }
       .first(5)

  Ending a chain with ".eager" generates a non-lazy enumerator, which
  is suitable for returning or passing to another method that expects
  a normal enumerator.

     def active_items
       groups
         .lazy
         .flat_map(&:items)
         .reject(&:disabled)
         .eager
     end

     # This works lazily; if a checked item is found, it stops
     # iteration and does not look into remaining groups.
     first_checked = active_items.find(&:checked)

     # This returns an array of items like a normal enumerator does.
     all_checked = active_items.select(&:checked)
Enumerator::Generator: 'Generator   '
Enumerator::Yielder: 'Yielder   '
Enumerator::Producer: 'Producer   '
Enumerator::Chain: |-
  Enumerator::Chain is a subclass of Enumerator, which represents a
  chain of enumerables that works as a single enumerator.

  This type of objects can be created by Enumerable#chain and
  Enumerator#+.
Enumerator::ArithmeticSequence: |-
  Enumerator::ArithmeticSequence is a subclass of Enumerator,
  that is a representation of sequences of numbers with common difference.
  Instances of this class can be generated by the Range#step and Numeric#step
  methods.
StopIteration: |-
  Raised to stop the iteration, in particular by Enumerator#next. It is
  rescued by Kernel#loop.

    loop do
      puts "Hello"
      raise StopIteration
      puts "World"
    end
    puts "Done!"

  <em>produces:</em>

    Hello
    Done!
Exception: |-
  \Class Exception and its subclasses are used to communicate between
  Kernel#raise and +rescue+ statements in <code>begin ... end</code> blocks.

  An Exception object carries information about an exception:
  - Its type (the exception's class).
  - An optional descriptive message.
  - Optional backtrace information.

  Some built-in subclasses of Exception have additional methods: e.g., NameError#name.

  == Defaults

  Two Ruby statements have default exception classes:
  - +raise+: defaults to RuntimeError.
  - +rescue+: defaults to StandardError.

  == Global Variables

  When an exception has been raised but not yet handled (in +rescue+,
  +ensure+, +at_exit+ and +END+ blocks), two global variables are set:
  - <code>$!</code> contains the current exception.
  - <code>$@</code> contains its backtrace.

  == Custom Exceptions

  To provide additional or alternate information,
  a program may create custom exception classes
  that derive from the built-in exception classes.

  A good practice is for a library to create a single "generic" exception class
  (typically a subclass of StandardError or RuntimeError)
  and have its other exception classes derive from that class.
  This allows the user to rescue the generic exception, thus catching all exceptions
  the library may raise even if future versions of the library add new
  exception subclasses.

  For example:

    class MyLibrary
      class Error < ::StandardError
      end

      class WidgetError < Error
      end

      class FrobError < Error
      end

    end

  To handle both MyLibrary::WidgetError and MyLibrary::FrobError the library
  user can rescue MyLibrary::Error.

  == Built-In Exception Classes

  The built-in subclasses of Exception are:

  * NoMemoryError
  * ScriptError
    * LoadError
    * NotImplementedError
    * SyntaxError
  * SecurityError
  * SignalException
    * Interrupt
  * StandardError
    * ArgumentError
      * UncaughtThrowError
    * EncodingError
    * FiberError
    * IOError
      * EOFError
    * IndexError
      * KeyError
      * StopIteration
        * ClosedQueueError
    * LocalJumpError
    * NameError
      * NoMethodError
    * RangeError
      * FloatDomainError
    * RegexpError
    * RuntimeError
      * FrozenError
    * SystemCallError
      * Errno::*
    * ThreadError
    * TypeError
    * ZeroDivisionError
  * SystemExit
  * SystemStackError
  * fatal
SystemExit: Raised by +exit+ to initiate the termination of the script.
fatal: |-
  fatal is an Exception that is raised when Ruby has encountered a fatal
  error and must exit.
SignalException: |-
  Raised when a signal is received.

     begin
       Process.kill('HUP',Process.pid)
       sleep # wait for receiver to handle signal sent by Process.kill
     rescue SignalException => e
       puts "received Exception #{e}"
     end

  <em>produces:</em>

     received Exception SIGHUP
Interrupt: |-
  Raised when the interrupt signal is received, typically because the
  user has pressed Control-C (on most posix platforms). As such, it is a
  subclass of +SignalException+.

     begin
       puts "Press ctrl-C when you get bored"
       loop {}
     rescue Interrupt => e
       puts "Note: You will typically use Signal.trap instead."
     end

  <em>produces:</em>

     Press ctrl-C when you get bored

  <em>then waits until it is interrupted with Control-C and then prints:</em>

     Note: You will typically use Signal.trap instead.
StandardError: |-
  The most standard error types are subclasses of StandardError. A
  rescue clause without an explicit Exception class will rescue all
  StandardErrors (and only those).

     def foo
       raise "Oups"
     end
     foo rescue "Hello"   #=> "Hello"

  On the other hand:

     require 'does/not/exist' rescue "Hi"

  <em>raises the exception:</em>

     LoadError: no such file to load -- does/not/exist
TypeError: |-
  Raised when encountering an object that is not of the expected type.

     [1, 2, 3].first("two")

  <em>raises the exception:</em>

     TypeError: no implicit conversion of String into Integer
ArgumentError: |-
  Raised when the arguments are wrong and there isn't a more specific
  Exception class.

  Ex: passing the wrong number of arguments

     [1, 2, 3].first(4, 5)

  <em>raises the exception:</em>

     ArgumentError: wrong number of arguments (given 2, expected 1)

  Ex: passing an argument that is not acceptable:

     [1, 2, 3].first(-4)

  <em>raises the exception:</em>

     ArgumentError: negative array size
IndexError: |-
  Raised when the given index is invalid.

     a = [:foo, :bar]
     a.fetch(0)   #=> :foo
     a[4]         #=> nil
     a.fetch(4)   #=> IndexError: index 4 outside of array bounds: -2...2
KeyError: |-
  Raised when the specified key is not found. It is a subclass of
  IndexError.

     h = {"foo" => :bar}
     h.fetch("foo") #=> :bar
     h.fetch("baz") #=> KeyError: key not found: "baz"
RangeError: |-
  Raised when a given numerical value is out of range.

     [1, 2, 3].drop(1 << 100)

  <em>raises the exception:</em>

     RangeError: bignum too big to convert into `long'
ScriptError: |-
  ScriptError is the superclass for errors raised when a script
  can not be executed because of a +LoadError+,
  +NotImplementedError+ or a +SyntaxError+. Note these type of
  +ScriptErrors+ are not +StandardError+ and will not be
  rescued unless it is specified explicitly (or its ancestor
  +Exception+).
SyntaxError: |-
  Raised when encountering Ruby code with an invalid syntax.

     eval("1+1=2")

  <em>raises the exception:</em>

     SyntaxError: (eval):1: syntax error, unexpected '=', expecting $end
LoadError: |-
  Raised when a file required (a Ruby script, extension library, ...)
  fails to load.

     require 'this/file/does/not/exist'

  <em>raises the exception:</em>

     LoadError: no such file to load -- this/file/does/not/exist
NotImplementedError: |-
  Raised when a feature is not implemented on the current platform. For
  example, methods depending on the +fsync+ or +fork+ system calls may
  raise this exception if the underlying operating system or Ruby
  runtime does not support them.

  Note that if +fork+ raises a +NotImplementedError+, then
  <code>respond_to?(:fork)</code> returns +false+.
NameError: |-
  Raised when a given name is invalid or undefined.

     puts foo

  <em>raises the exception:</em>

     NameError: undefined local variable or method `foo' for main:Object

  Since constant names must start with a capital:

     Integer.const_set :answer, 42

  <em>raises the exception:</em>

     NameError: wrong constant name answer
NoMethodError: |-
  Raised when a method is called on a receiver which doesn't have it
  defined and also fails to respond with +method_missing+.

     "hello".to_ary

  <em>raises the exception:</em>

     NoMethodError: undefined method `to_ary' for "hello":String
RuntimeError: |-
  A generic error class raised when an invalid operation is attempted.
  Kernel#raise will raise a RuntimeError if no Exception class is
  specified.

     raise "ouch"

  <em>raises the exception:</em>

     RuntimeError: ouch
FrozenError: |-
  Raised when there is an attempt to modify a frozen object.

     [1, 2, 3].freeze << 4

  <em>raises the exception:</em>

     FrozenError: can't modify frozen Array
SecurityError: No longer used by internal code.
NoMemoryError: Raised when memory allocation fails.
EncodingError: EncodingError is the base class for encoding errors.
SystemCallError: |-
  SystemCallError is the base class for all low-level
  platform-dependent errors.

  The errors available on the current platform are subclasses of
  SystemCallError and are defined in the Errno module.

     File.open("does/not/exist")

  <em>raises the exception:</em>

     Errno::ENOENT: No such file or directory - does/not/exist
Errno: |-
  Ruby exception objects are subclasses of Exception.  However,
  operating systems typically report errors using plain
  integers. Module Errno is created dynamically to map these
  operating system errors to Ruby classes, with each error number
  generating its own subclass of SystemCallError.  As the subclass
  is created in module Errno, its name will start
  <code>Errno::</code>.

  The names of the <code>Errno::</code> classes depend on the
  environment in which Ruby runs. On a typical Unix or Windows
  platform, there are Errno classes such as Errno::EACCES,
  Errno::EAGAIN, Errno::EINTR, and so on.

  The integer operating system error number corresponding to a
  particular error is available as the class constant
  <code>Errno::</code><em>error</em><code>::Errno</code>.

     Errno::EACCES::Errno   #=> 13
     Errno::EAGAIN::Errno   #=> 11
     Errno::EINTR::Errno    #=> 4

  The full list of operating system errors on your particular platform
  are available as the constants of Errno.

     Errno.constants   #=> :E2BIG, :EACCES, :EADDRINUSE, :EADDRNOTAVAIL, ...
Warning: |-
  The Warning module contains a single method named #warn, and the
  module extends itself, making Warning.warn available.
  Warning.warn is called for all warnings issued by Ruby.
  By default, warnings are printed to $stderr.

  By overriding Warning.warn, you can change how warnings are
  handled by Ruby, either filtering some warnings, and/or outputting
  warnings somewhere other than $stderr.  When Warning.warn is
  overridden, super can be called to get the default behavior of
  printing the warning to $stderr.
Module: |-
  A Module is a collection of methods and constants. The
  methods in a module may be instance methods or module methods.
  Instance methods appear as methods in a class when the module is
  included, module methods do not. Conversely, module methods may be
  called without creating an encapsulating object, while instance
  methods may not. (See Module#module_function.)

  In the descriptions that follow, the parameter <i>sym</i> refers
  to a symbol, which is either a quoted string or a
  Symbol (such as <code>:name</code>).

     module Mod
       include Math
       CONST = 1
       def meth
         #  ...
       end
     end
     Mod.class              #=> Module
     Mod.constants          #=> [:CONST, :PI, :E]
     Mod.instance_methods   #=> [:meth]
IO: |-
  The IO class is the basis for all input and output in Ruby.
  An I/O stream may be <em>duplexed</em> (that is, bidirectional), and
  so may use more than one native operating system stream.

  Many of the examples in this section use the File class, the only standard
  subclass of IO. The two classes are closely associated.  Like the File
  class, the Socket library subclasses from IO (such as TCPSocket or
  UDPSocket).

  The Kernel#open method can create an IO (or File) object for these types
  of arguments:

  * A plain string represents a filename suitable for the underlying
    operating system.

  * A string starting with <code>"|"</code> indicates a subprocess.
    The remainder of the string following the <code>"|"</code> is
    invoked as a process with appropriate input/output channels
    connected to it.

  * A string equal to <code>"|-"</code> will create another Ruby
    instance as a subprocess.

  The IO may be opened with different file modes (read-only, write-only) and
  encodings for proper conversion.  See IO.new for these options.  See
  Kernel#open for details of the various command formats described above.

  IO.popen, the Open3 library, or  Process#spawn may also be used to
  communicate with subprocesses through an IO.

  Ruby will convert pathnames between different operating system
  conventions if possible.  For instance, on a Windows system the
  filename <code>"/gumby/ruby/test.rb"</code> will be opened as
  <code>"\gumby\ruby\test.rb"</code>.  When specifying a Windows-style
  filename in a Ruby string, remember to escape the backslashes:

    "C:\\gumby\\ruby\\test.rb"

  Our examples here will use the Unix-style forward slashes;
  File::ALT_SEPARATOR can be used to get the platform-specific separator
  character.

  The global constant ARGF (also accessible as <code>$<</code>) provides an
  IO-like stream which allows access to all files mentioned on the
  command line (or STDIN if no files are mentioned). ARGF#path and its alias
  ARGF#filename are provided to access the name of the file currently being
  read.

  == io/console

  The io/console extension provides methods for interacting with the
  console.  The console can be accessed from IO.console or the standard
  input/output/error IO objects.

  Requiring io/console adds the following methods:

  * IO::console
  * IO#raw
  * IO#raw!
  * IO#cooked
  * IO#cooked!
  * IO#getch
  * IO#echo=
  * IO#echo?
  * IO#noecho
  * IO#winsize
  * IO#winsize=
  * IO#iflush
  * IO#ioflush
  * IO#oflush

  Example:

    require 'io/console'
    rows, columns = $stdout.winsize
    puts "Your screen is #{columns} wide and #{rows} tall"
IO::EAGAINWaitReadable: 'exception to wait for reading by EAGAIN. see IO.select.   '
IO::EAGAINWaitWritable: 'exception to wait for writing by EAGAIN. see IO.select.   '
IO::EWOULDBLOCKWaitReadable: 'exception to wait for reading by EWOULDBLOCK. see IO.select.   '
IO::EWOULDBLOCKWaitWritable: 'exception to wait for writing by EWOULDBLOCK. see IO.select.   '
IO::EINPROGRESSWaitReadable: 'exception to wait for reading by EINPROGRESS. see IO.select.   '
IO::EINPROGRESSWaitWritable: 'exception to wait for writing by EINPROGRESS. see IO.select.   '
IO::WaitReadable: 'exception to wait for reading. see IO.select.   '
IO::WaitWritable: 'exception to wait for writing. see IO.select.   '
FileTest: |-
  FileTest implements file test operations similar to those used in
  File::Stat. It exists as a standalone module, and its methods are
  also insinuated into the File class. (Note that this is not done
  by inclusion: the interpreter cheats).
BasicObject: |-
  BasicObject is the parent class of all classes in Ruby.  It's an explicit
  blank class.

  BasicObject can be used for creating object hierarchies independent of
  Ruby's object hierarchy, proxy objects like the Delegator class, or other
  uses where namespace pollution from Ruby's methods and classes must be
  avoided.

  To avoid polluting BasicObject for other users an appropriately named
  subclass of BasicObject should be created instead of directly modifying
  BasicObject:

    class MyObjectSystem < BasicObject
    end

  BasicObject does not include Kernel (for methods like +puts+) and
  BasicObject is outside of the namespace of the standard library so common
  classes will not be found without using a full class path.

  A variety of strategies can be used to provide useful portions of the
  standard library to subclasses of BasicObject.  A subclass could
  <code>include Kernel</code> to obtain +puts+, +exit+, etc.  A custom
  Kernel-like module could be created and included or delegation can be used
  via #method_missing:

    class MyObjectSystem < BasicObject
      DELEGATE = [:puts, :p]

      def method_missing(name, *args, &block)
        return super unless DELEGATE.include? name
        ::Kernel.send(name, *args, &block)
      end

      def respond_to_missing?(name, include_private = false)
        DELEGATE.include?(name) or super
      end
    end

  Access to classes and modules from the Ruby standard library can be
  obtained in a BasicObject subclass by referencing the desired constant
  from the root like <code>::File</code> or <code>::Enumerator</code>.
  Like #method_missing, #const_missing can be used to delegate constant
  lookup to +Object+:

    class MyObjectSystem < BasicObject
      def self.const_missing(name)
        ::Object.const_get(name)
      end
    end
GC: |-
  The GC module provides an interface to Ruby's mark and
  sweep garbage collection mechanism.

  Some of the underlying methods are also available via the ObjectSpace
  module.

  You may obtain information about the operation of the GC through
  GC::Profiler.
GC::Profiler: |-
  The GC profiler provides access to information on GC runs including time,
  length and object space size.

  Example:

    GC::Profiler.enable

    require 'rdoc/rdoc'

    GC::Profiler.report

    GC::Profiler.disable

  See also GC.count, GC.malloc_allocated_size and GC.malloc_allocations
ObjectSpace: |-
  The ObjectSpace module contains a number of routines
  that interact with the garbage collection facility and allow you to
  traverse all living objects with an iterator.

  ObjectSpace also provides support for object finalizers, procs that will be
  called when a specific object is about to be destroyed by garbage
  collection.

     require 'objspace'

     a = "A"
     b = "B"

     ObjectSpace.define_finalizer(a, proc {|id| puts "Finalizer one on #{id}" })
     ObjectSpace.define_finalizer(b, proc {|id| puts "Finalizer two on #{id}" })

  _produces:_

     Finalizer two on 537763470
     Finalizer one on 537763480
ObjectSpace::WeakMap: |-
  An ObjectSpace::WeakMap object holds references to
  any objects, but those objects can get garbage collected.

  This class is mostly used internally by WeakRef, please use
  +lib/weakref.rb+ for the public interface.
FalseClass: |-
  The global value <code>false</code> is the only instance of class
  FalseClass and represents a logically false value in
  boolean expressions. The class provides operators allowing
  <code>false</code> to participate correctly in logical expressions.
Symbol: |-
  Symbol objects represent names inside the Ruby interpreter. They
  are generated using the <code>:name</code> and
  <code>:"string"</code> literals syntax, and by the various
  <code>to_sym</code> methods. The same Symbol object will be
  created for a given name or string for the duration of a program's
  execution, regardless of the context or meaning of that name. Thus
  if <code>Fred</code> is a constant in one context, a method in
  another, and a class in a third, the Symbol <code>:Fred</code>
  will be the same object in all three contexts.

     module One
       class Fred
       end
       $f1 = :Fred
     end
     module Two
       Fred = 1
       $f2 = :Fred
     end
     def Fred()
     end
     $f3 = :Fred
     $f1.object_id   #=> 2514190
     $f2.object_id   #=> 2514190
     $f3.object_id   #=> 2514190
Hash: |-
  A Hash is a dictionary-like collection of unique keys and their values.
  Also called associative arrays, they are similar to Arrays, but where an
  Array uses integers as its index, a Hash allows you to use any object
  type.

  Hashes enumerate their values in the order that the corresponding keys
  were inserted.

  A Hash can be easily created by using its implicit form:

    grades = { "Jane Doe" => 10, "Jim Doe" => 6 }

  Hashes allow an alternate syntax for keys that are symbols.
  Instead of

    options = { :font_size => 10, :font_family => "Arial" }

  You could write it as:

    options = { font_size: 10, font_family: "Arial" }

  Each named key is a symbol you can access in hash:

    options[:font_size]  # => 10

  A Hash can also be created through its ::new method:

    grades = Hash.new
    grades["Dorothy Doe"] = 9

  Hashes have a <em>default value</em> that is returned when accessing
  keys that do not exist in the hash. If no default is set +nil+ is used.
  You can set the default value by sending it as an argument to Hash.new:

    grades = Hash.new(0)

  Or by using the #default= method:

    grades = {"Timmy Doe" => 8}
    grades.default = 0

  Accessing a value in a Hash requires using its key:

    puts grades["Jane Doe"] # => 0

  === Common Uses

  Hashes are an easy way to represent data structures, such as

    books         = {}
    books[:matz]  = "The Ruby Programming Language"
    books[:black] = "The Well-Grounded Rubyist"

  Hashes are also commonly used as a way to have named parameters in
  functions. Note that no brackets are used below. If a hash is the last
  argument on a method call, no braces are needed, thus creating a really
  clean interface:

    Person.create(name: "John Doe", age: 27)

    def self.create(params)
      @name = params[:name]
      @age  = params[:age]
    end

  === Hash Keys

  Two objects refer to the same hash key when their <code>hash</code> value
  is identical and the two objects are <code>eql?</code> to each other.

  A user-defined class may be used as a hash key if the <code>hash</code>
  and <code>eql?</code> methods are overridden to provide meaningful
  behavior.  By default, separate instances refer to separate hash keys.

  A typical implementation of <code>hash</code> is based on the
  object's data while <code>eql?</code> is usually aliased to the overridden
  <code>==</code> method:

    class Book
      attr_reader :author, :title

      def initialize(author, title)
        @author = author
        @title = title
      end

      def ==(other)
        self.class === other and
          other.author == @author and
          other.title == @title
      end

      alias eql? ==

      def hash
        @author.hash ^ @title.hash # XOR
      end
    end

    book1 = Book.new 'matz', 'Ruby in a Nutshell'
    book2 = Book.new 'matz', 'Ruby in a Nutshell'

    reviews = {}

    reviews[book1] = 'Great reference!'
    reviews[book2] = 'Nice and compact!'

    reviews.length #=> 1

  See also Object#hash and Object#eql?
ENV: |-
  ENV is a hash-like accessor for environment variables.

  === Interaction with the Operating System

  The ENV object interacts with the operating system's environment variables:

  - When you get the value for a name in ENV, the value is retrieved from among the current environment variables.
  - When you create or set a name-value pair in ENV, the name and value are immediately set in the environment variables.
  - When you delete a name-value pair in ENV, it is immediately deleted from the environment variables.

  === Names and Values

  Generally, a name or value is a String.

  ==== Valid Names and Values

  Each name or value must be one of the following:

  - A String.
  - An object that responds to \#to_str by returning a String, in which case that String will be used as the name or value.

  ==== Invalid Names and Values

  A new name:

  - May not be the empty string:
      ENV[''] = '0'
      # Raises Errno::EINVAL (Invalid argument - ruby_setenv())

  - May not contain character <code>"="</code>:
      ENV['='] = '0'
      # Raises Errno::EINVAL (Invalid argument - ruby_setenv(=))

  A new name or value:

  - May not be a non-String that does not respond to \#to_str:

      ENV['foo'] = Object.new
      # Raises TypeError (no implicit conversion of Object into String)
      ENV[Object.new] = '0'
      # Raises TypeError (no implicit conversion of Object into String)

  - May not contain the NUL character <code>"\0"</code>:

      ENV['foo'] = "\0"
      # Raises ArgumentError (bad environment variable value: contains null byte)
      ENV["\0"] == '0'
      # Raises ArgumentError (bad environment variable name: contains null byte)

  - May not have an ASCII-incompatible encoding such as UTF-16LE or ISO-2022-JP:

      ENV['foo'] = '0'.force_encoding(Encoding::ISO_2022_JP)
      # Raises ArgumentError (bad environment variable name: ASCII incompatible encoding: ISO-2022-JP)
      ENV["foo".force_encoding(Encoding::ISO_2022_JP)] = '0'
      # Raises ArgumentError (bad environment variable name: ASCII incompatible encoding: ISO-2022-JP)

  === About Ordering

  ENV enumerates its name/value pairs in the order found
  in the operating system's environment variables.
  Therefore the ordering of ENV content is OS-dependent, and may be indeterminate.

  This will be seen in:
  - A Hash returned by an ENV method.
  - An Enumerator returned by an ENV method.
  - An Array returned by ENV.keys, ENV.values, or ENV.to_a.
  - The String returned by ENV.inspect.
  - The Array returned by ENV.shift.
  - The name returned by ENV.key.

  === About the Examples
  Some methods in ENV return ENV itself. Typically, there are many environment variables.
  It's not useful to display a large ENV in the examples here,
  so most example snippets begin by resetting the contents of ENV:
  - ENV.replace replaces ENV with a new collection of entries.
  - ENV.clear empties ENV.
IOError: |-
  Raised when an IO operation fails.

     File.open("/etc/hosts") {|f| f << "example"}
       #=> IOError: not opened for writing

     File.open("/etc/hosts") {|f| f.close; f.read }
       #=> IOError: closed stream

  Note that some IO failures raise <code>SystemCallError</code>s
  and these are not subclasses of IOError:

     File.open("does/not/exist")
       #=> Errno::ENOENT: No such file or directory - does/not/exist
EOFError: |-
  Raised by some IO operations when reaching the end of file. Many IO
  methods exist in two forms,

  one that returns +nil+ when the end of file is reached, the other
  raises +EOFError+.

  +EOFError+ is a subclass of +IOError+.

     file = File.open("/etc/hosts")
     file.read
     file.gets     #=> nil
     file.readline #=> EOFError: end of file reached
ARGF: |-
  +ARGF+ is a stream designed for use in scripts that process files given as
  command-line arguments or passed in via STDIN.

  The arguments passed to your script are stored in the +ARGV+ Array, one
  argument per element. +ARGF+ assumes that any arguments that aren't
  filenames have been removed from +ARGV+. For example:

      $ ruby argf.rb --verbose file1 file2

      ARGV  #=> ["--verbose", "file1", "file2"]
      option = ARGV.shift #=> "--verbose"
      ARGV  #=> ["file1", "file2"]

  You can now use +ARGF+ to work with a concatenation of each of these named
  files. For instance, +ARGF.read+ will return the contents of _file1_
  followed by the contents of _file2_.

  After a file in +ARGV+ has been read +ARGF+ removes it from the Array.
  Thus, after all files have been read +ARGV+ will be empty.

  You can manipulate +ARGV+ yourself to control what +ARGF+ operates on. If
  you remove a file from +ARGV+, it is ignored by +ARGF+; if you add files to
  +ARGV+, they are treated as if they were named on the command line. For
  example:

      ARGV.replace ["file1"]
      ARGF.readlines # Returns the contents of file1 as an Array
      ARGV           #=> []
      ARGV.replace ["file2", "file3"]
      ARGF.read      # Returns the contents of file2 and file3

  If +ARGV+ is empty, +ARGF+ acts as if it contained STDIN, i.e. the data
  piped to your script. For example:

      $ echo "glark" | ruby -e 'p ARGF.read'
      "glark\n"
Marshal: |-
  The marshaling library converts collections of Ruby objects into a
  byte stream, allowing them to be stored outside the currently
  active script. This data may subsequently be read and the original
  objects reconstituted.

  Marshaled data has major and minor version numbers stored along
  with the object information. In normal use, marshaling can only
  load data written with the same major version number and an equal
  or lower minor version number. If Ruby's ``verbose'' flag is set
  (normally using -d, -v, -w, or --verbose) the major and minor
  numbers must match exactly. Marshal versioning is independent of
  Ruby's version numbers. You can extract the version by reading the
  first two bytes of marshaled data.

      str = Marshal.dump("thing")
      RUBY_VERSION   #=> "1.9.0"
      str[0].ord     #=> 4
      str[1].ord     #=> 8

  Some objects cannot be dumped: if the objects to be dumped include
  bindings, procedure or method objects, instances of class IO, or
  singleton objects, a TypeError will be raised.

  If your class has special serialization needs (for example, if you
  want to serialize in some specific format), or if it contains
  objects that would otherwise not be serializable, you can implement
  your own serialization strategy.

  There are two methods of doing this, your object can define either
  marshal_dump and marshal_load or _dump and _load.  marshal_dump will take
  precedence over _dump if both are defined.  marshal_dump may result in
  smaller Marshal strings.

  == Security considerations

  By design, Marshal.load can deserialize almost any class loaded into the
  Ruby process. In many cases this can lead to remote code execution if the
  Marshal data is loaded from an untrusted source.

  As a result, Marshal.load is not suitable as a general purpose serialization
  format and you should never unmarshal user supplied input or other untrusted
  data.

  If you need to deserialize untrusted data, use JSON or another serialization
  format that is only able to load simple, 'primitive' types such as String,
  Array, Hash, etc. Never allow user input to specify arbitrary types to
  deserialize into.

  == marshal_dump and marshal_load

  When dumping an object the method marshal_dump will be called.
  marshal_dump must return a result containing the information necessary for
  marshal_load to reconstitute the object.  The result can be any object.

  When loading an object dumped using marshal_dump the object is first
  allocated then marshal_load is called with the result from marshal_dump.
  marshal_load must recreate the object from the information in the result.

  Example:

    class MyObj
      def initialize name, version, data
        @name    = name
        @version = version
        @data    = data
      end

      def marshal_dump
        [@name, @version]
      end

      def marshal_load array
        @name, @version = array
      end
    end

  == _dump and _load

  Use _dump and _load when you need to allocate the object you're restoring
  yourself.

  When dumping an object the instance method _dump is called with an Integer
  which indicates the maximum depth of objects to dump (a value of -1 implies
  that you should disable depth checking).  _dump must return a String
  containing the information necessary to reconstitute the object.

  The class method _load should take a String and use it to return an object
  of the same class.

  Example:

    class MyObj
      def initialize name, version, data
        @name    = name
        @version = version
        @data    = data
      end

      def _dump level
        [@name, @version].join ':'
      end

      def self._load args
        new(*args.split(':'))
      end
    end

  Since Marshal.dump outputs a string you can have _dump return a Marshal
  string which is Marshal.loaded in _load for complex objects.
Math: |-
  The Math module contains module functions for basic
  trigonometric and transcendental functions. See class
  Float for a list of constants that
  define Ruby's floating point accuracy.

  Domains and codomains are given only for real (not complex) numbers.
Math::DomainError: |-
  Raised when a mathematical function is evaluated outside of its
  domain of definition.

  For example, since +cos+ returns values in the range -1..1,
  its inverse function +acos+ is only defined on that interval:

     Math.acos(42)

  <em>produces:</em>

     Math::DomainError: Numerical argument is out of domain - "acos"
ZeroDivisionError: |-
  Raised when attempting to divide an integer by 0.

     42 / 0   #=> ZeroDivisionError: divided by 0

  Note that only division by an exact 0 will raise the exception:

     42 /  0.0   #=> Float::INFINITY
     42 / -0.0   #=> -Float::INFINITY
     0  /  0.0   #=> NaN
FloatDomainError: |-
  Raised when attempting to convert special float values (in particular
  +Infinity+ or +NaN+) to numerical classes which don't support them.

     Float::INFINITY.to_r   #=> FloatDomainError: Infinity
Class: |-
  Classes in Ruby are first-class objects---each is an instance of
  class Class.

  Typically, you create a new class by using:

    class Name
     # some code describing the class behavior
    end

  When a new class is created, an object of type Class is initialized and
  assigned to a global constant (Name in this case).

  When <code>Name.new</code> is called to create a new object, the
  #new method in Class is run by default.
  This can be demonstrated by overriding #new in Class:

     class Class
       alias old_new new
       def new(*args)
         print "Creating a new ", self.name, "\n"
         old_new(*args)
       end
     end

     class Name
     end

     n = Name.new

  <em>produces:</em>

     Creating a new Name

  Classes, modules, and objects are interrelated. In the diagram
  that follows, the vertical arrows represent inheritance, and the
  parentheses metaclasses. All metaclasses are instances
  of the class `Class'.
                             +---------+             +-...
                             |         |             |
             BasicObject-----|-->(BasicObject)-------|-...
                 ^           |         ^             |
                 |           |         |             |
              Object---------|----->(Object)---------|-...
                 ^           |         ^             |
                 |           |         |             |
                 +-------+   |         +--------+    |
                 |       |   |         |        |    |
                 |    Module-|---------|--->(Module)-|-...
                 |       ^   |         |        ^    |
                 |       |   |         |        |    |
                 |     Class-|---------|---->(Class)-|-...
                 |       ^   |         |        ^    |
                 |       +---+         |        +----+
                 |                     |
    obj--->OtherClass---------->(OtherClass)-----------...
Data: |-
  This is a deprecated class, base class for C extensions using
  Data_Make_Struct or Data_Wrap_Struct.
TrueClass: |-
  The global value <code>true</code> is the only instance of class
  TrueClass and represents a logically true value in
  boolean expressions. The class provides operators allowing
  <code>true</code> to be used in logical expressions.
Binding: |-
  Objects of class Binding encapsulate the execution context at some
  particular place in the code and retain this context for future
  use. The variables, methods, value of <code>self</code>, and
  possibly an iterator block that can be accessed in this context
  are all retained. Binding objects can be created using
  Kernel#binding, and are made available to the callback of
  Kernel#set_trace_func and instances of TracePoint.

  These binding objects can be passed as the second argument of the
  Kernel#eval method, establishing an environment for the
  evaluation.

     class Demo
       def initialize(n)
         @secret = n
       end
       def get_binding
         binding
       end
     end

     k1 = Demo.new(99)
     b1 = k1.get_binding
     k2 = Demo.new(-3)
     b2 = k2.get_binding

     eval("@secret", b1)   #=> 99
     eval("@secret", b2)   #=> -3
     eval("@secret")       #=> nil

  Binding objects have no class-specific methods.
Thread: |-
  Threads are the Ruby implementation for a concurrent programming model.

  Programs that require multiple threads of execution are a perfect
  candidate for Ruby's Thread class.

  For example, we can create a new thread separate from the main thread's
  execution using ::new.

      thr = Thread.new { puts "What's the big deal" }

  Then we are able to pause the execution of the main thread and allow
  our new thread to finish, using #join:

      thr.join #=> "What's the big deal"

  If we don't call +thr.join+ before the main thread terminates, then all
  other threads including +thr+ will be killed.

  Alternatively, you can use an array for handling multiple threads at
  once, like in the following example:

      threads = []
      threads << Thread.new { puts "What's the big deal" }
      threads << Thread.new { 3.times { puts "Threads are fun!" } }

  After creating a few threads we wait for them all to finish
  consecutively.

      threads.each { |thr| thr.join }

  To retrieve the last value of a thread, use #value

      thr = Thread.new { sleep 1; "Useful value" }
      thr.value #=> "Useful value"

  === Thread initialization

  In order to create new threads, Ruby provides ::new, ::start, and
  ::fork. A block must be provided with each of these methods, otherwise
  a ThreadError will be raised.

  When subclassing the Thread class, the +initialize+ method of your
  subclass will be ignored by ::start and ::fork. Otherwise, be sure to
  call super in your +initialize+ method.

  === Thread termination

  For terminating threads, Ruby provides a variety of ways to do this.

  The class method ::kill, is meant to exit a given thread:

      thr = Thread.new { sleep }
      Thread.kill(thr) # sends exit() to thr

  Alternatively, you can use the instance method #exit, or any of its
  aliases #kill or #terminate.

      thr.exit

  === Thread status

  Ruby provides a few instance methods for querying the state of a given
  thread. To get a string with the current thread's state use #status

      thr = Thread.new { sleep }
      thr.status # => "sleep"
      thr.exit
      thr.status # => false

  You can also use #alive? to tell if the thread is running or sleeping,
  and #stop? if the thread is dead or sleeping.

  === Thread variables and scope

  Since threads are created with blocks, the same rules apply to other
  Ruby blocks for variable scope. Any local variables created within this
  block are accessible to only this thread.

  ==== Fiber-local vs. Thread-local

  Each fiber has its own bucket for Thread#[] storage. When you set a
  new fiber-local it is only accessible within this Fiber. To illustrate:

      Thread.new {
        Thread.current[:foo] = "bar"
        Fiber.new {
          p Thread.current[:foo] # => nil
        }.resume
      }.join

  This example uses #[] for getting and #[]= for setting fiber-locals,
  you can also use #keys to list the fiber-locals for a given
  thread and #key? to check if a fiber-local exists.

  When it comes to thread-locals, they are accessible within the entire
  scope of the thread. Given the following example:

      Thread.new{
        Thread.current.thread_variable_set(:foo, 1)
        p Thread.current.thread_variable_get(:foo) # => 1
        Fiber.new{
          Thread.current.thread_variable_set(:foo, 2)
          p Thread.current.thread_variable_get(:foo) # => 2
        }.resume
        p Thread.current.thread_variable_get(:foo)   # => 2
      }.join

  You can see that the thread-local +:foo+ carried over into the fiber
  and was changed to +2+ by the end of the thread.

  This example makes use of #thread_variable_set to create new
  thread-locals, and #thread_variable_get to reference them.

  There is also #thread_variables to list all thread-locals, and
  #thread_variable? to check if a given thread-local exists.

  === Exception handling

  When an unhandled exception is raised inside a thread, it will
  terminate. By default, this exception will not propagate to other
  threads. The exception is stored and when another thread calls #value
  or #join, the exception will be re-raised in that thread.

      t = Thread.new{ raise 'something went wrong' }
      t.value #=> RuntimeError: something went wrong

  An exception can be raised from outside the thread using the
  Thread#raise instance method, which takes the same parameters as
  Kernel#raise.

  Setting Thread.abort_on_exception = true, Thread#abort_on_exception =
  true, or $DEBUG = true will cause a subsequent unhandled exception
  raised in a thread to be automatically re-raised in the main thread.

  With the addition of the class method ::handle_interrupt, you can now
  handle exceptions asynchronously with threads.

  === Scheduling

  Ruby provides a few ways to support scheduling threads in your program.

  The first way is by using the class method ::stop, to put the current
  running thread to sleep and schedule the execution of another thread.

  Once a thread is asleep, you can use the instance method #wakeup to
  mark your thread as eligible for scheduling.

  You can also try ::pass, which attempts to pass execution to another
  thread but is dependent on the OS whether a running thread will switch
  or not. The same goes for #priority, which lets you hint to the thread
  scheduler which threads you want to take precedence when passing
  execution. This method is also dependent on the OS and may be ignored
  on some platforms.
Thread::Backtrace::Location: |-
  An object representation of a stack frame, initialized by
  Kernel#caller_locations.

  For example:

          # caller_locations.rb
          def a(skip)
            caller_locations(skip)
          end
          def b(skip)
            a(skip)
          end
          def c(skip)
            b(skip)
          end

          c(0..2).map do |call|
            puts call.to_s
          end

  Running <code>ruby caller_locations.rb</code> will produce:

          caller_locations.rb:2:in `a'
          caller_locations.rb:5:in `b'
          caller_locations.rb:8:in `c'

  Here's another example with a slightly different result:

          # foo.rb
          class Foo
            attr_accessor :locations
            def initialize(skip)
              @locations = caller_locations(skip)
            end
          end

          Foo.new(0..2).locations.map do |call|
            puts call.to_s
          end

  Now run <code>ruby foo.rb</code> and you should see:

          init.rb:4:in `initialize'
          init.rb:8:in `new'
          init.rb:8:in `<main>'
Proc: |-
  A +Proc+ object is an encapsulation of a block of code, which can be stored
  in a local variable, passed to a method or another Proc, and can be called.
  Proc is an essential concept in Ruby and a core of its functional
  programming features.

       square = Proc.new {|x| x**2 }

       square.call(3)  #=> 9
       # shorthands:
       square.(3)      #=> 9
       square[3]       #=> 9

  Proc objects are _closures_, meaning they remember and can use the entire
  context in which they were created.

      def gen_times(factor)
        Proc.new {|n| n*factor } # remembers the value of factor at the moment of creation
      end

      times3 = gen_times(3)
      times5 = gen_times(5)

      times3.call(12)               #=> 36
      times5.call(5)                #=> 25
      times3.call(times5.call(4))   #=> 60

  == Creation

  There are several methods to create a Proc

  * Use the Proc class constructor:

       proc1 = Proc.new {|x| x**2 }

  * Use the Kernel#proc method as a shorthand of Proc.new:

       proc2 = proc {|x| x**2 }

  * Receiving a block of code into proc argument (note the <code>&</code>):

       def make_proc(&block)
         block
       end

       proc3 = make_proc {|x| x**2 }

  * Construct a proc with lambda semantics using the Kernel#lambda method
    (see below for explanations about lambdas):

       lambda1 = lambda {|x| x**2 }

  * Use the Lambda literal syntax (also constructs a proc with lambda semantics):

       lambda2 = ->(x) { x**2 }

  == Lambda and non-lambda semantics

  Procs are coming in two flavors: lambda and non-lambda (regular procs).
  Differences are:

  * In lambdas, +return+ and +break+ means exit from this lambda;
  * In non-lambda procs, +return+ means exit from embracing method
    (and will throw +LocalJumpError+ if invoked outside the method);
  * In non-lambda procs, +break+ means exit from the method which the block given for.
    (and will throw +LocalJumpError+ if invoked after the method returns);
  * In lambdas, arguments are treated in the same way as in methods: strict,
    with +ArgumentError+ for mismatching argument number,
    and no additional argument processing;
  * Regular procs accept arguments more generously: missing arguments
    are filled with +nil+, single Array arguments are deconstructed if the
    proc has multiple arguments, and there is no error raised on extra
    arguments.

  Examples:

       # +return+ in non-lambda proc, +b+, exits +m2+.
       # (The block +{ return }+ is given for +m1+ and embraced by +m2+.)
       $a = []; def m1(&b) b.call; $a << :m1 end; def m2() m1 { return }; $a << :m2 end; m2; p $a
       #=> []

       # +break+ in non-lambda proc, +b+, exits +m1+.
       # (The block +{ break }+ is given for +m1+ and embraced by +m2+.)
       $a = []; def m1(&b) b.call; $a << :m1 end; def m2() m1 { break }; $a << :m2 end; m2; p $a
       #=> [:m2]

       # +next+ in non-lambda proc, +b+, exits the block.
       # (The block +{ next }+ is given for +m1+ and embraced by +m2+.)
       $a = []; def m1(&b) b.call; $a << :m1 end; def m2() m1 { next }; $a << :m2 end; m2; p $a
       #=> [:m1, :m2]

       # Using +proc+ method changes the behavior as follows because
       # The block is given for +proc+ method and embraced by +m2+.
       $a = []; def m1(&b) b.call; $a << :m1 end; def m2() m1(&proc { return }); $a << :m2 end; m2; p $a
       #=> []
       $a = []; def m1(&b) b.call; $a << :m1 end; def m2() m1(&proc { break }); $a << :m2 end; m2; p $a
       # break from proc-closure (LocalJumpError)
       $a = []; def m1(&b) b.call; $a << :m1 end; def m2() m1(&proc { next }); $a << :m2 end; m2; p $a
       #=> [:m1, :m2]

       # +return+, +break+ and +next+ in the stubby lambda exits the block.
       # (+lambda+ method behaves same.)
       # (The block is given for stubby lambda syntax and embraced by +m2+.)
       $a = []; def m1(&b) b.call; $a << :m1 end; def m2() m1(&-> { return }); $a << :m2 end; m2; p $a
       #=> [:m1, :m2]
       $a = []; def m1(&b) b.call; $a << :m1 end; def m2() m1(&-> { break }); $a << :m2 end; m2; p $a
       #=> [:m1, :m2]
       $a = []; def m1(&b) b.call; $a << :m1 end; def m2() m1(&-> { next }); $a << :m2 end; m2; p $a
       #=> [:m1, :m2]

       p = proc {|x, y| "x=#{x}, y=#{y}" }
       p.call(1, 2)      #=> "x=1, y=2"
       p.call([1, 2])    #=> "x=1, y=2", array deconstructed
       p.call(1, 2, 8)   #=> "x=1, y=2", extra argument discarded
       p.call(1)         #=> "x=1, y=", nil substituted instead of error

       l = lambda {|x, y| "x=#{x}, y=#{y}" }
       l.call(1, 2)      #=> "x=1, y=2"
       l.call([1, 2])    # ArgumentError: wrong number of arguments (given 1, expected 2)
       l.call(1, 2, 8)   # ArgumentError: wrong number of arguments (given 3, expected 2)
       l.call(1)         # ArgumentError: wrong number of arguments (given 1, expected 2)

       def test_return
         -> { return 3 }.call      # just returns from lambda into method body
         proc { return 4 }.call    # returns from method
         return 5
       end

       test_return # => 4, return from proc

  Lambdas are useful as self-sufficient functions, in particular useful as
  arguments to higher-order functions, behaving exactly like Ruby methods.

  Procs are useful for implementing iterators:

       def test
         [[1, 2], [3, 4], [5, 6]].map {|a, b| return a if a + b > 10 }
                                   #  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
       end

  Inside +map+, the block of code is treated as a regular (non-lambda) proc,
  which means that the internal arrays will be deconstructed to pairs of
  arguments, and +return+ will exit from the method +test+. That would
  not be possible with a stricter lambda.

  You can tell a lambda from a regular proc by using the #lambda? instance method.

  Lambda semantics is typically preserved during the proc lifetime, including
  <code>&</code>-deconstruction to a block of code:

       p = proc {|x, y| x }
       l = lambda {|x, y| x }
       [[1, 2], [3, 4]].map(&p) #=> [1, 2]
       [[1, 2], [3, 4]].map(&l) # ArgumentError: wrong number of arguments (given 1, expected 2)

  The only exception is dynamic method definition: even if defined by
  passing a non-lambda proc, methods still have normal semantics of argument
  checking.

    class C
      define_method(:e, &proc {})
    end
    C.new.e(1,2)       #=> ArgumentError
    C.new.method(:e).to_proc.lambda?   #=> true

  This exception ensures that methods never have unusual argument passing
  conventions, and makes it easy to have wrappers defining methods that
  behave as usual.

    class C
      def self.def2(name, &body)
        define_method(name, &body)
      end

      def2(:f) {}
    end
    C.new.f(1,2)       #=> ArgumentError

  The wrapper <code>def2</code> receives _body_ as a non-lambda proc,
  yet defines a method which has normal semantics.

  == Conversion of other objects to procs

  Any object that implements the +to_proc+ method can be converted into
  a proc by the <code>&</code> operator, and therefore con be
  consumed by iterators.

       class Greeter
         def initialize(greeting)
           @greeting = greeting
         end

         def to_proc
           proc {|name| "#{@greeting}, #{name}!" }
         end
       end

       hi = Greeter.new("Hi")
       hey = Greeter.new("Hey")
       ["Bob", "Jane"].map(&hi)    #=> ["Hi, Bob!", "Hi, Jane!"]
       ["Bob", "Jane"].map(&hey)   #=> ["Hey, Bob!", "Hey, Jane!"]

  Of the Ruby core classes, this method is implemented by Symbol,
  Method, and Hash.

       :to_s.to_proc.call(1)           #=> "1"
       [1, 2].map(&:to_s)              #=> ["1", "2"]

       method(:puts).to_proc.call(1)   # prints 1
       [1, 2].each(&method(:puts))     # prints 1, 2

       {test: 1}.to_proc.call(:test)       #=> 1
       %i[test many keys].map(&{test: 1})  #=> [1, nil, nil]

  == Orphaned Proc

  +return+ and +break+ in a block exit a method.
  If a Proc object is generated from the block and the Proc object
  survives until the method is returned, +return+ and +break+ cannot work.
  In such case, +return+ and +break+ raises LocalJumpError.
  A Proc object in such situation is called as orphaned Proc object.

  Note that the method to exit is different for +return+ and +break+.
  There is a situation that orphaned for +break+ but not orphaned for +return+.

      def m1(&b) b.call end; def m2(); m1 { return } end; m2 # ok
      def m1(&b) b.call end; def m2(); m1 { break } end; m2 # ok

      def m1(&b) b end; def m2(); m1 { return }.call end; m2 # ok
      def m1(&b) b end; def m2(); m1 { break }.call end; m2 # LocalJumpError

      def m1(&b) b end; def m2(); m1 { return } end; m2.call # LocalJumpError
      def m1(&b) b end; def m2(); m1 { break } end; m2.call # LocalJumpError

  Since +return+ and +break+ exits the block itself in lambdas,
  lambdas cannot be orphaned.

  == Numbered parameters

  Numbered parameters are implicitly defined block parameters intended to
  simplify writing short blocks:

      # Explicit parameter:
      %w[test me please].each { |str| puts str.upcase } # prints TEST, ME, PLEASE
      (1..5).map { |i| i**2 } # => [1, 4, 9, 16, 25]

      # Implicit parameter:
      %w[test me please].each { puts _1.upcase } # prints TEST, ME, PLEASE
      (1..5).map { _1**2 } # => [1, 4, 9, 16, 25]

  Parameter names from +_1+ to +_9+ are supported:

      [10, 20, 30].zip([40, 50, 60], [70, 80, 90]).map { _1 + _2 + _3 }
      # => [120, 150, 180]

  Though, it is advised to resort to them wisely, probably limiting
  yourself to +_1+ and +_2+, and to one-line blocks.

  Numbered parameters can't be used together with explicitly named
  ones:

      [10, 20, 30].map { |x| _1**2 }
      # SyntaxError (ordinary parameter is defined)

  To avoid conflicts, naming local variables or method
  arguments +_1+, +_2+ and so on, causes a warning.

      _1 = 'test'
      # warning: `_1' is reserved as numbered parameter

  Using implicit numbered parameters affects block's arity:

      p = proc { _1 + _2 }
      l = lambda { _1 + _2 }
      p.parameters     # => [[:opt, :_1], [:opt, :_2]]
      p.arity          # => 2
      l.parameters     # => [[:req, :_1], [:req, :_2]]
      l.arity          # => 2

  Blocks with numbered parameters can't be nested:

      %w[test me].each { _1.each_char { p _1 } }
      # SyntaxError (numbered parameter is already used in outer block here)
      # %w[test me].each { _1.each_char { p _1 } }
      #                    ^~

  Numbered parameters were introduced in Ruby 2.7.
LocalJumpError: |-
  Raised when Ruby can't yield as requested.

  A typical scenario is attempting to yield when no block is given:

     def call_block
       yield 42
     end
     call_block

  <em>raises the exception:</em>

     LocalJumpError: no block given (yield)

  A more subtle example:

     def get_me_a_return
       Proc.new { return 42 }
     end
     get_me_a_return.call

  <em>raises the exception:</em>

     LocalJumpError: unexpected return
SystemStackError: |-
  Raised in case of a stack overflow.

     def me_myself_and_i
       me_myself_and_i
     end
     me_myself_and_i

  <em>raises the exception:</em>

    SystemStackError: stack level too deep
Method: |-
  Method objects are created by Object#method, and are associated
  with a particular object (not just with a class).  They may be
  used to invoke the method within the object, and as a block
  associated with an iterator.  They may also be unbound from one
  object (creating an UnboundMethod) and bound to another.

     class Thing
       def square(n)
         n*n
       end
     end
     thing = Thing.new
     meth  = thing.method(:square)

     meth.call(9)                 #=> 81
     [ 1, 2, 3 ].collect(&meth)   #=> [1, 4, 9]

     [ 1, 2, 3 ].each(&method(:puts)) #=> prints 1, 2, 3

     require 'date'
     %w[2017-03-01 2017-03-02].collect(&Date.method(:parse))
     #=> [#<Date: 2017-03-01 ((2457814j,0s,0n),+0s,2299161j)>, #<Date: 2017-03-02 ((2457815j,0s,0n),+0s,2299161j)>]
UnboundMethod: |-
  Ruby supports two forms of objectified methods. Class Method is
  used to represent methods that are associated with a particular
  object: these method objects are bound to that object. Bound
  method objects for an object can be created using Object#method.

  Ruby also supports unbound methods; methods objects that are not
  associated with a particular object. These can be created either
  by calling Module#instance_method or by calling #unbind on a bound
  method object. The result of both of these is an UnboundMethod
  object.

  Unbound methods can only be called after they are bound to an
  object. That object must be a kind_of? the method's original
  class.

     class Square
       def area
         @side * @side
       end
       def initialize(side)
         @side = side
       end
     end

     area_un = Square.instance_method(:area)

     s = Square.new(12)
     area = area_un.bind(s)
     area.call   #=> 144

  Unbound methods are a reference to the method at the time it was
  objectified: subsequent changes to the underlying class will not
  affect the unbound method.

     class Test
       def test
         :original
       end
     end
     um = Test.instance_method(:test)
     class Test
       def test
         :modified
       end
     end
     t = Test.new
     t.test            #=> :modified
     um.bind(t).call   #=> :original
Struct: |-
  A Struct is a convenient way to bundle a number of attributes together,
  using accessor methods, without having to write an explicit class.

  The Struct class generates new subclasses that hold a set of members and
  their values.  For each member a reader and writer method is created
  similar to Module#attr_accessor.

     Customer = Struct.new(:name, :address) do
       def greeting
         "Hello #{name}!"
       end
     end

     dave = Customer.new("Dave", "123 Main")
     dave.name     #=> "Dave"
     dave.greeting #=> "Hello Dave!"

  See Struct::new for further examples of creating struct subclasses and
  instances.

  In the method descriptions that follow, a "member" parameter refers to a
  struct member which is either a quoted string (<code>"name"</code>) or a
  Symbol (<code>:name</code>).
Process: |-
  The module contains several groups of functionality for handling OS processes:

  * Low-level property introspection and management of the current process, like
    Process.argv0, Process.pid;
  * Low-level introspection of other processes, like Process.getpgid, Process.getpriority;
  * Management of the current process: Process.abort, Process.exit, Process.daemon, etc.
    (for convenience, most of those are also available as global functions
    and module functions of Kernel);
  * Creation and management of child processes: Process.fork, Process.spawn, and
    related methods;
  * Management of low-level system clock: Process.times and Process.clock_gettime,
    which could be important for proper benchmarking and other elapsed
    time measurement tasks.
Process::Status: |-
  Process::Status encapsulates the information on the
  status of a running or terminated system process. The built-in
  variable <code>$?</code> is either +nil+ or a
  Process::Status object.

     fork { exit 99 }   #=> 26557
     Process.wait       #=> 26557
     $?.class           #=> Process::Status
     $?.to_i            #=> 25344
     $? >> 8            #=> 99
     $?.stopped?        #=> false
     $?.exited?         #=> true
     $?.exitstatus      #=> 99

  Posix systems record information on processes using a 16-bit
  integer.  The lower bits record the process status (stopped,
  exited, signaled) and the upper bits possibly contain additional
  information (for example the program's return code in the case of
  exited processes). Pre Ruby 1.8, these bits were exposed directly
  to the Ruby program. Ruby now encapsulates these in a
  Process::Status object. To maximize compatibility,
  however, these objects retain a bit-oriented interface. In the
  descriptions that follow, when we talk about the integer value of
  _stat_, we're referring to this 16 bit value.
Process::UID: |-
  The Process::UID module contains a collection of
  module functions which can be used to portably get, set, and
  switch the current process's real, effective, and saved user IDs.
Process::GID: |-
  The Process::GID module contains a collection of
  module functions which can be used to portably get, set, and
  switch the current process's real, effective, and saved group IDs.
Process::Sys: |-
  The Process::Sys module contains UID and GID
  functions which provide direct bindings to the system calls of the
  same names instead of the more-portable versions of the same
  functionality found in the Process,
  Process::UID, and Process::GID modules.
Random: |-
  Random provides an interface to Ruby's pseudo-random number generator, or
  PRNG.  The PRNG produces a deterministic sequence of bits which approximate
  true randomness. The sequence may be represented by integers, floats, or
  binary strings.

  The generator may be initialized with either a system-generated or
  user-supplied seed value by using Random.srand.

  The class method Random.rand provides the base functionality of Kernel.rand
  along with better handling of floating point values. These are both
  interfaces to Random::DEFAULT, the Ruby system PRNG.

  Random.new will create a new PRNG with a state independent of
  Random::DEFAULT, allowing multiple generators with different seed values or
  sequence positions to exist simultaneously. Random objects can be
  marshaled, allowing sequences to be saved and resumed.

  PRNGs are currently implemented as a modified Mersenne Twister with a period
  of 2**19937-1.
Random::Formatter: 'Format raw random number as Random does   '
Range: |-
  A Range represents an interval---a set of values with a
  beginning and an end. Ranges may be constructed using the
  <em>s</em><code>..</code><em>e</em> and
  <em>s</em><code>...</code><em>e</em> literals, or with
  Range::new. Ranges constructed using <code>..</code>
  run from the beginning to the end inclusively. Those created using
  <code>...</code> exclude the end value. When used as an iterator,
  ranges return each value in the sequence.

     (-1..-5).to_a      #=> []
     (-5..-1).to_a      #=> [-5, -4, -3, -2, -1]
     ('a'..'e').to_a    #=> ["a", "b", "c", "d", "e"]
     ('a'...'e').to_a   #=> ["a", "b", "c", "d"]

  == Beginless/Endless Ranges

  A "beginless range" and "endless range" represents a semi-infinite
  range.  Literal notation for a beginless range is:

     (..1)
     # or
     (...1)

  Literal notation for an endless range is:

     (1..)
     # or similarly
     (1...)

  Which is equivalent to

     (1..nil)  # or similarly (1...nil)
     Range.new(1, nil) # or Range.new(1, nil, true)

  Beginless/endless ranges are useful, for example, for idiomatic
  slicing of arrays:

    [1, 2, 3, 4, 5][...2]   # => [1, 2]
    [1, 2, 3, 4, 5][2...]   # => [3, 4, 5]

  Some implementation details:

  * +begin+ of beginless range and +end+ of endless range are +nil+;
  * +each+ of beginless range raises an exception;
  * +each+ of endless range enumerates infinite sequence (may be
    useful in combination with Enumerable#take_while or similar
    methods);
  * <code>(1..)</code> and <code>(1...)</code> are not equal,
    although technically representing the same sequence.

  == Custom Objects in Ranges

  Ranges can be constructed using any objects that can be compared
  using the <code><=></code> operator.
  Methods that treat the range as a sequence (#each and methods inherited
  from Enumerable) expect the begin object to implement a
  <code>succ</code> method to return the next object in sequence.
  The #step and #include? methods require the begin
  object to implement <code>succ</code> or to be numeric.

  In the <code>Xs</code> class below both <code><=></code> and
  <code>succ</code> are implemented so <code>Xs</code> can be used
  to construct ranges. Note that the Comparable module is included
  so the <code>==</code> method is defined in terms of <code><=></code>.

     class Xs                # represent a string of 'x's
       include Comparable
       attr :length
       def initialize(n)
         @length = n
       end
       def succ
         Xs.new(@length + 1)
       end
       def <=>(other)
         @length <=> other.length
       end
       def to_s
         sprintf "%2d #{inspect}", @length
       end
       def inspect
         'x' * @length
       end
     end

  An example of using <code>Xs</code> to construct a range:

     r = Xs.new(3)..Xs.new(6)   #=> xxx..xxxxxx
     r.to_a                     #=> [xxx, xxxx, xxxxx, xxxxxx]
     r.member?(Xs.new(5))       #=> true
Rational: |-
  A rational number can be represented as a pair of integer numbers:
  a/b (b>0), where a is the numerator and b is the denominator.
  Integer a equals rational a/1 mathematically.

  In Ruby, you can create rational objects with the Kernel#Rational,
  to_r, or rationalize methods or by suffixing +r+ to a literal.
  The return values will be irreducible fractions.

     Rational(1)      #=> (1/1)
     Rational(2, 3)   #=> (2/3)
     Rational(4, -6)  #=> (-2/3)
     3.to_r           #=> (3/1)
     2/3r             #=> (2/3)

  You can also create rational objects from floating-point numbers or
  strings.

     Rational(0.3)    #=> (5404319552844595/18014398509481984)
     Rational('0.3')  #=> (3/10)
     Rational('2/3')  #=> (2/3)

     0.3.to_r         #=> (5404319552844595/18014398509481984)
     '0.3'.to_r       #=> (3/10)
     '2/3'.to_r       #=> (2/3)
     0.3.rationalize  #=> (3/10)

  A rational object is an exact number, which helps you to write
  programs without any rounding errors.

     10.times.inject(0) {|t| t + 0.1 }              #=> 0.9999999999999999
     10.times.inject(0) {|t| t + Rational('0.1') }  #=> (1/1)

  However, when an expression includes an inexact component (numerical value
  or operation), it will produce an inexact result.

     Rational(10) / 3   #=> (10/3)
     Rational(10) / 3.0 #=> 3.3333333333333335

     Rational(-8) ** Rational(1, 3)
                        #=> (1.0000000000000002+1.7320508075688772i)
RegexpError: |-
  Raised when given an invalid regexp expression.

     Regexp.new("?")

  <em>raises the exception:</em>

     RegexpError: target of repeat operator is not specified: /?/
Regexp: |+
  A Regexp holds a regular expression, used to match a pattern
  against strings. Regexps are created using the <code>/.../</code>
  and <code>%r{...}</code> literals, and by the Regexp::new
  constructor.

  Regular expressions (<i>regexp</i>s) are patterns which describe the
  contents of a string. They're used for testing whether a string contains a
  given pattern, or extracting the portions that match. They are created
  with the <tt>/</tt><i>pat</i><tt>/</tt> and
  <tt>%r{</tt><i>pat</i><tt>}</tt> literals or the <tt>Regexp.new</tt>
  constructor.

  A regexp is usually delimited with forward slashes (<tt>/</tt>). For
  example:

      /hay/ =~ 'haystack'   #=> 0
      /y/.match('haystack') #=> #<MatchData "y">

  If a string contains the pattern it is said to <i>match</i>. A literal
  string matches itself.

  Here 'haystack' does not contain the pattern 'needle', so it doesn't match:

      /needle/.match('haystack') #=> nil

  Here 'haystack' contains the pattern 'hay', so it matches:

      /hay/.match('haystack')    #=> #<MatchData "hay">

  Specifically, <tt>/st/</tt> requires that the string contains the letter
  _s_ followed by the letter _t_, so it matches _haystack_, also.

  == <tt>=~</tt> and Regexp#match

  Pattern matching may be achieved by using <tt>=~</tt> operator or Regexp#match
  method.

  === <tt>=~</tt> operator

  <tt>=~</tt> is Ruby's basic pattern-matching operator.  When one operand is a
  regular expression and the other is a string then the regular expression is
  used as a pattern to match against the string.  (This operator is equivalently
  defined by Regexp and String so the order of String and Regexp do not matter.
  Other classes may have different implementations of <tt>=~</tt>.)  If a match
  is found, the operator returns index of first match in string, otherwise it
  returns +nil+.

      /hay/ =~ 'haystack'   #=> 0
      'haystack' =~ /hay/   #=> 0
      /a/   =~ 'haystack'   #=> 1
      /u/   =~ 'haystack'   #=> nil

  Using <tt>=~</tt> operator with a String and Regexp the <tt>$~</tt> global
  variable is set after a successful match.  <tt>$~</tt> holds a MatchData
  object. Regexp.last_match is equivalent to <tt>$~</tt>.

  === Regexp#match method

  The #match method returns a MatchData object:

      /st/.match('haystack')   #=> #<MatchData "st">

  == Metacharacters and Escapes

  The following are <i>metacharacters</i> <tt>(</tt>, <tt>)</tt>,
  <tt>[</tt>, <tt>]</tt>, <tt>{</tt>, <tt>}</tt>, <tt>.</tt>, <tt>?</tt>,
  <tt>+</tt>, <tt>*</tt>. They have a specific meaning when appearing in a
  pattern. To match them literally they must be backslash-escaped. To match
  a backslash literally, backslash-escape it: <tt>\\\\</tt>.

      /1 \+ 2 = 3\?/.match('Does 1 + 2 = 3?') #=> #<MatchData "1 + 2 = 3?">
      /a\\\\b/.match('a\\\\b')                    #=> #<MatchData "a\\b">

  Patterns behave like double-quoted strings and can contain the same
  backslash escapes (the meaning of <tt>\s</tt> is different, however,
  see below[#label-Character+Classes]).

      /\s\u{6771 4eac 90fd}/.match("Go to 東京都")
          #=> #<MatchData " 東京都">

  Arbitrary Ruby expressions can be embedded into patterns with the
  <tt>#{...}</tt> construct.

      place = "東京都"
      /#{place}/.match("Go to 東京都")
          #=> #<MatchData "東京都">

  == Character Classes

  A <i>character class</i> is delimited with square brackets (<tt>[</tt>,
  <tt>]</tt>) and lists characters that may appear at that point in the
  match. <tt>/[ab]/</tt> means _a_ or _b_, as opposed to <tt>/ab/</tt> which
  means _a_ followed by _b_.

      /W[aeiou]rd/.match("Word") #=> #<MatchData "Word">

  Within a character class the hyphen (<tt>-</tt>) is a metacharacter
  denoting an inclusive range of characters. <tt>[abcd]</tt> is equivalent
  to <tt>[a-d]</tt>. A range can be followed by another range, so
  <tt>[abcdwxyz]</tt> is equivalent to <tt>[a-dw-z]</tt>. The order in which
  ranges or individual characters appear inside a character class is
  irrelevant.

      /[0-9a-f]/.match('9f') #=> #<MatchData "9">
      /[9f]/.match('9f')     #=> #<MatchData "9">

  If the first character of a character class is a caret (<tt>^</tt>) the
  class is inverted: it matches any character _except_ those named.

      /[^a-eg-z]/.match('f') #=> #<MatchData "f">

  A character class may contain another character class. By itself this
  isn't useful because <tt>[a-z[0-9]]</tt> describes the same set as
  <tt>[a-z0-9]</tt>. However, character classes also support the <tt>&&</tt>
  operator which performs set intersection on its arguments. The two can be
  combined as follows:

      /[a-w&&[^c-g]z]/ # ([a-w] AND ([^c-g] OR z))

  This is equivalent to:

      /[abh-w]/

  The following metacharacters also behave like character classes:

  * <tt>/./</tt> - Any character except a newline.
  * <tt>/./m</tt> - Any character (the +m+ modifier enables multiline mode)
  * <tt>/\w/</tt> - A word character (<tt>[a-zA-Z0-9_]</tt>)
  * <tt>/\W/</tt> - A non-word character (<tt>[^a-zA-Z0-9_]</tt>).
    Please take a look at {Bug #4044}[https://bugs.ruby-lang.org/issues/4044] if
    using <tt>/\W/</tt> with the <tt>/i</tt> modifier.
  * <tt>/\d/</tt> - A digit character (<tt>[0-9]</tt>)
  * <tt>/\D/</tt> - A non-digit character (<tt>[^0-9]</tt>)
  * <tt>/\h/</tt> - A hexdigit character (<tt>[0-9a-fA-F]</tt>)
  * <tt>/\H/</tt> - A non-hexdigit character (<tt>[^0-9a-fA-F]</tt>)
  * <tt>/\s/</tt> - A whitespace character: <tt>/[ \t\r\n\f\v]/</tt>
  * <tt>/\S/</tt> - A non-whitespace character: <tt>/[^ \t\r\n\f\v]/</tt>
  * <tt>/\R/</tt> - A linebreak: <tt>\n</tt>, <tt>\v</tt>, <tt>\f</tt>, <tt>\r</tt>
    <tt>\u0085</tt> (NEXT LINE), <tt>\u2028</tt> (LINE SEPARATOR), <tt>\u2029</tt> (PARAGRAPH SEPARATOR)
    or <tt>\r\n</tt>.

  POSIX <i>bracket expressions</i> are also similar to character classes.
  They provide a portable alternative to the above, with the added benefit
  that they encompass non-ASCII characters. For instance, <tt>/\d/</tt>
  matches only the ASCII decimal digits (0-9); whereas <tt>/[[:digit:]]/</tt>
  matches any character in the Unicode _Nd_ category.

  * <tt>/[[:alnum:]]/</tt> - Alphabetic and numeric character
  * <tt>/[[:alpha:]]/</tt> - Alphabetic character
  * <tt>/[[:blank:]]/</tt> - Space or tab
  * <tt>/[[:cntrl:]]/</tt> - Control character
  * <tt>/[[:digit:]]/</tt> - Digit
  * <tt>/[[:graph:]]/</tt> - Non-blank character (excludes spaces, control
    characters, and similar)
  * <tt>/[[:lower:]]/</tt> - Lowercase alphabetical character
  * <tt>/[[:print:]]/</tt> - Like [:graph:], but includes the space character
  * <tt>/[[:punct:]]/</tt> - Punctuation character
  * <tt>/[[:space:]]/</tt> - Whitespace character (<tt>[:blank:]</tt>, newline,
    carriage return, etc.)
  * <tt>/[[:upper:]]/</tt> - Uppercase alphabetical
  * <tt>/[[:xdigit:]]/</tt> - Digit allowed in a hexadecimal number (i.e.,
    0-9a-fA-F)

  Ruby also supports the following non-POSIX character classes:

  * <tt>/[[:word:]]/</tt> - A character in one of the following Unicode
    general categories _Letter_, _Mark_, _Number_,
    <i>Connector_Punctuation</i>
  * <tt>/[[:ascii:]]/</tt> - A character in the ASCII character set

      # U+06F2 is "EXTENDED ARABIC-INDIC DIGIT TWO"
      /[[:digit:]]/.match("\u06F2")    #=> #<MatchData "\u{06F2}">
      /[[:upper:]][[:lower:]]/.match("Hello") #=> #<MatchData "He">
      /[[:xdigit:]][[:xdigit:]]/.match("A6")  #=> #<MatchData "A6">

  == Repetition

  The constructs described so far match a single character. They can be
  followed by a repetition metacharacter to specify how many times they need
  to occur. Such metacharacters are called <i>quantifiers</i>.

  * <tt>*</tt> - Zero or more times
  * <tt>+</tt> - One or more times
  * <tt>?</tt> - Zero or one times (optional)
  * <tt>{</tt><i>n</i><tt>}</tt> - Exactly <i>n</i> times
  * <tt>{</tt><i>n</i><tt>,}</tt> - <i>n</i> or more times
  * <tt>{,</tt><i>m</i><tt>}</tt> - <i>m</i> or less times
  * <tt>{</tt><i>n</i><tt>,</tt><i>m</i><tt>}</tt> - At least <i>n</i> and
    at most <i>m</i> times

  At least one uppercase character ('H'), at least one lowercase character
  ('e'), two 'l' characters, then one 'o':

      "Hello".match(/[[:upper:]]+[[:lower:]]+l{2}o/) #=> #<MatchData "Hello">

  Repetition is <i>greedy</i> by default: as many occurrences as possible
  are matched while still allowing the overall match to succeed. By
  contrast, <i>lazy</i> matching makes the minimal amount of matches
  necessary for overall success. Most greedy metacharacters can be made lazy
  by following them with <tt>?</tt>. For the <tt>{n}</tt> pattern, because
  it specifies an exact number of characters to match and not a variable
  number of characters, the <tt>?</tt> metacharacter instead makes the
  repeated pattern optional.

  Both patterns below match the string. The first uses a greedy quantifier so
  '.+' matches '<a><b>'; the second uses a lazy quantifier so '.+?' matches
  '<a>':

      /<.+>/.match("<a><b>")  #=> #<MatchData "<a><b>">
      /<.+?>/.match("<a><b>") #=> #<MatchData "<a>">

  A quantifier followed by <tt>+</tt> matches <i>possessively</i>: once it
  has matched it does not backtrack. They behave like greedy quantifiers,
  but having matched they refuse to "give up" their match even if this
  jeopardises the overall match.

  == Capturing

  Parentheses can be used for <i>capturing</i>. The text enclosed by the
  <i>n</i><sup>th</sup> group of parentheses can be subsequently referred to
  with <i>n</i>. Within a pattern use the <i>backreference</i>
  <tt>\n</tt>; outside of the pattern use
  <tt>MatchData[</tt><i>n</i><tt>]</tt>.

  'at' is captured by the first group of parentheses, then referred to later
  with <tt>\1</tt>:

      /[csh](..) [csh]\1 in/.match("The cat sat in the hat")
          #=> #<MatchData "cat sat in" 1:"at">

  Regexp#match returns a MatchData object which makes the captured text
  available with its #[] method:

      /[csh](..) [csh]\1 in/.match("The cat sat in the hat")[1] #=> 'at'

  Capture groups can be referred to by name when defined with the
  <tt>(?<</tt><i>name</i><tt>>)</tt> or <tt>(?'</tt><i>name</i><tt>')</tt>
  constructs.

      /\$(?<dollars>\d+)\.(?<cents>\d+)/.match("$3.67")
          #=> #<MatchData "$3.67" dollars:"3" cents:"67">
      /\$(?<dollars>\d+)\.(?<cents>\d+)/.match("$3.67")[:dollars] #=> "3"

  Named groups can be backreferenced with <tt>\k<</tt><i>name</i><tt>></tt>,
  where _name_ is the group name.

      /(?<vowel>[aeiou]).\k<vowel>.\k<vowel>/.match('ototomy')
          #=> #<MatchData "ototo" vowel:"o">

  *Note*: A regexp can't use named backreferences and numbered
  backreferences simultaneously. Also, if a named capture is used in a
  regexp, then parentheses used for grouping which would otherwise result
  in a unnamed capture are treated as non-capturing.

      /(\w)(\w)/.match("ab").captures # => ["a", "b"]
      /(\w)(\w)/.match("ab").named_captures # => {}

      /(?<c>\w)(\w)/.match("ab").captures # => ["a"]
      /(?<c>\w)(\w)/.match("ab").named_captures # => {"c"=>"a"}

  When named capture groups are used with a literal regexp on the left-hand
  side of an expression and the <tt>=~</tt> operator, the captured text is
  also assigned to local variables with corresponding names.

      /\$(?<dollars>\d+)\.(?<cents>\d+)/ =~ "$3.67" #=> 0
      dollars #=> "3"

  == Grouping

  Parentheses also <i>group</i> the terms they enclose, allowing them to be
  quantified as one <i>atomic</i> whole.

  The pattern below matches a vowel followed by 2 word characters:

      /[aeiou]\w{2}/.match("Caenorhabditis elegans") #=> #<MatchData "aen">

  Whereas the following pattern matches a vowel followed by a word character,
  twice, i.e. <tt>[aeiou]\w[aeiou]\w</tt>: 'enor'.

      /([aeiou]\w){2}/.match("Caenorhabditis elegans")
          #=> #<MatchData "enor" 1:"or">

  The <tt>(?:</tt>...<tt>)</tt> construct provides grouping without
  capturing. That is, it combines the terms it contains into an atomic whole
  without creating a backreference. This benefits performance at the slight
  expense of readability.

  The first group of parentheses captures 'n' and the second 'ti'. The second
  group is referred to later with the backreference <tt>\2</tt>:

      /I(n)ves(ti)ga\2ons/.match("Investigations")
          #=> #<MatchData "Investigations" 1:"n" 2:"ti">

  The first group of parentheses is now made non-capturing with '?:', so it
  still matches 'n', but doesn't create the backreference. Thus, the
  backreference <tt>\1</tt> now refers to 'ti'.

      /I(?:n)ves(ti)ga\1ons/.match("Investigations")
          #=> #<MatchData "Investigations" 1:"ti">

  === Atomic Grouping

  Grouping can be made <i>atomic</i> with
  <tt>(?></tt><i>pat</i><tt>)</tt>. This causes the subexpression <i>pat</i>
  to be matched independently of the rest of the expression such that what
  it matches becomes fixed for the remainder of the match, unless the entire
  subexpression must be abandoned and subsequently revisited. In this
  way <i>pat</i> is treated as a non-divisible whole. Atomic grouping is
  typically used to optimise patterns so as to prevent the regular
  expression engine from backtracking needlessly.

  The <tt>"</tt> in the pattern below matches the first character of the string,
  then <tt>.*</tt> matches <i>Quote"</i>. This causes the overall match to fail,
  so the text matched by <tt>.*</tt> is backtracked by one position, which
  leaves the final character of the string available to match <tt>"</tt>

            /".*"/.match('"Quote"')     #=> #<MatchData "\"Quote\"">

  If <tt>.*</tt> is grouped atomically, it refuses to backtrack <i>Quote"</i>,
  even though this means that the overall match fails

      /"(?>.*)"/.match('"Quote"') #=> nil

  == Subexpression Calls

  The <tt>\g<</tt><i>name</i><tt>></tt> syntax matches the previous
  subexpression named _name_, which can be a group name or number, again.
  This differs from backreferences in that it re-executes the group rather
  than simply trying to re-match the same text.

  This pattern matches a <i>(</i> character and assigns it to the <tt>paren</tt>
  group, tries to call that the <tt>paren</tt> sub-expression again but fails,
  then matches a literal <i>)</i>:

      /\A(?<paren>\(\g<paren>*\))*\z/ =~ '()'


      /\A(?<paren>\(\g<paren>*\))*\z/ =~ '(())' #=> 0
      # ^1
      #      ^2
      #           ^3
      #                 ^4
      #      ^5
      #           ^6
      #                      ^7
      #                       ^8
      #                       ^9
      #                           ^10

  1.  Matches at the beginning of the string, i.e. before the first
      character.
  2.  Enters a named capture group called <tt>paren</tt>
  3.  Matches a literal <i>(</i>, the first character in the string
  4.  Calls the <tt>paren</tt> group again, i.e. recurses back to the
      second step
  5.  Re-enters the <tt>paren</tt> group
  6.  Matches a literal <i>(</i>, the second character in the
      string
  7.  Try to call <tt>paren</tt> a third time, but fail because
      doing so would prevent an overall successful match
  8.  Match a literal <i>)</i>, the third character in the string.
      Marks the end of the second recursive call
  9.  Match a literal <i>)</i>, the fourth character in the string
  10. Match the end of the string

  == Alternation

  The vertical bar metacharacter (<tt>|</tt>) combines two expressions into
  a single one that matches either of the expressions. Each expression is an
  <i>alternative</i>.

      /\w(and|or)\w/.match("Feliformia") #=> #<MatchData "form" 1:"or">
      /\w(and|or)\w/.match("furandi")    #=> #<MatchData "randi" 1:"and">
      /\w(and|or)\w/.match("dissemblance") #=> nil

  == Character Properties

  The <tt>\p{}</tt> construct matches characters with the named property,
  much like POSIX bracket classes.

  * <tt>/\p{Alnum}/</tt> - Alphabetic and numeric character
  * <tt>/\p{Alpha}/</tt> - Alphabetic character
  * <tt>/\p{Blank}/</tt> - Space or tab
  * <tt>/\p{Cntrl}/</tt> - Control character
  * <tt>/\p{Digit}/</tt> - Digit
  * <tt>/\p{Graph}/</tt> - Non-blank character (excludes spaces, control
    characters, and similar)
  * <tt>/\p{Lower}/</tt> - Lowercase alphabetical character
  * <tt>/\p{Print}/</tt> - Like <tt>\p{Graph}</tt>, but includes the space character
  * <tt>/\p{Punct}/</tt> - Punctuation character
  * <tt>/\p{Space}/</tt> - Whitespace character (<tt>[:blank:]</tt>, newline,
    carriage return, etc.)
  * <tt>/\p{Upper}/</tt> - Uppercase alphabetical
  * <tt>/\p{XDigit}/</tt> - Digit allowed in a hexadecimal number (i.e., 0-9a-fA-F)
  * <tt>/\p{Word}/</tt> - A member of one of the following Unicode general
    category <i>Letter</i>, <i>Mark</i>, <i>Number</i>,
    <i>Connector\_Punctuation</i>
  * <tt>/\p{ASCII}/</tt> - A character in the ASCII character set
  * <tt>/\p{Any}/</tt> - Any Unicode character (including unassigned
    characters)
  * <tt>/\p{Assigned}/</tt> - An assigned character

  A Unicode character's <i>General Category</i> value can also be matched
  with <tt>\p{</tt><i>Ab</i><tt>}</tt> where <i>Ab</i> is the category's
  abbreviation as described below:

  * <tt>/\p{L}/</tt> - 'Letter'
  * <tt>/\p{Ll}/</tt> - 'Letter: Lowercase'
  * <tt>/\p{Lm}/</tt> - 'Letter: Mark'
  * <tt>/\p{Lo}/</tt> - 'Letter: Other'
  * <tt>/\p{Lt}/</tt> - 'Letter: Titlecase'
  * <tt>/\p{Lu}/</tt> - 'Letter: Uppercase
  * <tt>/\p{Lo}/</tt> - 'Letter: Other'
  * <tt>/\p{M}/</tt> - 'Mark'
  * <tt>/\p{Mn}/</tt> - 'Mark: Nonspacing'
  * <tt>/\p{Mc}/</tt> - 'Mark: Spacing Combining'
  * <tt>/\p{Me}/</tt> - 'Mark: Enclosing'
  * <tt>/\p{N}/</tt> - 'Number'
  * <tt>/\p{Nd}/</tt> - 'Number: Decimal Digit'
  * <tt>/\p{Nl}/</tt> - 'Number: Letter'
  * <tt>/\p{No}/</tt> - 'Number: Other'
  * <tt>/\p{P}/</tt> - 'Punctuation'
  * <tt>/\p{Pc}/</tt> - 'Punctuation: Connector'
  * <tt>/\p{Pd}/</tt> - 'Punctuation: Dash'
  * <tt>/\p{Ps}/</tt> - 'Punctuation: Open'
  * <tt>/\p{Pe}/</tt> - 'Punctuation: Close'
  * <tt>/\p{Pi}/</tt> - 'Punctuation: Initial Quote'
  * <tt>/\p{Pf}/</tt> - 'Punctuation: Final Quote'
  * <tt>/\p{Po}/</tt> - 'Punctuation: Other'
  * <tt>/\p{S}/</tt> - 'Symbol'
  * <tt>/\p{Sm}/</tt> - 'Symbol: Math'
  * <tt>/\p{Sc}/</tt> - 'Symbol: Currency'
  * <tt>/\p{Sc}/</tt> - 'Symbol: Currency'
  * <tt>/\p{Sk}/</tt> - 'Symbol: Modifier'
  * <tt>/\p{So}/</tt> - 'Symbol: Other'
  * <tt>/\p{Z}/</tt> - 'Separator'
  * <tt>/\p{Zs}/</tt> - 'Separator: Space'
  * <tt>/\p{Zl}/</tt> - 'Separator: Line'
  * <tt>/\p{Zp}/</tt> - 'Separator: Paragraph'
  * <tt>/\p{C}/</tt> - 'Other'
  * <tt>/\p{Cc}/</tt> - 'Other: Control'
  * <tt>/\p{Cf}/</tt> - 'Other: Format'
  * <tt>/\p{Cn}/</tt> - 'Other: Not Assigned'
  * <tt>/\p{Co}/</tt> - 'Other: Private Use'
  * <tt>/\p{Cs}/</tt> - 'Other: Surrogate'

  Lastly, <tt>\p{}</tt> matches a character's Unicode <i>script</i>. The
  following scripts are supported: <i>Arabic</i>, <i>Armenian</i>,
  <i>Balinese</i>, <i>Bengali</i>, <i>Bopomofo</i>, <i>Braille</i>,
  <i>Buginese</i>, <i>Buhid</i>, <i>Canadian_Aboriginal</i>, <i>Carian</i>,
  <i>Cham</i>, <i>Cherokee</i>, <i>Common</i>, <i>Coptic</i>,
  <i>Cuneiform</i>, <i>Cypriot</i>, <i>Cyrillic</i>, <i>Deseret</i>,
  <i>Devanagari</i>, <i>Ethiopic</i>, <i>Georgian</i>, <i>Glagolitic</i>,
  <i>Gothic</i>, <i>Greek</i>, <i>Gujarati</i>, <i>Gurmukhi</i>, <i>Han</i>,
  <i>Hangul</i>, <i>Hanunoo</i>, <i>Hebrew</i>, <i>Hiragana</i>,
  <i>Inherited</i>, <i>Kannada</i>, <i>Katakana</i>, <i>Kayah_Li</i>,
  <i>Kharoshthi</i>, <i>Khmer</i>, <i>Lao</i>, <i>Latin</i>, <i>Lepcha</i>,
  <i>Limbu</i>, <i>Linear_B</i>, <i>Lycian</i>, <i>Lydian</i>,
  <i>Malayalam</i>, <i>Mongolian</i>, <i>Myanmar</i>, <i>New_Tai_Lue</i>,
  <i>Nko</i>, <i>Ogham</i>, <i>Ol_Chiki</i>, <i>Old_Italic</i>,
  <i>Old_Persian</i>, <i>Oriya</i>, <i>Osmanya</i>, <i>Phags_Pa</i>,
  <i>Phoenician</i>, <i>Rejang</i>, <i>Runic</i>, <i>Saurashtra</i>,
  <i>Shavian</i>, <i>Sinhala</i>, <i>Sundanese</i>, <i>Syloti_Nagri</i>,
  <i>Syriac</i>, <i>Tagalog</i>, <i>Tagbanwa</i>, <i>Tai_Le</i>,
  <i>Tamil</i>, <i>Telugu</i>, <i>Thaana</i>, <i>Thai</i>, <i>Tibetan</i>,
  <i>Tifinagh</i>, <i>Ugaritic</i>, <i>Vai</i>, and <i>Yi</i>.

  Unicode codepoint U+06E9 is named "ARABIC PLACE OF SAJDAH" and belongs to the
  Arabic script:

      /\p{Arabic}/.match("\u06E9") #=> #<MatchData "\u06E9">

  All character properties can be inverted by prefixing their name with a
  caret (<tt>^</tt>).

  Letter 'A' is not in the Unicode Ll (Letter; Lowercase) category, so this
  match succeeds:

      /\p{^Ll}/.match("A") #=> #<MatchData "A">

  == Anchors

  Anchors are metacharacter that match the zero-width positions between
  characters, <i>anchoring</i> the match to a specific position.

  * <tt>^</tt> - Matches beginning of line
  * <tt>$</tt> - Matches end of line
  * <tt>\A</tt> - Matches beginning of string.
  * <tt>\Z</tt> - Matches end of string. If string ends with a newline,
    it matches just before newline
  * <tt>\z</tt> - Matches end of string
  * <tt>\G</tt> - Matches first matching position:

    In methods like <tt>String#gsub</tt> and <tt>String#scan</tt>, it changes on each iteration.
    It initially matches the beginning of subject, and in each following iteration it matches where the last match finished.

        "    a b c".gsub(/ /, '_')    #=> "____a_b_c"
        "    a b c".gsub(/\G /, '_')  #=> "____a b c"

    In methods like <tt>Regexp#match</tt> and <tt>String#match</tt> that take an (optional) offset, it matches where the search begins.

        "hello, world".match(/,/, 3)    #=> #<MatchData ",">
        "hello, world".match(/\G,/, 3)  #=> nil

  * <tt>\b</tt> - Matches word boundaries when outside brackets;
    backspace (0x08) when inside brackets
  * <tt>\B</tt> - Matches non-word boundaries
  * <tt>(?=</tt><i>pat</i><tt>)</tt> - <i>Positive lookahead</i> assertion:
    ensures that the following characters match <i>pat</i>, but doesn't
    include those characters in the matched text
  * <tt>(?!</tt><i>pat</i><tt>)</tt> - <i>Negative lookahead</i> assertion:
    ensures that the following characters do not match <i>pat</i>, but
    doesn't include those characters in the matched text
  * <tt>(?<=</tt><i>pat</i><tt>)</tt> - <i>Positive lookbehind</i>
    assertion: ensures that the preceding characters match <i>pat</i>, but
    doesn't include those characters in the matched text
  * <tt>(?<!</tt><i>pat</i><tt>)</tt> - <i>Negative lookbehind</i>
    assertion: ensures that the preceding characters do not match
    <i>pat</i>, but doesn't include those characters in the matched text

  If a pattern isn't anchored it can begin at any point in the string:

      /real/.match("surrealist") #=> #<MatchData "real">

  Anchoring the pattern to the beginning of the string forces the match to start
  there. 'real' doesn't occur at the beginning of the string, so now the match
  fails:

      /\Areal/.match("surrealist") #=> nil

  The match below fails because although 'Demand' contains 'and', the pattern
  does not occur at a word boundary.

      /\band/.match("Demand")

  Whereas in the following example 'and' has been anchored to a non-word
  boundary so instead of matching the first 'and' it matches from the fourth
  letter of 'demand' instead:

      /\Band.+/.match("Supply and demand curve") #=> #<MatchData "and curve">

  The pattern below uses positive lookahead and positive lookbehind to match
  text appearing in <b></b> tags without including the tags in the match:

      /(?<=<b>)\w+(?=<\/b>)/.match("Fortune favours the <b>bold</b>")
          #=> #<MatchData "bold">

  == Options

  The end delimiter for a regexp can be followed by one or more single-letter
  options which control how the pattern can match.

  * <tt>/pat/i</tt> - Ignore case
  * <tt>/pat/m</tt> - Treat a newline as a character matched by <tt>.</tt>
  * <tt>/pat/x</tt> - Ignore whitespace and comments in the pattern
  * <tt>/pat/o</tt> - Perform <tt>#{}</tt> interpolation only once

  <tt>i</tt>, <tt>m</tt>, and <tt>x</tt> can also be applied on the
  subexpression level with the
  <tt>(?</tt><i>on</i><tt>-</tt><i>off</i><tt>)</tt> construct, which
  enables options <i>on</i>, and disables options <i>off</i> for the
  expression enclosed by the parentheses:

      /a(?i:b)c/.match('aBc')   #=> #<MatchData "aBc">
      /a(?-i:b)c/i.match('ABC') #=> nil

  Additionally, these options can also be toggled for the remainder of the
  pattern:

      /a(?i)bc/.match('abC') #=> #<MatchData "abC">

  Options may also be used with <tt>Regexp.new</tt>:

      Regexp.new("abc", Regexp::IGNORECASE)                     #=> /abc/i
      Regexp.new("abc", Regexp::MULTILINE)                      #=> /abc/m
      Regexp.new("abc # Comment", Regexp::EXTENDED)             #=> /abc # Comment/x
      Regexp.new("abc", Regexp::IGNORECASE | Regexp::MULTILINE) #=> /abc/mi

  == Free-Spacing Mode and Comments

  As mentioned above, the <tt>x</tt> option enables <i>free-spacing</i>
  mode. Literal white space inside the pattern is ignored, and the
  octothorpe (<tt>#</tt>) character introduces a comment until the end of
  the line. This allows the components of the pattern to be organized in a
  potentially more readable fashion.

  A contrived pattern to match a number with optional decimal places:

      float_pat = /\A
          [[:digit:]]+ # 1 or more digits before the decimal point
          (\.          # Decimal point
              [[:digit:]]+ # 1 or more digits after the decimal point
          )? # The decimal point and following digits are optional
      \Z/x
      float_pat.match('3.14') #=> #<MatchData "3.14" 1:".14">

  There are a number of strategies for matching whitespace:

  * Use a pattern such as <tt>\s</tt> or <tt>\p{Space}</tt>.
  * Use escaped whitespace such as <tt>\ </tt>, i.e. a space preceded by a backslash.
  * Use a character class such as <tt>[ ]</tt>.

  Comments can be included in a non-<tt>x</tt> pattern with the
  <tt>(?#</tt><i>comment</i><tt>)</tt> construct, where <i>comment</i> is
  arbitrary text ignored by the regexp engine.

  Comments in regexp literals cannot include unescaped terminator
  characters.

  == Encoding

  Regular expressions are assumed to use the source encoding. This can be
  overridden with one of the following modifiers.

  * <tt>/</tt><i>pat</i><tt>/u</tt> - UTF-8
  * <tt>/</tt><i>pat</i><tt>/e</tt> - EUC-JP
  * <tt>/</tt><i>pat</i><tt>/s</tt> - Windows-31J
  * <tt>/</tt><i>pat</i><tt>/n</tt> - ASCII-8BIT

  A regexp can be matched against a string when they either share an
  encoding, or the regexp's encoding is _US-ASCII_ and the string's encoding
  is ASCII-compatible.

  If a match between incompatible encodings is attempted an
  <tt>Encoding::CompatibilityError</tt> exception is raised.

  The <tt>Regexp#fixed_encoding?</tt> predicate indicates whether the regexp
  has a <i>fixed</i> encoding, that is one incompatible with ASCII. A
  regexp's encoding can be explicitly fixed by supplying
  <tt>Regexp::FIXEDENCODING</tt> as the second argument of
  <tt>Regexp.new</tt>:

      r = Regexp.new("a".force_encoding("iso-8859-1"),Regexp::FIXEDENCODING)
      r =~ "a\u3042"
         # raises Encoding::CompatibilityError: incompatible encoding regexp match
         #         (ISO-8859-1 regexp with UTF-8 string)

  == Special global variables

  Pattern matching sets some global variables :
  * <tt>$~</tt> is equivalent to Regexp.last_match;
  * <tt>$&</tt> contains the complete matched text;
  * <tt>$`</tt> contains string before match;
  * <tt>$'</tt> contains string after match;
  * <tt>$1</tt>, <tt>$2</tt> and so on contain text matching first, second, etc
    capture group;
  * <tt>$+</tt> contains last capture group.

  Example:

      m = /s(\w{2}).*(c)/.match('haystack') #=> #<MatchData "stac" 1:"ta" 2:"c">
      $~                                    #=> #<MatchData "stac" 1:"ta" 2:"c">
      Regexp.last_match                     #=> #<MatchData "stac" 1:"ta" 2:"c">

      $&      #=> "stac"
              # same as m[0]
      $`      #=> "hay"
              # same as m.pre_match
      $'      #=> "k"
              # same as m.post_match
      $1      #=> "ta"
              # same as m[1]
      $2      #=> "c"
              # same as m[2]
      $3      #=> nil
              # no third group in pattern
      $+      #=> "c"
              # same as m[-1]

  These global variables are thread-local and method-local variables.

  == Performance

  Certain pathological combinations of constructs can lead to abysmally bad
  performance.

  Consider a string of 25 <i>a</i>s, a <i>d</i>, 4 <i>a</i>s, and a
  <i>c</i>.

      s = 'a' * 25 + 'd' + 'a' * 4 + 'c'
      #=> "aaaaaaaaaaaaaaaaaaaaaaaaadaaaac"

  The following patterns match instantly as you would expect:

      /(b|a)/ =~ s #=> 0
      /(b|a+)/ =~ s #=> 0
      /(b|a+)*/ =~ s #=> 0

  However, the following pattern takes appreciably longer:

      /(b|a+)*c/ =~ s #=> 26

  This happens because an atom in the regexp is quantified by both an
  immediate <tt>+</tt> and an enclosing <tt>*</tt> with nothing to
  differentiate which is in control of any particular character. The
  nondeterminism that results produces super-linear performance. (Consult
  <i>Mastering Regular Expressions</i> (3rd ed.), pp 222, by
  <i>Jeffery Friedl</i>, for an in-depth analysis). This particular case
  can be fixed by use of atomic grouping, which prevents the unnecessary
  backtracking:

      (start = Time.now) && /(b|a+)*c/ =~ s && (Time.now - start)
         #=> 24.702736882
      (start = Time.now) && /(?>b|a+)*c/ =~ s && (Time.now - start)
         #=> 0.000166571

  A similar case is typified by the following example, which takes
  approximately 60 seconds to execute for me:

  Match a string of 29 <i>a</i>s against a pattern of 29 optional <i>a</i>s
  followed by 29 mandatory <i>a</i>s:

      Regexp.new('a?' * 29 + 'a' * 29) =~ 'a' * 29

  The 29 optional <i>a</i>s match the string, but this prevents the 29
  mandatory <i>a</i>s that follow from matching. Ruby must then backtrack
  repeatedly so as to satisfy as many of the optional matches as it can
  while still matching the mandatory 29. It is plain to us that none of the
  optional matches can succeed, but this fact unfortunately eludes Ruby.

  The best way to improve performance is to significantly reduce the amount of
  backtracking needed.  For this case, instead of individually matching 29
  optional <i>a</i>s, a range of optional <i>a</i>s can be matched all at once
  with <i>a{0,29}</i>:

      Regexp.new('a{0,29}' + 'a' * 29) =~ 'a' * 29

MatchData: |-
  MatchData encapsulates the result of matching a Regexp against
  string. It is returned by Regexp#match and String#match, and also
  stored in a global variable returned by Regexp.last_match.

  Usage:

      url = 'https://docs.ruby-lang.org/en/2.5.0/MatchData.html'
      m = url.match(/(\d\.?)+/)   # => #<MatchData "2.5.0" 1:"0">
      m.string                    # => "https://docs.ruby-lang.org/en/2.5.0/MatchData.html"
      m.regexp                    # => /(\d\.?)+/
      # entire matched substring:
      m[0]                        # => "2.5.0"

      # Working with unnamed captures
      m = url.match(%r{([^/]+)/([^/]+)\.html$})
      m.captures                  # => ["2.5.0", "MatchData"]
      m[1]                        # => "2.5.0"
      m.values_at(1, 2)           # => ["2.5.0", "MatchData"]

      # Working with named captures
      m = url.match(%r{(?<version>[^/]+)/(?<module>[^/]+)\.html$})
      m.captures                  # => ["2.5.0", "MatchData"]
      m.named_captures            # => {"version"=>"2.5.0", "module"=>"MatchData"}
      m[:version]                 # => "2.5.0"
      m.values_at(:version, :module)
                                  # => ["2.5.0", "MatchData"]
      # Numerical indexes are working, too
      m[1]                        # => "2.5.0"
      m.values_at(1, 2)           # => ["2.5.0", "MatchData"]

  == Global variables equivalence

  Parts of last MatchData (returned by Regexp.last_match) are also
  aliased as global variables:

  * <code>$~</code> is Regexp.last_match;
  * <code>$&</code> is Regexp.last_match<code>[0]</code>;
  * <code>$1</code>, <code>$2</code>, and so on are
    Regexp.last_match<code>[i]</code> (captures by number);
  * <code>$`</code> is Regexp.last_match<code>.pre_match</code>;
  * <code>$'</code> is Regexp.last_match<code>.post_match</code>;
  * <code>$+</code> is Regexp.last_match<code>[-1]</code> (the last capture).

  See also "Special global variables" section in Regexp documentation.
Signal: |-
  Many operating systems allow signals to be sent to running
  processes. Some signals have a defined effect on the process, while
  others may be trapped at the code level and acted upon. For
  example, your process may trap the USR1 signal and use it to toggle
  debugging, and may use TERM to initiate a controlled shutdown.

      pid = fork do
        Signal.trap("USR1") do
          $debug = !$debug
          puts "Debug now: #$debug"
        end
        Signal.trap("TERM") do
          puts "Terminating..."
          shutdown()
        end
        # . . . do some work . . .
      end

      Process.detach(pid)

      # Controlling program:
      Process.kill("USR1", pid)
      # ...
      Process.kill("USR1", pid)
      # ...
      Process.kill("TERM", pid)

  produces:
      Debug now: true
      Debug now: false
     Terminating...

  The list of available signal names and their interpretation is
  system dependent. Signal delivery semantics may also vary between
  systems; in particular signal delivery may not always be reliable.
UnicodeNormalize: 'define UnicodeNormalize module here so that we don''t have to look
  it up   '
ThreadGroup: |-
  ThreadGroup provides a means of keeping track of a number of threads as a
  group.

  A given Thread object can only belong to one ThreadGroup at a time; adding
  a thread to a new group will remove it from any previous group.

  Newly created threads belong to the same group as the thread from which they
  were created.
ThreadError: |-
  Raised when an invalid operation is attempted on a thread.

  For example, when no other thread has been started:

     Thread.stop

  This will raises the following exception:

     ThreadError: stopping only thread
     note: use sleep to stop forever
Mutex: |-
  Mutex implements a simple semaphore that can be used to coordinate access to
  shared data from multiple concurrent threads.

  Example:

    semaphore = Mutex.new

    a = Thread.new {
      semaphore.synchronize {
        # access shared resource
      }
    }

    b = Thread.new {
      semaphore.synchronize {
        # access shared resource
      }
    }
ConditionVariable: |-
  ConditionVariable objects augment class Mutex. Using condition variables,
  it is possible to suspend while in the middle of a critical section until a
  resource becomes available.

  Example:

    mutex = Mutex.new
    resource = ConditionVariable.new

    a = Thread.new {
       mutex.synchronize {
         # Thread 'a' now needs the resource
         resource.wait(mutex)
         # 'a' can now have the resource
       }
    }

    b = Thread.new {
       mutex.synchronize {
         # Thread 'b' has finished using the resource
         resource.signal
       }
    }
Queue: |-
  The Queue class implements multi-producer, multi-consumer queues.
  It is especially useful in threaded programming when information
  must be exchanged safely between multiple threads. The Queue class
  implements all the required locking semantics.

  The class implements FIFO type of queue. In a FIFO queue, the first
  tasks added are the first retrieved.

  Example:

      queue = Queue.new

      producer = Thread.new do
        5.times do |i|
           sleep rand(i) # simulate expense
           queue << i
           puts "#{i} produced"
        end
      end

      consumer = Thread.new do
        5.times do |i|
           value = queue.pop
           sleep rand(i/2) # simulate expense
           puts "consumed #{value}"
        end
      end

      consumer.join
SizedQueue: |-
  This class represents queues of specified size capacity.  The push operation
  may be blocked if the capacity is full.

  See Queue for an example of how a SizedQueue works.
ClosedQueueError: |-
  The exception class which will be raised when pushing into a closed
  Queue.  See Queue#close and SizedQueue#close.
Time: |-
  Time is an abstraction of dates and times. Time is stored internally as
  the number of seconds with fraction since the _Epoch_, January 1, 1970
  00:00 UTC. Also see the library module Date. The Time class treats GMT
  (Greenwich Mean Time) and UTC (Coordinated Universal Time) as equivalent.
  GMT is the older way of referring to these baseline times but persists in
  the names of calls on POSIX systems.

  All times may have fraction. Be aware of this fact when comparing times
  with each other -- times that are apparently equal when displayed may be
  different when compared.

  Since Ruby 1.9.2, Time implementation uses a signed 63 bit integer,
  Bignum or Rational.
  The integer is a number of nanoseconds since the _Epoch_ which can
  represent 1823-11-12 to 2116-02-20.
  When Bignum or Rational is used (before 1823, after 2116, under
  nanosecond), Time works slower as when integer is used.

  = Examples

  All of these examples were done using the EST timezone which is GMT-5.

  == Creating a new Time instance

  You can create a new instance of Time with Time::new. This will use the
  current system time. Time::now is an alias for this. You can also
  pass parts of the time to Time::new such as year, month, minute, etc. When
  you want to construct a time this way you must pass at least a year. If you
  pass the year with nothing else time will default to January 1 of that year
  at 00:00:00 with the current system timezone. Here are some examples:

    Time.new(2002)         #=> 2002-01-01 00:00:00 -0500
    Time.new(2002, 10)     #=> 2002-10-01 00:00:00 -0500
    Time.new(2002, 10, 31) #=> 2002-10-31 00:00:00 -0500

  You can pass a UTC offset:

    Time.new(2002, 10, 31, 2, 2, 2, "+02:00") #=> 2002-10-31 02:02:02 +0200

  Or a timezone object:

    tz = timezone("Europe/Athens") # Eastern European Time, UTC+2
    Time.new(2002, 10, 31, 2, 2, 2, tz) #=> 2002-10-31 02:02:02 +0200

  You can also use Time::gm, Time::local and Time::utc to infer GMT,
  local and UTC timezones instead of using the current system
  setting.

  You can also create a new time using Time::at which takes the number of
  seconds (or fraction of seconds) since the {Unix
  Epoch}[http://en.wikipedia.org/wiki/Unix_time].

    Time.at(628232400) #=> 1989-11-28 00:00:00 -0500

  == Working with an instance of Time

  Once you have an instance of Time there is a multitude of things you can
  do with it. Below are some examples. For all of the following examples, we
  will work on the assumption that you have done the following:

    t = Time.new(1993, 02, 24, 12, 0, 0, "+09:00")

  Was that a monday?

    t.monday? #=> false

  What year was that again?

    t.year #=> 1993

  Was it daylight savings at the time?

    t.dst? #=> false

  What's the day a year later?

    t + (60*60*24*365) #=> 1994-02-24 12:00:00 +0900

  How many seconds was that since the Unix Epoch?

    t.to_i #=> 730522800

  You can also do standard functions like compare two times.

    t1 = Time.new(2010)
    t2 = Time.new(2011)

    t1 == t2 #=> false
    t1 == t1 #=> true
    t1 <  t2 #=> true
    t1 >  t2 #=> false

    Time.new(2010,10,31).between?(t1, t2) #=> true

  == Timezone argument

  A timezone argument must have +local_to_utc+ and +utc_to_local+
  methods, and may have +name+, +abbr+, and +dst?+ methods.

  The +local_to_utc+ method should convert a Time-like object from
  the timezone to UTC, and +utc_to_local+ is the opposite.  The
  result also should be a Time or Time-like object (not necessary to
  be the same class).  The #zone of the result is just ignored.
  Time-like argument to these methods is similar to a Time object in
  UTC without sub-second; it has attribute readers for the parts,
  e.g. #year, #month, and so on, and epoch time readers, #to_i.  The
  sub-second attributes are fixed as 0, and #utc_offset, #zone,
  #isdst, and their aliases are same as a Time object in UTC.
  Also #to_time, #+, and #- methods are defined.

  The +name+ method is used for marshaling. If this method is not
  defined on a timezone object, Time objects using that timezone
  object can not be dumped by Marshal.

  The +abbr+ method is used by '%Z' in #strftime.

  The +dst?+ method is called with a +Time+ value and should return whether
  the +Time+ value is in daylight savings time in the zone.

  === Auto conversion to Timezone

  At loading marshaled data, a timezone name will be converted to a timezone
  object by +find_timezone+ class method, if the method is defined.

  Similarly, that class method will be called when a timezone argument does
  not have the necessary methods mentioned above.
TracePoint: |-
  Document-class: TracePoint

  A class that provides the functionality of Kernel#set_trace_func in a
  nice Object-Oriented API.

  == Example

  We can use TracePoint to gather information specifically for exceptions:

            trace = TracePoint.new(:raise) do |tp|
                p [tp.lineno, tp.event, tp.raised_exception]
            end
            #=> #<TracePoint:disabled>

            trace.enable
            #=> false

            0 / 0
            #=> [5, :raise, #<ZeroDivisionError: divided by 0>]

  == Events

  If you don't specify the type of events you want to listen for,
  TracePoint will include all available events.

  *Note* do not depend on current event set, as this list is subject to
  change. Instead, it is recommended you specify the type of events you
  want to use.

  To filter what is traced, you can pass any of the following as +events+:

  +:line+:: execute code on a new line
  +:class+:: start a class or module definition
  +:end+:: finish a class or module definition
  +:call+:: call a Ruby method
  +:return+:: return from a Ruby method
  +:c_call+:: call a C-language routine
  +:c_return+:: return from a C-language routine
  +:raise+:: raise an exception
  +:b_call+:: event hook at block entry
  +:b_return+:: event hook at block ending
  +:thread_begin+:: event hook at thread beginning
  +:thread_end+:: event hook at thread ending
  +:fiber_switch+:: event hook at fiber switch
  +:script_compiled+:: new Ruby code compiled (with +eval+, +load+ or +require+)
UncaughtThrowError: |-
  Raised when +throw+ is called with a _tag_ which does not have
  corresponding +catch+ block.

     throw "foo", "bar"

  <em>raises the exception:</em>

     UncaughtThrowError: uncaught throw "foo"
