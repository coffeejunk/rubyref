---
ARGF:
  main: |-
    +ARGF+ is a stream designed for use in scripts that process files given as
    command-line arguments or passed in via STDIN.

    The arguments passed to your script are stored in the +ARGV+ Array, one
    argument per element. +ARGF+ assumes that any arguments that aren't
    filenames have been removed from +ARGV+. For example:

        $ ruby argf.rb --verbose file1 file2

        ARGV  #=> ["--verbose", "file1", "file2"]
        option = ARGV.shift #=> "--verbose"
        ARGV  #=> ["file1", "file2"]

    You can now use +ARGF+ to work with a concatenation of each of these named
    files. For instance, +ARGF.read+ will return the contents of _file1_
    followed by the contents of _file2_.

    After a file in +ARGV+ has been read +ARGF+ removes it from the Array.
    Thus, after all files have been read +ARGV+ will be empty.

    You can manipulate +ARGV+ yourself to control what +ARGF+ operates on. If
    you remove a file from +ARGV+, it is ignored by +ARGF+; if you add files to
    +ARGV+, they are treated as if they were named on the command line. For
    example:

        ARGV.replace ["file1"]
        ARGF.readlines # Returns the contents of file1 as an Array
        ARGV           #=> []
        ARGV.replace ["file2", "file3"]
        ARGF.read      # Returns the contents of file2 and file3

    If +ARGV+ is empty, +ARGF+ acts as if it contained STDIN, i.e. the data
    piped to your script. For example:

        $ echo "glark" | ruby -e 'p ARGF.read'
        "glark\n"
ArgumentError:
  main: |-
    Raised when the arguments are wrong and there isn't a more specific
    Exception class.

    Ex: passing the wrong number of arguments

       [1, 2, 3].first(4, 5)

    <em>raises the exception:</em>

       ArgumentError: wrong number of arguments (given 2, expected 1)

    Ex: passing an argument that is not acceptable:

       [1, 2, 3].first(-4)

    <em>raises the exception:</em>

       ArgumentError: negative array size
Array:
  main: |-
    Arrays are ordered, integer-indexed collections of any object.

    Array indexing starts at 0, as in C or Java.  A negative index is assumed
    to be relative to the end of the array---that is, an index of -1 indicates
    the last element of the array, -2 is the next to last element in the
    array, and so on.

    == Creating Arrays

    A new array can be created by using the literal constructor
    <code>[]</code>.  Arrays can contain different types of objects.  For
    example, the array below contains an Integer, a String and a Float:

       ary = [1, "two", 3.0] #=> [1, "two", 3.0]

    An array can also be created by explicitly calling Array.new with zero, one
    (the initial size of the Array) or two arguments (the initial size and a
    default object).

       ary = Array.new    #=> []
       Array.new(3)       #=> [nil, nil, nil]
       Array.new(3, true) #=> [true, true, true]

    Note that the second argument populates the array with references to the
    same object.  Therefore, it is only recommended in cases when you need to
    instantiate arrays with natively immutable objects such as Symbols,
    numbers, true or false.

    To create an array with separate objects a block can be passed instead.
    This method is safe to use with mutable objects such as hashes, strings or
    other arrays:

       Array.new(4) {Hash.new}    #=> [{}, {}, {}, {}]
       Array.new(4) {|i| i.to_s } #=> ["0", "1", "2", "3"]

    This is also a quick way to build up multi-dimensional arrays:

       empty_table = Array.new(3) {Array.new(3)}
       #=> [[nil, nil, nil], [nil, nil, nil], [nil, nil, nil]]

    An array can also be created by using the Array() method, provided by
    Kernel, which tries to call #to_ary, then #to_a on its argument.

        Array({:a => "a", :b => "b"}) #=> [[:a, "a"], [:b, "b"]]

    == Example Usage

    In addition to the methods it mixes in through the Enumerable module, the
    Array class has proprietary methods for accessing, searching and otherwise
    manipulating arrays.

    Some of the more common ones are illustrated below.

    == Accessing Elements

    Elements in an array can be retrieved using the Array#[] method.  It can
    take a single integer argument (a numeric index), a pair of arguments
    (start and length) or a range. Negative indices start counting from the end,
    with -1 being the last element.

       arr = [1, 2, 3, 4, 5, 6]
       arr[2]    #=> 3
       arr[100]  #=> nil
       arr[-3]   #=> 4
       arr[2, 3] #=> [3, 4, 5]
       arr[1..4] #=> [2, 3, 4, 5]
       arr[1..-3] #=> [2, 3, 4]

    Another way to access a particular array element is by using the #at method

       arr.at(0) #=> 1

    The #slice method works in an identical manner to Array#[].

    To raise an error for indices outside of the array bounds or else to
    provide a default value when that happens, you can use #fetch.

       arr = ['a', 'b', 'c', 'd', 'e', 'f']
       arr.fetch(100) #=> IndexError: index 100 outside of array bounds: -6...6
       arr.fetch(100, "oops") #=> "oops"

    The special methods #first and #last will return the first and last
    elements of an array, respectively.

       arr.first #=> 1
       arr.last  #=> 6

    To return the first +n+ elements of an array, use #take

       arr.take(3) #=> [1, 2, 3]

    #drop does the opposite of #take, by returning the elements after +n+
    elements have been dropped:

       arr.drop(3) #=> [4, 5, 6]

    == Obtaining Information about an Array

    Arrays keep track of their own length at all times.  To query an array
    about the number of elements it contains, use #length, #count or #size.

      browsers = ['Chrome', 'Firefox', 'Safari', 'Opera', 'IE']
      browsers.length #=> 5
      browsers.count #=> 5

    To check whether an array contains any elements at all

      browsers.empty? #=> false

    To check whether a particular item is included in the array

      browsers.include?('Konqueror') #=> false

    == Adding Items to Arrays

    Items can be added to the end of an array by using either #push or #<<

      arr = [1, 2, 3, 4]
      arr.push(5) #=> [1, 2, 3, 4, 5]
      arr << 6    #=> [1, 2, 3, 4, 5, 6]

    #unshift will add a new item to the beginning of an array.

       arr.unshift(0) #=> [0, 1, 2, 3, 4, 5, 6]

    With #insert you can add a new element to an array at any position.

       arr.insert(3, 'apple')  #=> [0, 1, 2, 'apple', 3, 4, 5, 6]

    Using the #insert method, you can also insert multiple values at once:

       arr.insert(3, 'orange', 'pear', 'grapefruit')
       #=> [0, 1, 2, "orange", "pear", "grapefruit", "apple", 3, 4, 5, 6]

    == Removing Items from an Array

    The method #pop removes the last element in an array and returns it:

       arr =  [1, 2, 3, 4, 5, 6]
       arr.pop #=> 6
       arr #=> [1, 2, 3, 4, 5]

    To retrieve and at the same time remove the first item, use #shift:

       arr.shift #=> 1
       arr #=> [2, 3, 4, 5]

    To delete an element at a particular index:

       arr.delete_at(2) #=> 4
       arr #=> [2, 3, 5]

    To delete a particular element anywhere in an array, use #delete:

       arr = [1, 2, 2, 3]
       arr.delete(2) #=> 2
       arr #=> [1,3]

    A useful method if you need to remove +nil+ values from an array is
    #compact:

       arr = ['foo', 0, nil, 'bar', 7, 'baz', nil]
       arr.compact  #=> ['foo', 0, 'bar', 7, 'baz']
       arr          #=> ['foo', 0, nil, 'bar', 7, 'baz', nil]
       arr.compact! #=> ['foo', 0, 'bar', 7, 'baz']
       arr          #=> ['foo', 0, 'bar', 7, 'baz']

    Another common need is to remove duplicate elements from an array.

    It has the non-destructive #uniq, and destructive method #uniq!

       arr = [2, 5, 6, 556, 6, 6, 8, 9, 0, 123, 556]
       arr.uniq #=> [2, 5, 6, 556, 8, 9, 0, 123]

    == Iterating over Arrays

    Like all classes that include the Enumerable module, Array has an each
    method, which defines what elements should be iterated over and how.  In
    case of Array's #each, all elements in the Array instance are yielded to
    the supplied block in sequence.

    Note that this operation leaves the array unchanged.

       arr = [1, 2, 3, 4, 5]
       arr.each {|a| print a -= 10, " "}
       # prints: -9 -8 -7 -6 -5
       #=> [1, 2, 3, 4, 5]

    Another sometimes useful iterator is #reverse_each which will iterate over
    the elements in the array in reverse order.

       words = %w[first second third fourth fifth sixth]
       str = ""
       words.reverse_each {|word| str += "#{word} "}
       p str #=> "sixth fifth fourth third second first "

    The #map method can be used to create a new array based on the original
    array, but with the values modified by the supplied block:

       arr.map {|a| 2*a}     #=> [2, 4, 6, 8, 10]
       arr                   #=> [1, 2, 3, 4, 5]
       arr.map! {|a| a**2}   #=> [1, 4, 9, 16, 25]
       arr                   #=> [1, 4, 9, 16, 25]

    == Selecting Items from an Array

    Elements can be selected from an array according to criteria defined in a
    block.  The selection can happen in a destructive or a non-destructive
    manner.  While the destructive operations will modify the array they were
    called on, the non-destructive methods usually return a new array with the
    selected elements, but leave the original array unchanged.

    === Non-destructive Selection

       arr = [1, 2, 3, 4, 5, 6]
       arr.select {|a| a > 3}       #=> [4, 5, 6]
       arr.reject {|a| a < 3}       #=> [3, 4, 5, 6]
       arr.drop_while {|a| a < 4}   #=> [4, 5, 6]
       arr                          #=> [1, 2, 3, 4, 5, 6]

    === Destructive Selection

    #select! and #reject! are the corresponding destructive methods to #select
    and #reject

    Similar to #select vs. #reject, #delete_if and #keep_if have the exact
    opposite result when supplied with the same block:

       arr.delete_if {|a| a < 4}   #=> [4, 5, 6]
       arr                         #=> [4, 5, 6]

       arr = [1, 2, 3, 4, 5, 6]
       arr.keep_if {|a| a < 4}   #=> [1, 2, 3]
       arr                       #=> [1, 2, 3]
BasicObject:
  main: |-
    BasicObject is the parent class of all classes in Ruby.  It's an explicit
    blank class.

    BasicObject can be used for creating object hierarchies independent of
    Ruby's object hierarchy, proxy objects like the Delegator class, or other
    uses where namespace pollution from Ruby's methods and classes must be
    avoided.

    To avoid polluting BasicObject for other users an appropriately named
    subclass of BasicObject should be created instead of directly modifying
    BasicObject:

      class MyObjectSystem < BasicObject
      end

    BasicObject does not include Kernel (for methods like +puts+) and
    BasicObject is outside of the namespace of the standard library so common
    classes will not be found without using a full class path.

    A variety of strategies can be used to provide useful portions of the
    standard library to subclasses of BasicObject.  A subclass could
    <code>include Kernel</code> to obtain +puts+, +exit+, etc.  A custom
    Kernel-like module could be created and included or delegation can be used
    via #method_missing:

      class MyObjectSystem < BasicObject
        DELEGATE = [:puts, :p]

        def method_missing(name, *args, &block)
          return super unless DELEGATE.include? name
          ::Kernel.send(name, *args, &block)
        end

        def respond_to_missing?(name, include_private = false)
          DELEGATE.include?(name) or super
        end
      end

    Access to classes and modules from the Ruby standard library can be
    obtained in a BasicObject subclass by referencing the desired constant
    from the root like <code>::File</code> or <code>::Enumerator</code>.
    Like #method_missing, #const_missing can be used to delegate constant
    lookup to +Object+:

      class MyObjectSystem < BasicObject
        def self.const_missing(name)
          ::Object.const_get(name)
        end
      end
Binding:
  main: |-
    Objects of class Binding encapsulate the execution context at some
    particular place in the code and retain this context for future
    use. The variables, methods, value of <code>self</code>, and
    possibly an iterator block that can be accessed in this context
    are all retained. Binding objects can be created using
    Kernel#binding, and are made available to the callback of
    Kernel#set_trace_func and instances of TracePoint.

    These binding objects can be passed as the second argument of the
    Kernel#eval method, establishing an environment for the
    evaluation.

       class Demo
         def initialize(n)
           @secret = n
         end
         def get_binding
           binding
         end
       end

       k1 = Demo.new(99)
       b1 = k1.get_binding
       k2 = Demo.new(-3)
       b2 = k2.get_binding

       eval("@secret", b1)   #=> 99
       eval("@secret", b2)   #=> -3
       eval("@secret")       #=> nil

    Binding objects have no class-specific methods.
Class:
  main: |-
    Classes in Ruby are first-class objects---each is an instance of
    class Class.

    Typically, you create a new class by using:

      class Name
       # some code describing the class behavior
      end

    When a new class is created, an object of type Class is initialized and
    assigned to a global constant (Name in this case).

    When <code>Name.new</code> is called to create a new object, the
    #new method in Class is run by default.
    This can be demonstrated by overriding #new in Class:

       class Class
         alias old_new new
         def new(*args)
           print "Creating a new ", self.name, "\n"
           old_new(*args)
         end
       end

       class Name
       end

       n = Name.new

    <em>produces:</em>

       Creating a new Name

    Classes, modules, and objects are interrelated. In the diagram
    that follows, the vertical arrows represent inheritance, and the
    parentheses metaclasses. All metaclasses are instances
    of the class `Class'.
                               +---------+             +-...
                               |         |             |
               BasicObject-----|-->(BasicObject)-------|-...
                   ^           |         ^             |
                   |           |         |             |
                Object---------|----->(Object)---------|-...
                   ^           |         ^             |
                   |           |         |             |
                   +-------+   |         +--------+    |
                   |       |   |         |        |    |
                   |    Module-|---------|--->(Module)-|-...
                   |       ^   |         |        ^    |
                   |       |   |         |        |    |
                   |     Class-|---------|---->(Class)-|-...
                   |       ^   |         |        ^    |
                   |       +---+         |        +----+
                   |                     |
      obj--->OtherClass---------->(OtherClass)-----------...
ClosedQueueError:
  main: |-
    The exception class which will be raised when pushing into a closed
    Queue.  See Queue#close and SizedQueue#close.
Comparable:
  main: |-
    The Comparable mixin is used by classes whose objects may be
    ordered. The class must define the <code><=></code> operator,
    which compares the receiver against another object, returning a
    value less than 0, returning 0, or returning a value greater than 0,
    depending on whether the receiver is less than, equal to,
    or greater than the other object. If the other object is not
    comparable then the <code><=></code> operator should return +nil+.
    Comparable uses <code><=></code> to implement the conventional
    comparison operators (<code><</code>, <code><=</code>,
    <code>==</code>, <code>>=</code>, and <code>></code>) and the
    method <code>between?</code>.

       class SizeMatters
         include Comparable
         attr :str
         def <=>(other)
           str.size <=> other.str.size
         end
         def initialize(str)
           @str = str
         end
         def inspect
           @str
         end
       end

       s1 = SizeMatters.new("Z")
       s2 = SizeMatters.new("YY")
       s3 = SizeMatters.new("XXX")
       s4 = SizeMatters.new("WWWW")
       s5 = SizeMatters.new("VVVVV")

       s1 < s2                       #=> true
       s4.between?(s1, s3)           #=> false
       s4.between?(s3, s5)           #=> true
       [ s3, s2, s5, s4, s1 ].sort   #=> [Z, YY, XXX, WWWW, VVVVV]
Complex:
  main: |-
    A complex number can be represented as a paired real number with
    imaginary unit; a+bi.  Where a is real part, b is imaginary part
    and i is imaginary unit.  Real a equals complex a+0i
    mathematically.

    Complex object can be created as literal, and also by using
    Kernel#Complex, Complex::rect, Complex::polar or to_c method.

       2+1i                 #=> (2+1i)
       Complex(1)           #=> (1+0i)
       Complex(2, 3)        #=> (2+3i)
       Complex.polar(2, 3)  #=> (-1.9799849932008908+0.2822400161197344i)
       3.to_c               #=> (3+0i)

    You can also create complex object from floating-point numbers or
    strings.

       Complex(0.3)         #=> (0.3+0i)
       Complex('0.3-0.5i')  #=> (0.3-0.5i)
       Complex('2/3+3/4i')  #=> ((2/3)+(3/4)*i)
       Complex('1@2')       #=> (-0.4161468365471424+0.9092974268256817i)

       0.3.to_c             #=> (0.3+0i)
       '0.3-0.5i'.to_c      #=> (0.3-0.5i)
       '2/3+3/4i'.to_c      #=> ((2/3)+(3/4)*i)
       '1@2'.to_c           #=> (-0.4161468365471424+0.9092974268256817i)

    A complex object is either an exact or an inexact number.

       Complex(1, 1) / 2    #=> ((1/2)+(1/2)*i)
       Complex(1, 1) / 2.0  #=> (0.5+0.5i)
ConditionVariable:
  main: |-
    ConditionVariable objects augment class Mutex. Using condition variables,
    it is possible to suspend while in the middle of a critical section until a
    resource becomes available.

    Example:

      mutex = Mutex.new
      resource = ConditionVariable.new

      a = Thread.new {
         mutex.synchronize {
           # Thread 'a' now needs the resource
           resource.wait(mutex)
           # 'a' can now have the resource
         }
      }

      b = Thread.new {
         mutex.synchronize {
           # Thread 'b' has finished using the resource
           resource.signal
         }
      }
Continuation:
  main: |-
    Continuation objects are generated by Kernel#callcc,
    after having +require+d <i>continuation</i>. They hold
    a return address and execution context, allowing a nonlocal return
    to the end of the #callcc block from anywhere within a
    program. Continuations are somewhat analogous to a structured
    version of C's <code>setjmp/longjmp</code> (although they contain
    more state, so you might consider them closer to threads).

    For instance:

       require "continuation"
       arr = [ "Freddie", "Herbie", "Ron", "Max", "Ringo" ]
       callcc{|cc| $cc = cc}
       puts(message = arr.shift)
       $cc.call unless message =~ /Max/

    <em>produces:</em>

       Freddie
       Herbie
       Ron
       Max

    Also you can call callcc in other methods:

       require "continuation"

       def g
         arr = [ "Freddie", "Herbie", "Ron", "Max", "Ringo" ]
         cc = callcc { |cc| cc }
         puts arr.shift
         return cc, arr.size
       end

       def f
         c, size = g
         c.call(c) if size > 1
       end

       f

    This (somewhat contrived) example allows the inner loop to abandon
    processing early:

       require "continuation"
       callcc {|cont|
         for i in 0..4
           print "#{i}: "
           for j in i*5...(i+1)*5
             cont.call() if j == 17
             printf "%3d", j
           end
         end
       }
       puts

    <em>produces:</em>

       0:   0  1  2  3  4
       1:   5  6  7  8  9
       2:  10 11 12 13 14
       3:  15 16
Data:
  main: |-
    This is a deprecated class, base class for C extensions using
    Data_Make_Struct or Data_Wrap_Struct.
Dir:
  main: |-
    Objects of class Dir are directory streams representing
    directories in the underlying file system. They provide a variety
    of ways to list directories and their contents. See also File.

    The directory used in these examples contains the two regular files
    (<code>config.h</code> and <code>main.rb</code>), the parent
    directory (<code>..</code>), and the directory itself
    (<code>.</code>).
ENV:
  main: |-
    ENV is a hash-like accessor for environment variables.

    === Interaction with the Operating System

    The ENV object interacts with the operating system's environment variables:

    - When you get the value for a name in ENV, the value is retrieved from among the current environment variables.
    - When you create or set a name-value pair in ENV, the name and value are immediately set in the environment variables.
    - When you delete a name-value pair in ENV, it is immediately deleted from the environment variables.

    === Names and Values

    Generally, a name or value is a String.

    ==== Valid Names and Values

    Each name or value must be one of the following:

    - A String.
    - An object that responds to \#to_str by returning a String, in which case that String will be used as the name or value.

    ==== Invalid Names and Values

    A new name:

    - May not be the empty string:
        ENV[''] = '0'
        # Raises Errno::EINVAL (Invalid argument - ruby_setenv())

    - May not contain character <code>"="</code>:
        ENV['='] = '0'
        # Raises Errno::EINVAL (Invalid argument - ruby_setenv(=))

    A new name or value:

    - May not be a non-String that does not respond to \#to_str:

        ENV['foo'] = Object.new
        # Raises TypeError (no implicit conversion of Object into String)
        ENV[Object.new] = '0'
        # Raises TypeError (no implicit conversion of Object into String)

    - May not contain the NUL character <code>"\0"</code>:

        ENV['foo'] = "\0"
        # Raises ArgumentError (bad environment variable value: contains null byte)
        ENV["\0"] == '0'
        # Raises ArgumentError (bad environment variable name: contains null byte)

    - May not have an ASCII-incompatible encoding such as UTF-16LE or ISO-2022-JP:

        ENV['foo'] = '0'.force_encoding(Encoding::ISO_2022_JP)
        # Raises ArgumentError (bad environment variable name: ASCII incompatible encoding: ISO-2022-JP)
        ENV["foo".force_encoding(Encoding::ISO_2022_JP)] = '0'
        # Raises ArgumentError (bad environment variable name: ASCII incompatible encoding: ISO-2022-JP)

    === About Ordering

    ENV enumerates its name/value pairs in the order found
    in the operating system's environment variables.
    Therefore the ordering of ENV content is OS-dependent, and may be indeterminate.

    This will be seen in:
    - A Hash returned by an ENV method.
    - An Enumerator returned by an ENV method.
    - An Array returned by ENV.keys, ENV.values, or ENV.to_a.
    - The String returned by ENV.inspect.
    - The Array returned by ENV.shift.
    - The name returned by ENV.key.

    === About the Examples
    Some methods in ENV return ENV itself. Typically, there are many environment variables.
    It's not useful to display a large ENV in the examples here,
    so most example snippets begin by resetting the contents of ENV:
    - ENV.replace replaces ENV with a new collection of entries.
    - ENV.clear empties ENV.
EOFError:
  main: |-
    Raised by some IO operations when reaching the end of file. Many IO
    methods exist in two forms,

    one that returns +nil+ when the end of file is reached, the other
    raises +EOFError+.

    +EOFError+ is a subclass of +IOError+.

       file = File.open("/etc/hosts")
       file.read
       file.gets     #=> nil
       file.readline #=> EOFError: end of file reached
Encoding:
  main: |-
    An Encoding instance represents a character encoding usable in Ruby. It is
    defined as a constant under the Encoding namespace. It has a name and
    optionally, aliases:

      Encoding::ISO_8859_1.name
      #=> "ISO-8859-1"

      Encoding::ISO_8859_1.names
      #=> ["ISO-8859-1", "ISO8859-1"]

    Ruby methods dealing with encodings return or accept Encoding instances as
    arguments (when a method accepts an Encoding instance as an argument, it
    can be passed an Encoding name or alias instead).

      "some string".encoding
      #=> #<Encoding:UTF-8>

      string = "some string".encode(Encoding::ISO_8859_1)
      #=> "some string"
      string.encoding
      #=> #<Encoding:ISO-8859-1>

      "some string".encode "ISO-8859-1"
      #=> "some string"

    Encoding::ASCII_8BIT is a special encoding that is usually used for
    a byte string, not a character string. But as the name insists, its
    characters in the range of ASCII are considered as ASCII
    characters.  This is useful when you use ASCII-8BIT characters with
    other ASCII compatible characters.

    == Changing an encoding

    The associated Encoding of a String can be changed in two different ways.

    First, it is possible to set the Encoding of a string to a new Encoding
    without changing the internal byte representation of the string, with
    String#force_encoding. This is how you can tell Ruby the correct encoding
    of a string.

      string
      #=> "R\xC3\xA9sum\xC3\xA9"
      string.encoding
      #=> #<Encoding:ISO-8859-1>
      string.force_encoding(Encoding::UTF_8)
      #=> "R\u00E9sum\u00E9"

    Second, it is possible to transcode a string, i.e. translate its internal
    byte representation to another encoding. Its associated encoding is also
    set to the other encoding. See String#encode for the various forms of
    transcoding, and the Encoding::Converter class for additional control over
    the transcoding process.

      string
      #=> "R\u00E9sum\u00E9"
      string.encoding
      #=> #<Encoding:UTF-8>
      string = string.encode!(Encoding::ISO_8859_1)
      #=> "R\xE9sum\xE9"
      string.encoding
      #=> #<Encoding::ISO-8859-1>

    == Script encoding

    All Ruby script code has an associated Encoding which any String literal
    created in the source code will be associated to.

    The default script encoding is Encoding::UTF_8 after v2.0, but it
    can be changed by a magic comment on the first line of the source
    code file (or second line, if there is a shebang line on the
    first). The comment must contain the word <code>coding</code> or
    <code>encoding</code>, followed by a colon, space and the Encoding
    name or alias:

      # encoding: UTF-8

      "some string".encoding
      #=> #<Encoding:UTF-8>

    The <code>__ENCODING__</code> keyword returns the script encoding of the file
    which the keyword is written:

      # encoding: ISO-8859-1

      __ENCODING__
      #=> #<Encoding:ISO-8859-1>

    <code>ruby -K</code> will change the default locale encoding, but this is
    not recommended. Ruby source files should declare its script encoding by a
    magic comment even when they only depend on US-ASCII strings or regular
    expressions.

    == Locale encoding

    The default encoding of the environment. Usually derived from locale.

    see Encoding.locale_charmap, Encoding.find('locale')

    == Filesystem encoding

    The default encoding of strings from the filesystem of the environment.
    This is used for strings of file names or paths.

    see Encoding.find('filesystem')

    == External encoding

    Each IO object has an external encoding which indicates the encoding that
    Ruby will use to read its data. By default Ruby sets the external encoding
    of an IO object to the default external encoding. The default external
    encoding is set by locale encoding or the interpreter <code>-E</code> option.
    Encoding.default_external returns the current value of the external
    encoding.

      ENV["LANG"]
      #=> "UTF-8"
      Encoding.default_external
      #=> #<Encoding:UTF-8>

      $ ruby -E ISO-8859-1 -e "p Encoding.default_external"
      #<Encoding:ISO-8859-1>

      $ LANG=C ruby -e 'p Encoding.default_external'
      #<Encoding:US-ASCII>

    The default external encoding may also be set through
    Encoding.default_external=, but you should not do this as strings created
    before and after the change will have inconsistent encodings.  Instead use
    <code>ruby -E</code> to invoke ruby with the correct external encoding.

    When you know that the actual encoding of the data of an IO object is not
    the default external encoding, you can reset its external encoding with
    IO#set_encoding or set it at IO object creation (see IO.new options).

    == Internal encoding

    To process the data of an IO object which has an encoding different
    from its external encoding, you can set its internal encoding. Ruby will use
    this internal encoding to transcode the data when it is read from the IO
    object.

    Conversely, when data is written to the IO object it is transcoded from the
    internal encoding to the external encoding of the IO object.

    The internal encoding of an IO object can be set with
    IO#set_encoding or at IO object creation (see IO.new options).

    The internal encoding is optional and when not set, the Ruby default
    internal encoding is used. If not explicitly set this default internal
    encoding is +nil+ meaning that by default, no transcoding occurs.

    The default internal encoding can be set with the interpreter option
    <code>-E</code>. Encoding.default_internal returns the current internal
    encoding.

       $ ruby -e 'p Encoding.default_internal'
       nil

       $ ruby -E ISO-8859-1:UTF-8 -e "p [Encoding.default_external, \
         Encoding.default_internal]"
       [#<Encoding:ISO-8859-1>, #<Encoding:UTF-8>]

    The default internal encoding may also be set through
    Encoding.default_internal=, but you should not do this as strings created
    before and after the change will have inconsistent encodings.  Instead use
    <code>ruby -E</code> to invoke ruby with the correct internal encoding.

    == IO encoding example

    In the following example a UTF-8 encoded string "R\u00E9sum\u00E9" is transcoded for
    output to ISO-8859-1 encoding, then read back in and transcoded to UTF-8:

      string = "R\u00E9sum\u00E9"

      open("transcoded.txt", "w:ISO-8859-1") do |io|
        io.write(string)
      end

      puts "raw text:"
      p File.binread("transcoded.txt")
      puts

      open("transcoded.txt", "r:ISO-8859-1:UTF-8") do |io|
        puts "transcoded text:"
        p io.read
      end

    While writing the file, the internal encoding is not specified as it is
    only necessary for reading.  While reading the file both the internal and
    external encoding must be specified to obtain the correct result.

      $ ruby t.rb
      raw text:
      "R\xE9sum\xE9"

      transcoded text:
      "R\u00E9sum\u00E9"
Encoding::CompatibilityError:
  main: |-
    Raised by Encoding and String methods when the source encoding is
    incompatible with the target encoding.
Encoding::Converter:
  main: Encoding conversion class.
Encoding::ConverterNotFoundError:
  main: |-
    Raised by transcoding methods when a named encoding does not
    correspond with a known converter.
Encoding::InvalidByteSequenceError:
  main: |-
    Raised by Encoding and String methods when the string being
    transcoded contains a byte invalid for the either the source or
    target encoding.
Encoding::UndefinedConversionError:
  main: |-
    Raised by Encoding and String methods when a transcoding operation
    fails.
EncodingError:
  main: EncodingError is the base class for encoding errors.
Enumerable:
  main: |-
    The Enumerable mixin provides collection classes with several
    traversal and searching methods, and with the ability to sort. The
    class must provide a method #each, which yields
    successive members of the collection. If Enumerable#max, #min, or
    #sort is used, the objects in the collection must also implement a
    meaningful <code><=></code> operator, as these methods rely on an
    ordering between members of the collection.
Enumerator:
  main: |-
    A class which allows both internal and external iteration.

    An Enumerator can be created by the following methods.
    - Object#to_enum
    - Object#enum_for
    - Enumerator.new

    Most methods have two forms: a block form where the contents
    are evaluated for each item in the enumeration, and a non-block form
    which returns a new Enumerator wrapping the iteration.

      enumerator = %w(one two three).each
      puts enumerator.class # => Enumerator

      enumerator.each_with_object("foo") do |item, obj|
        puts "#{obj}: #{item}"
      end

      # foo: one
      # foo: two
      # foo: three

      enum_with_obj = enumerator.each_with_object("foo")
      puts enum_with_obj.class # => Enumerator

      enum_with_obj.each do |item, obj|
        puts "#{obj}: #{item}"
      end

      # foo: one
      # foo: two
      # foo: three

    This allows you to chain Enumerators together.  For example, you
    can map a list's elements to strings containing the index
    and the element as a string via:

      puts %w[foo bar baz].map.with_index { |w, i| "#{i}:#{w}" }
      # => ["0:foo", "1:bar", "2:baz"]

    An Enumerator can also be used as an external iterator.
    For example, Enumerator#next returns the next value of the iterator
    or raises StopIteration if the Enumerator is at the end.

      e = [1,2,3].each   # returns an enumerator object.
      puts e.next   # => 1
      puts e.next   # => 2
      puts e.next   # => 3
      puts e.next   # raises StopIteration

    You can use this to implement an internal iterator as follows:

      def ext_each(e)
        while true
          begin
            vs = e.next_values
          rescue StopIteration
            return $!.result
          end
          y = yield(*vs)
          e.feed y
        end
      end

      o = Object.new

      def o.each
        puts yield
        puts yield(1)
        puts yield(1, 2)
        3
      end

      # use o.each as an internal iterator directly.
      puts o.each {|*x| puts x; [:b, *x] }
      # => [], [:b], [1], [:b, 1], [1, 2], [:b, 1, 2], 3

      # convert o.each to an external iterator for
      # implementing an internal iterator.
      puts ext_each(o.to_enum) {|*x| puts x; [:b, *x] }
      # => [], [:b], [1], [:b, 1], [1, 2], [:b, 1, 2], 3
Enumerator::ArithmeticSequence:
  main: |-
    Enumerator::ArithmeticSequence is a subclass of Enumerator,
    that is a representation of sequences of numbers with common difference.
    Instances of this class can be generated by the Range#step and Numeric#step
    methods.
Enumerator::Chain:
  main: |-
    Enumerator::Chain is a subclass of Enumerator, which represents a
    chain of enumerables that works as a single enumerator.

    This type of objects can be created by Enumerable#chain and
    Enumerator#+.
Enumerator::Generator:
  main: 'Generator   '
Enumerator::Lazy:
  main: |-
    Enumerator::Lazy is a special type of Enumerator, that allows constructing
    chains of operations without evaluating them immediately, and evaluating
    values on as-needed basis. In order to do so it redefines most of Enumerable
    methods so that they just construct another lazy enumerator.

    Enumerator::Lazy can be constructed from any Enumerable with the
    Enumerable#lazy method.

       lazy = (1..Float::INFINITY).lazy.select(&:odd?).drop(10).take_while { |i| i < 30 }
       # => #<Enumerator::Lazy: #<Enumerator::Lazy: #<Enumerator::Lazy: #<Enumerator::Lazy: 1..Infinity>:select>:drop(10)>:take_while>

    The real enumeration is performed when any non-redefined Enumerable method
    is called, like Enumerable#first or Enumerable#to_a (the latter is aliased
    as #force for more semantic code):

       lazy.first(2)
       #=> [21, 23]

       lazy.force
       #=> [21, 23, 25, 27, 29]

    Note that most Enumerable methods that could be called with or without
    a block, on Enumerator::Lazy will always require a block:

       [1, 2, 3].map       #=> #<Enumerator: [1, 2, 3]:map>
       [1, 2, 3].lazy.map  # ArgumentError: tried to call lazy map without a block

    This class allows idiomatic calculations on long or infinite sequences, as well
    as chaining of calculations without constructing intermediate arrays.

    Example for working with a slowly calculated sequence:

       require 'open-uri'

       # This will fetch all URLs before selecting
       # necessary data
       URLS.map { |u| JSON.parse(open(u).read) }
         .select { |data| data.key?('stats') }
         .first(5)

       # This will fetch URLs one-by-one, only till
       # there is enough data to satisfy the condition
       URLS.lazy.map { |u| JSON.parse(open(u).read) }
         .select { |data| data.key?('stats') }
         .first(5)

    Ending a chain with ".eager" generates a non-lazy enumerator, which
    is suitable for returning or passing to another method that expects
    a normal enumerator.

       def active_items
         groups
           .lazy
           .flat_map(&:items)
           .reject(&:disabled)
           .eager
       end

       # This works lazily; if a checked item is found, it stops
       # iteration and does not look into remaining groups.
       first_checked = active_items.find(&:checked)

       # This returns an array of items like a normal enumerator does.
       all_checked = active_items.select(&:checked)
Enumerator::Producer:
  main: 'Producer   '
Enumerator::Yielder:
  main: 'Yielder   '
Errno:
  main: |-
    Ruby exception objects are subclasses of Exception.  However,
    operating systems typically report errors using plain
    integers. Module Errno is created dynamically to map these
    operating system errors to Ruby classes, with each error number
    generating its own subclass of SystemCallError.  As the subclass
    is created in module Errno, its name will start
    <code>Errno::</code>.

    The names of the <code>Errno::</code> classes depend on the
    environment in which Ruby runs. On a typical Unix or Windows
    platform, there are Errno classes such as Errno::EACCES,
    Errno::EAGAIN, Errno::EINTR, and so on.

    The integer operating system error number corresponding to a
    particular error is available as the class constant
    <code>Errno::</code><em>error</em><code>::Errno</code>.

       Errno::EACCES::Errno   #=> 13
       Errno::EAGAIN::Errno   #=> 11
       Errno::EINTR::Errno    #=> 4

    The full list of operating system errors on your particular platform
    are available as the constants of Errno.

       Errno.constants   #=> :E2BIG, :EACCES, :EADDRINUSE, :EADDRNOTAVAIL, ...
Exception:
  main: |-
    \Class Exception and its subclasses are used to communicate between
    Kernel#raise and +rescue+ statements in <code>begin ... end</code> blocks.

    An Exception object carries information about an exception:
    - Its type (the exception's class).
    - An optional descriptive message.
    - Optional backtrace information.

    Some built-in subclasses of Exception have additional methods: e.g., NameError#name.

    == Defaults

    Two Ruby statements have default exception classes:
    - +raise+: defaults to RuntimeError.
    - +rescue+: defaults to StandardError.

    == Global Variables

    When an exception has been raised but not yet handled (in +rescue+,
    +ensure+, +at_exit+ and +END+ blocks), two global variables are set:
    - <code>$!</code> contains the current exception.
    - <code>$@</code> contains its backtrace.

    == Custom Exceptions

    To provide additional or alternate information,
    a program may create custom exception classes
    that derive from the built-in exception classes.

    A good practice is for a library to create a single "generic" exception class
    (typically a subclass of StandardError or RuntimeError)
    and have its other exception classes derive from that class.
    This allows the user to rescue the generic exception, thus catching all exceptions
    the library may raise even if future versions of the library add new
    exception subclasses.

    For example:

      class MyLibrary
        class Error < ::StandardError
        end

        class WidgetError < Error
        end

        class FrobError < Error
        end

      end

    To handle both MyLibrary::WidgetError and MyLibrary::FrobError the library
    user can rescue MyLibrary::Error.

    == Built-In Exception Classes

    The built-in subclasses of Exception are:

    * NoMemoryError
    * ScriptError
      * LoadError
      * NotImplementedError
      * SyntaxError
    * SecurityError
    * SignalException
      * Interrupt
    * StandardError
      * ArgumentError
        * UncaughtThrowError
      * EncodingError
      * FiberError
      * IOError
        * EOFError
      * IndexError
        * KeyError
        * StopIteration
          * ClosedQueueError
      * LocalJumpError
      * NameError
        * NoMethodError
      * RangeError
        * FloatDomainError
      * RegexpError
      * RuntimeError
        * FrozenError
      * SystemCallError
        * Errno::*
      * ThreadError
      * TypeError
      * ZeroDivisionError
    * SystemExit
    * SystemStackError
    * fatal
FalseClass:
  main: |-
    The global value <code>false</code> is the only instance of class
    FalseClass and represents a logically false value in
    boolean expressions. The class provides operators allowing
    <code>false</code> to participate correctly in logical expressions.
Fiber:
  main: |-
    Fibers are primitives for implementing light weight cooperative
    concurrency in Ruby. Basically they are a means of creating code blocks
    that can be paused and resumed, much like threads. The main difference
    is that they are never preempted and that the scheduling must be done by
    the programmer and not the VM.

    As opposed to other stackless light weight concurrency models, each fiber
    comes with a stack.  This enables the fiber to be paused from deeply
    nested function calls within the fiber block.  See the ruby(1)
    manpage to configure the size of the fiber stack(s).

    When a fiber is created it will not run automatically. Rather it must
    be explicitly asked to run using the Fiber#resume method.
    The code running inside the fiber can give up control by calling
    Fiber.yield in which case it yields control back to caller (the
    caller of the Fiber#resume).

    Upon yielding or termination the Fiber returns the value of the last
    executed expression

    For instance:

      fiber = Fiber.new do
        Fiber.yield 1
        2
      end

      puts fiber.resume
      puts fiber.resume
      puts fiber.resume

    <em>produces</em>

      1
      2
      FiberError: dead fiber called

    The Fiber#resume method accepts an arbitrary number of parameters,
    if it is the first call to #resume then they will be passed as
    block arguments. Otherwise they will be the return value of the
    call to Fiber.yield

    Example:

      fiber = Fiber.new do |first|
        second = Fiber.yield first + 2
      end

      puts fiber.resume 10
      puts fiber.resume 1_000_000
      puts fiber.resume "The fiber will be dead before I can cause trouble"

    <em>produces</em>

      12
      1000000
      FiberError: dead fiber called
FiberError:
  main: |-
    Raised when an invalid operation is attempted on a Fiber, in
    particular when attempting to call/resume a dead fiber,
    attempting to yield from the root fiber, or calling a fiber across
    threads.

       fiber = Fiber.new{}
       fiber.resume #=> nil
       fiber.resume #=> FiberError: dead fiber called
File:
  main: |-
    A File is an abstraction of any file object accessible by the
    program and is closely associated with class IO.  File includes
    the methods of module FileTest as class methods, allowing you to
    write (for example) <code>File.exist?("foo")</code>.

    In the description of File methods,
    <em>permission bits</em> are a platform-specific
    set of bits that indicate permissions of a file. On Unix-based
    systems, permissions are viewed as a set of three octets, for the
    owner, the group, and the rest of the world. For each of these
    entities, permissions may be set to read, write, or execute the
    file:

    The permission bits <code>0644</code> (in octal) would thus be
    interpreted as read/write for owner, and read-only for group and
    other. Higher-order bits may also be used to indicate the type of
    file (plain, directory, pipe, socket, and so on) and various other
    special features. If the permissions are for a directory, the
    meaning of the execute bit changes; when set the directory can be
    searched.

    On non-Posix operating systems, there may be only the ability to
    make a file read-only or read-write. In this case, the remaining
    permission bits will be synthesized to resemble typical values. For
    instance, on Windows NT the default permission bits are
    <code>0644</code>, which means read/write for owner, read-only for
    all others. The only change that can be made is to make the file
    read-only, which is reported as <code>0444</code>.

    Various constants for the methods in File can be found in File::Constants.
File::Constants:
  main: |-
    Document-module: File::Constants

    File::Constants provides file-related constants.  All possible
    file constants are listed in the documentation but they may not all
    be present on your platform.

    If the underlying platform doesn't define a constant the corresponding
    Ruby constant is not defined.

    Your platform documentations (e.g. man open(2)) may describe more
    detailed information.
File::Stat:
  main: |-
    Objects of class File::Stat encapsulate common status information
    for File objects. The information is recorded at the moment the
    File::Stat object is created; changes made to the file after that
    point will not be reflected. File::Stat objects are returned by
    IO#stat, File::stat, File#lstat, and File::lstat. Many of these
    methods return platform-specific values, and not all values are
    meaningful on all systems. See also Kernel#test.
FileTest:
  main: |-
    FileTest implements file test operations similar to those used in
    File::Stat. It exists as a standalone module, and its methods are
    also insinuated into the File class. (Note that this is not done
    by inclusion: the interpreter cheats).
Float:
  main: |-
    Float objects represent inexact real numbers using the native
    architecture's double-precision floating point representation.

    Floating point has a different arithmetic and is an inexact number.
    So you should know its esoteric system. See following:

    - http://docs.sun.com/source/806-3568/ncg_goldberg.html
    - https://github.com/rdp/ruby_tutorials_core/wiki/Ruby-Talk-FAQ#floats_imprecise
    - http://en.wikipedia.org/wiki/Floating_point#Accuracy_problems
FloatDomainError:
  main: |-
    Raised when attempting to convert special float values (in particular
    +Infinity+ or +NaN+) to numerical classes which don't support them.

       Float::INFINITY.to_r   #=> FloatDomainError: Infinity
FrozenError:
  main: |-
    Raised when there is an attempt to modify a frozen object.

       [1, 2, 3].freeze << 4

    <em>raises the exception:</em>

       FrozenError: can't modify frozen Array
GC:
  main: |-
    The GC module provides an interface to Ruby's mark and
    sweep garbage collection mechanism.

    Some of the underlying methods are also available via the ObjectSpace
    module.

    You may obtain information about the operation of the GC through
    GC::Profiler.
GC::Profiler:
  main: |-
    The GC profiler provides access to information on GC runs including time,
    length and object space size.

    Example:

      GC::Profiler.enable

      require 'rdoc/rdoc'

      GC::Profiler.report

      GC::Profiler.disable

    See also GC.count, GC.malloc_allocated_size and GC.malloc_allocations
Hash:
  main: |-
    A Hash is a dictionary-like collection of unique keys and their values.
    Also called associative arrays, they are similar to Arrays, but where an
    Array uses integers as its index, a Hash allows you to use any object
    type.

    Hashes enumerate their values in the order that the corresponding keys
    were inserted.

    A Hash can be easily created by using its implicit form:

      grades = { "Jane Doe" => 10, "Jim Doe" => 6 }

    Hashes allow an alternate syntax for keys that are symbols.
    Instead of

      options = { :font_size => 10, :font_family => "Arial" }

    You could write it as:

      options = { font_size: 10, font_family: "Arial" }

    Each named key is a symbol you can access in hash:

      options[:font_size]  # => 10

    A Hash can also be created through its ::new method:

      grades = Hash.new
      grades["Dorothy Doe"] = 9

    Hashes have a <em>default value</em> that is returned when accessing
    keys that do not exist in the hash. If no default is set +nil+ is used.
    You can set the default value by sending it as an argument to Hash.new:

      grades = Hash.new(0)

    Or by using the #default= method:

      grades = {"Timmy Doe" => 8}
      grades.default = 0

    Accessing a value in a Hash requires using its key:

      puts grades["Jane Doe"] # => 0

    === Common Uses

    Hashes are an easy way to represent data structures, such as

      books         = {}
      books[:matz]  = "The Ruby Programming Language"
      books[:black] = "The Well-Grounded Rubyist"

    Hashes are also commonly used as a way to have named parameters in
    functions. Note that no brackets are used below. If a hash is the last
    argument on a method call, no braces are needed, thus creating a really
    clean interface:

      Person.create(name: "John Doe", age: 27)

      def self.create(params)
        @name = params[:name]
        @age  = params[:age]
      end

    === Hash Keys

    Two objects refer to the same hash key when their <code>hash</code> value
    is identical and the two objects are <code>eql?</code> to each other.

    A user-defined class may be used as a hash key if the <code>hash</code>
    and <code>eql?</code> methods are overridden to provide meaningful
    behavior.  By default, separate instances refer to separate hash keys.

    A typical implementation of <code>hash</code> is based on the
    object's data while <code>eql?</code> is usually aliased to the overridden
    <code>==</code> method:

      class Book
        attr_reader :author, :title

        def initialize(author, title)
          @author = author
          @title = title
        end

        def ==(other)
          self.class === other and
            other.author == @author and
            other.title == @title
        end

        alias eql? ==

        def hash
          @author.hash ^ @title.hash # XOR
        end
      end

      book1 = Book.new 'matz', 'Ruby in a Nutshell'
      book2 = Book.new 'matz', 'Ruby in a Nutshell'

      reviews = {}

      reviews[book1] = 'Great reference!'
      reviews[book2] = 'Nice and compact!'

      reviews.length #=> 1

    See also Object#hash and Object#eql?
IO:
  main: |-
    The IO class is the basis for all input and output in Ruby.
    An I/O stream may be <em>duplexed</em> (that is, bidirectional), and
    so may use more than one native operating system stream.

    Many of the examples in this section use the File class, the only standard
    subclass of IO. The two classes are closely associated.  Like the File
    class, the Socket library subclasses from IO (such as TCPSocket or
    UDPSocket).

    The Kernel#open method can create an IO (or File) object for these types
    of arguments:

    * A plain string represents a filename suitable for the underlying
      operating system.

    * A string starting with <code>"|"</code> indicates a subprocess.
      The remainder of the string following the <code>"|"</code> is
      invoked as a process with appropriate input/output channels
      connected to it.

    * A string equal to <code>"|-"</code> will create another Ruby
      instance as a subprocess.

    The IO may be opened with different file modes (read-only, write-only) and
    encodings for proper conversion.  See IO.new for these options.  See
    Kernel#open for details of the various command formats described above.

    IO.popen, the Open3 library, or  Process#spawn may also be used to
    communicate with subprocesses through an IO.

    Ruby will convert pathnames between different operating system
    conventions if possible.  For instance, on a Windows system the
    filename <code>"/gumby/ruby/test.rb"</code> will be opened as
    <code>"\gumby\ruby\test.rb"</code>.  When specifying a Windows-style
    filename in a Ruby string, remember to escape the backslashes:

      "C:\\gumby\\ruby\\test.rb"

    Our examples here will use the Unix-style forward slashes;
    File::ALT_SEPARATOR can be used to get the platform-specific separator
    character.

    The global constant ARGF (also accessible as <code>$<</code>) provides an
    IO-like stream which allows access to all files mentioned on the
    command line (or STDIN if no files are mentioned). ARGF#path and its alias
    ARGF#filename are provided to access the name of the file currently being
    read.

    == io/console

    The io/console extension provides methods for interacting with the
    console.  The console can be accessed from IO.console or the standard
    input/output/error IO objects.

    Requiring io/console adds the following methods:

    * IO::console
    * IO#raw
    * IO#raw!
    * IO#cooked
    * IO#cooked!
    * IO#getch
    * IO#echo=
    * IO#echo?
    * IO#noecho
    * IO#winsize
    * IO#winsize=
    * IO#iflush
    * IO#ioflush
    * IO#oflush

    Example:

      require 'io/console'
      rows, columns = $stdout.winsize
      puts "Your screen is #{columns} wide and #{rows} tall"
IO::EAGAINWaitReadable:
  main: 'exception to wait for reading by EAGAIN. see IO.select.   '
IO::EAGAINWaitWritable:
  main: 'exception to wait for writing by EAGAIN. see IO.select.   '
IO::EINPROGRESSWaitReadable:
  main: 'exception to wait for reading by EINPROGRESS. see IO.select.   '
IO::EINPROGRESSWaitWritable:
  main: 'exception to wait for writing by EINPROGRESS. see IO.select.   '
IO::EWOULDBLOCKWaitReadable:
  main: 'exception to wait for reading by EWOULDBLOCK. see IO.select.   '
IO::EWOULDBLOCKWaitWritable:
  main: 'exception to wait for writing by EWOULDBLOCK. see IO.select.   '
IO::WaitReadable:
  main: 'exception to wait for reading. see IO.select.   '
IO::WaitWritable:
  main: 'exception to wait for writing. see IO.select.   '
IOError:
  main: |-
    Raised when an IO operation fails.

       File.open("/etc/hosts") {|f| f << "example"}
         #=> IOError: not opened for writing

       File.open("/etc/hosts") {|f| f.close; f.read }
         #=> IOError: closed stream

    Note that some IO failures raise <code>SystemCallError</code>s
    and these are not subclasses of IOError:

       File.open("does/not/exist")
         #=> Errno::ENOENT: No such file or directory - does/not/exist
IndexError:
  main: |-
    Raised when the given index is invalid.

       a = [:foo, :bar]
       a.fetch(0)   #=> :foo
       a[4]         #=> nil
       a.fetch(4)   #=> IndexError: index 4 outside of array bounds: -2...2
Integer:
  main: |-
    Holds Integer values.  You cannot add a singleton method to an
    Integer object, any attempt to do so will raise a TypeError.
Interrupt:
  main: |-
    Raised when the interrupt signal is received, typically because the
    user has pressed Control-C (on most posix platforms). As such, it is a
    subclass of +SignalException+.

       begin
         puts "Press ctrl-C when you get bored"
         loop {}
       rescue Interrupt => e
         puts "Note: You will typically use Signal.trap instead."
       end

    <em>produces:</em>

       Press ctrl-C when you get bored

    <em>then waits until it is interrupted with Control-C and then prints:</em>

       Note: You will typically use Signal.trap instead.
Kernel:
  main: |-
    The Kernel module is included by class Object, so its methods are
    available in every Ruby object.

    The Kernel instance methods are documented in class Object while the
    module methods are documented here.  These methods are called without a
    receiver and thus can be called in functional form:

      sprintf "%.1f", 1.234 #=> "1.2"
  methods:
    Complex: |2-

      Returns x+i*y;

         Complex(1, 2)    #=> (1+2i)
         Complex('1+2i')  #=> (1+2i)
         Complex(nil)     #=> TypeError
         Complex(1, nil)  #=> TypeError

         Complex(1, nil, exception: false)  #=> nil
         Complex('1+2', exception: false)   #=> nil

      Syntax of string form:

        string form = extra spaces , complex , extra spaces ;
        complex = real part | [ sign ] , imaginary part
                | real part , sign , imaginary part
                | rational , "@" , rational ;
        real part = rational ;
        imaginary part = imaginary unit | unsigned rational , imaginary unit ;
        rational = [ sign ] , unsigned rational ;
        unsigned rational = numerator | numerator , "/" , denominator ;
        numerator = integer part | fractional part | integer part , fractional part ;
        denominator = digits ;
        integer part = digits ;
        fractional part = "." , digits , [ ( "e" | "E" ) , [ sign ] , digits ] ;
        imaginary unit = "i" | "I" | "j" | "J" ;
        sign = "-" | "+" ;
        digits = digit , { digit | "_" , digit };
        digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;
        extra spaces = ? \s* ? ;

      See String#to_c.
    callcc: |2-

      Generates a Continuation object, which it passes to
      the associated block. You need to <code>require
      'continuation'</code> before using this method. Performing a
      <em>cont</em><code>.call</code> will cause the #callcc
      to return (as will falling through the end of the block). The
      value returned by the #callcc is the value of the
      block, or the value passed to <em>cont</em><code>.call</code>. See
      class Continuation for more details. Also see
      Kernel#throw for an alternative mechanism for
      unwinding a call stack.
    raise: |2-

      With no arguments, raises the exception in <code>$!</code> or raises
      a RuntimeError if <code>$!</code> is +nil+.  With a single +String+
      argument, raises a +RuntimeError+ with the string as a message. Otherwise,
      the first parameter should be an +Exception+ class (or another
      object that returns an +Exception+ object when sent an +exception+
      message).  The optional second parameter sets the message associated with
      the exception (accessible via Exception#message), and the third parameter
      is an array of callback information (accessible via Exception#backtrace).
      The +cause+ of the generated exception (accessible via Exception#cause)
      is automatically set to the "current" exception (<code>$!</code>), if any.
      An alternative value, either an +Exception+ object or +nil+, can be
      specified via the +:cause+ argument.

      Exceptions are caught by the +rescue+ clause of
      <code>begin...end</code> blocks.

         raise "Failed to create socket"
         raise ArgumentError, "No parameters", caller
    fail: |2-

      With no arguments, raises the exception in <code>$!</code> or raises
      a RuntimeError if <code>$!</code> is +nil+.  With a single +String+
      argument, raises a +RuntimeError+ with the string as a message. Otherwise,
      the first parameter should be an +Exception+ class (or another
      object that returns an +Exception+ object when sent an +exception+
      message).  The optional second parameter sets the message associated with
      the exception (accessible via Exception#message), and the third parameter
      is an array of callback information (accessible via Exception#backtrace).
      The +cause+ of the generated exception (accessible via Exception#cause)
      is automatically set to the "current" exception (<code>$!</code>), if any.
      An alternative value, either an +Exception+ object or +nil+, can be
      specified via the +:cause+ argument.

      Exceptions are caught by the +rescue+ clause of
      <code>begin...end</code> blocks.

         raise "Failed to create socket"
         raise ArgumentError, "No parameters", caller
    global_variables: |2-

      Returns an array of the names of global variables.

         global_variables.grep /std/   #=> [:$stdin, :$stdout, :$stderr]
    __method__: |2-

      Returns the name at the definition of the current method as a
      Symbol.
      If called outside of a method, it returns <code>nil</code>.
    __callee__: |2-

      Returns the called name of the current method as a Symbol.
      If called outside of a method, it returns <code>nil</code>.
    __dir__: |2-

      Returns the canonicalized absolute path of the directory of the file from
      which this method is called. It means symlinks in the path is resolved.
      If <code>__FILE__</code> is <code>nil</code>, it returns <code>nil</code>.
      The return value equals to <code>File.dirname(File.realpath(__FILE__))</code>.
    trace_var: |2-

      Controls tracing of assignments to global variables. The parameter
      +symbol+ identifies the variable (as either a string name or a
      symbol identifier). _cmd_ (which may be a string or a
      +Proc+ object) or block is executed whenever the variable
      is assigned. The block or +Proc+ object receives the
      variable's new value as a parameter. Also see
      Kernel::untrace_var.

         trace_var :$_, proc {|v| puts "$_ is now '#{v}'" }
         $_ = "hello"
         $_ = ' there'

      <em>produces:</em>

         $_ is now 'hello'
         $_ is now ' there'
    untrace_var: |2-

      Removes tracing for the specified command on the given global
      variable and returns +nil+. If no command is specified,
      removes all tracing for that variable and returns an array
      containing the commands actually removed.
    at_exit: |2-

      Converts _block_ to a +Proc+ object (and therefore
      binds it at the point of call) and registers it for execution when
      the program exits. If multiple handlers are registered, they are
      executed in reverse order of registration.

         def do_at_exit(str1)
           at_exit { print str1 }
         end
         at_exit { puts "cruel world" }
         do_at_exit("goodbye ")
         exit

      <em>produces:</em>

         goodbye cruel world
    test: |2-

      Uses the character +cmd+ to perform various tests on +file1+ (first
      table below) or on +file1+ and +file2+ (second table).

      File tests on a single file:

        Cmd    Returns   Meaning
        "A"  | Time    | Last access time for file1
        "b"  | boolean | True if file1 is a block device
        "c"  | boolean | True if file1 is a character device
        "C"  | Time    | Last change time for file1
        "d"  | boolean | True if file1 exists and is a directory
        "e"  | boolean | True if file1 exists
        "f"  | boolean | True if file1 exists and is a regular file
        "g"  | boolean | True if file1 has the \CF{setgid} bit
             |         | set (false under NT)
        "G"  | boolean | True if file1 exists and has a group
             |         | ownership equal to the caller's group
        "k"  | boolean | True if file1 exists and has the sticky bit set
        "l"  | boolean | True if file1 exists and is a symbolic link
        "M"  | Time    | Last modification time for file1
        "o"  | boolean | True if file1 exists and is owned by
             |         | the caller's effective uid
        "O"  | boolean | True if file1 exists and is owned by
             |         | the caller's real uid
        "p"  | boolean | True if file1 exists and is a fifo
        "r"  | boolean | True if file1 is readable by the effective
             |         | uid/gid of the caller
        "R"  | boolean | True if file is readable by the real
             |         | uid/gid of the caller
        "s"  | int/nil | If file1 has nonzero size, return the size,
             |         | otherwise return nil
        "S"  | boolean | True if file1 exists and is a socket
        "u"  | boolean | True if file1 has the setuid bit set
        "w"  | boolean | True if file1 exists and is writable by
             |         | the effective uid/gid
        "W"  | boolean | True if file1 exists and is writable by
             |         | the real uid/gid
        "x"  | boolean | True if file1 exists and is executable by
             |         | the effective uid/gid
        "X"  | boolean | True if file1 exists and is executable by
             |         | the real uid/gid
        "z"  | boolean | True if file1 exists and has a zero length

      Tests that take two files:

        "-"  | boolean | True if file1 and file2 are identical
        "="  | boolean | True if the modification times of file1
             |         | and file2 are equal
        "<"  | boolean | True if the modification time of file1
             |         | is prior to that of file2
        ">"  | boolean | True if the modification time of file1
             |         | is after that of file2
    syscall: |2-

      Calls the operating system function identified by _num_ and
      returns the result of the function or raises SystemCallError if
      it failed.

      Arguments for the function can follow _num_. They must be either
      +String+ objects or +Integer+ objects. A +String+ object is passed
      as a pointer to the byte sequence. An +Integer+ object is passed
      as an integer whose bit size is same as a pointer.
      Up to nine parameters may be passed.

      The function identified by _num_ is system
      dependent. On some Unix systems, the numbers may be obtained from a
      header file called <code>syscall.h</code>.

         syscall 4, 1, "hello\n", 6   # '4' is write(2) on our box

      <em>produces:</em>

         hello

      Calling +syscall+ on a platform which does not have any way to
      an arbitrary system function just fails with NotImplementedError.

      *Note:*
      +syscall+ is essentially unsafe and unportable.
      Feel free to shoot your foot.
      The DL (Fiddle) library is preferred for safer and a bit
      more portable programming.
    open: |2-

      Creates an IO object connected to the given stream, file, or subprocess.

      If +path+ does not start with a pipe character (<code>|</code>), treat it
      as the name of a file to open using the specified mode (defaulting to
      "r").

      The +mode+ is either a string or an integer.  If it is an integer, it
      must be bitwise-or of open(2) flags, such as File::RDWR or File::EXCL.  If
      it is a string, it is either "fmode", "fmode:ext_enc", or
      "fmode:ext_enc:int_enc".

      See the documentation of IO.new for full documentation of the +mode+ string
      directives.

      If a file is being created, its initial permissions may be set using the
      +perm+ parameter.  See File.new and the open(2) and chmod(2) man pages for
      a description of permissions.

      If a block is specified, it will be invoked with the IO object as a
      parameter, and the IO will be automatically closed when the block
      terminates.  The call returns the value of the block.

      If +path+ starts with a pipe character (<code>"|"</code>), a subprocess is
      created, connected to the caller by a pair of pipes.  The returned IO
      object may be used to write to the standard input and read from the
      standard output of this subprocess.

      If the command following the pipe is a single minus sign
      (<code>"|-"</code>), Ruby forks, and this subprocess is connected to the
      parent.  If the command is not <code>"-"</code>, the subprocess runs the
      command.

      When the subprocess is Ruby (opened via <code>"|-"</code>), the +open+
      call returns +nil+.  If a block is associated with the open call, that
      block will run twice --- once in the parent and once in the child.

      The block parameter will be an IO object in the parent and +nil+ in the
      child. The parent's +IO+ object will be connected to the child's $stdin
      and $stdout.  The subprocess will be terminated at the end of the block.

      === Examples

      Reading from "testfile":

         open("testfile") do |f|
           print f.gets
         end

      Produces:

         This is line one

      Open a subprocess and read its output:

         cmd = open("|date")
         print cmd.gets
         cmd.close

      Produces:

         Wed Apr  9 08:56:31 CDT 2003

      Open a subprocess running the same Ruby program:

         f = open("|-", "w+")
         if f.nil?
           puts "in Child"
           exit
         else
           puts "Got: #{f.gets}"
         end

      Produces:

         Got: in Child

      Open a subprocess using a block to receive the IO object:

         open "|-" do |f|
           if f then
             # parent process
             puts "Got: #{f.gets}"
           else
             # child process
             puts "in Child"
           end
         end

      Produces:

         Got: in Child
    printf: |2-

      Equivalent to:
         io.write(sprintf(string, obj, ...))
      or
         $stdout.write(sprintf(string, obj, ...))
    print: |2-

      Prints each object in turn to <code>$stdout</code>. If the output
      field separator (<code>$,</code>) is not +nil+, its
      contents will appear between each field. If the output record
      separator (<code>$\\</code>) is not +nil+, it will be
      appended to the output. If no arguments are given, prints
      <code>$_</code>. Objects that aren't strings will be converted by
      calling their <code>to_s</code> method.

         print "cat", [1,2,3], 99, "\n"
         $, = ", "
         $\ = "\n"
         print "cat", [1,2,3], 99

      <em>produces:</em>

         cat12399
         cat, 1, 2, 3, 99
    putc: |2-

      Equivalent to:

        $stdout.putc(int)

      Refer to the documentation for IO#putc for important information regarding
      multi-byte characters.
    puts: |2-

      Equivalent to

          $stdout.puts(obj, ...)
    gets: |2-

      Returns (and assigns to <code>$_</code>) the next line from the list
      of files in +ARGV+ (or <code>$*</code>), or from standard input if
      no files are present on the command line. Returns +nil+ at end of
      file. The optional argument specifies the record separator. The
      separator is included with the contents of each record. A separator
      of +nil+ reads the entire contents, and a zero-length separator
      reads the input one paragraph at a time, where paragraphs are
      divided by two consecutive newlines.  If the first argument is an
      integer, or optional second argument is given, the returning string
      would not be longer than the given value in bytes.  If multiple
      filenames are present in +ARGV+, <code>gets(nil)</code> will read
      the contents one file at a time.

         ARGV << "testfile"
         print while gets

      <em>produces:</em>

         This is line one
         This is line two
         This is line three
         And so on...

      The style of programming using <code>$_</code> as an implicit
      parameter is gradually losing favor in the Ruby community.
    readline: |2-

      Equivalent to Kernel::gets, except
      +readline+ raises +EOFError+ at end of file.
    select: |2-

      Calls select(2) system call.
      It monitors given arrays of IO objects, waits until one or more of
      IO objects are ready for reading, are ready for writing, and have
      pending exceptions respectively, and returns an array that contains
      arrays of those IO objects.  It will return +nil+ if optional
      <i>timeout</i> value is given and no IO object is ready in
      <i>timeout</i> seconds.

      IO.select peeks the buffer of IO objects for testing readability.
      If the IO buffer is not empty, IO.select immediately notifies
      readability.  This "peek" only happens for IO objects.  It does not
      happen for IO-like objects such as OpenSSL::SSL::SSLSocket.

      The best way to use IO.select is invoking it after nonblocking
      methods such as #read_nonblock, #write_nonblock, etc.  The methods
      raise an exception which is extended by IO::WaitReadable or
      IO::WaitWritable.  The modules notify how the caller should wait
      with IO.select.  If IO::WaitReadable is raised, the caller should
      wait for reading.  If IO::WaitWritable is raised, the caller should
      wait for writing.

      So, blocking read (#readpartial) can be emulated using
      #read_nonblock and IO.select as follows:

        begin
          result = io_like.read_nonblock(maxlen)
        rescue IO::WaitReadable
          IO.select([io_like])
          retry
        rescue IO::WaitWritable
          IO.select(nil, [io_like])
          retry
        end

      Especially, the combination of nonblocking methods and IO.select is
      preferred for IO like objects such as OpenSSL::SSL::SSLSocket.  It
      has #to_io method to return underlying IO object.  IO.select calls
      #to_io to obtain the file descriptor to wait.

      This means that readability notified by IO.select doesn't mean
      readability from OpenSSL::SSL::SSLSocket object.

      The most likely situation is that OpenSSL::SSL::SSLSocket buffers
      some data.  IO.select doesn't see the buffer.  So IO.select can
      block when OpenSSL::SSL::SSLSocket#readpartial doesn't block.

      However, several more complicated situations exist.

      SSL is a protocol which is sequence of records.
      The record consists of multiple bytes.
      So, the remote side of SSL sends a partial record, IO.select
      notifies readability but OpenSSL::SSL::SSLSocket cannot decrypt a
      byte and OpenSSL::SSL::SSLSocket#readpartial will block.

      Also, the remote side can request SSL renegotiation which forces
      the local SSL engine to write some data.
      This means OpenSSL::SSL::SSLSocket#readpartial may invoke #write
      system call and it can block.
      In such a situation, OpenSSL::SSL::SSLSocket#read_nonblock raises
      IO::WaitWritable instead of blocking.
      So, the caller should wait for ready for writability as above
      example.

      The combination of nonblocking methods and IO.select is also useful
      for streams such as tty, pipe socket socket when multiple processes
      read from a stream.

      Finally, Linux kernel developers don't guarantee that
      readability of select(2) means readability of following read(2) even
      for a single process.
      See select(2) manual on GNU/Linux system.

      Invoking IO.select before IO#readpartial works well as usual.
      However it is not the best way to use IO.select.

      The writability notified by select(2) doesn't show
      how many bytes are writable.
      IO#write method blocks until given whole string is written.
      So, <code>IO#write(two or more bytes)</code> can block after
      writability is notified by IO.select.  IO#write_nonblock is required
      to avoid the blocking.

      Blocking write (#write) can be emulated using #write_nonblock and
      IO.select as follows: IO::WaitReadable should also be rescued for
      SSL renegotiation in OpenSSL::SSL::SSLSocket.

        while 0 < string.bytesize
          begin
            written = io_like.write_nonblock(string)
          rescue IO::WaitReadable
            IO.select([io_like])
            retry
          rescue IO::WaitWritable
            IO.select(nil, [io_like])
            retry
          end
          string = string.byteslice(written..-1)
        end

      === Parameters
      read_array:: an array of IO objects that wait until ready for read
      write_array:: an array of IO objects that wait until ready for write
      error_array:: an array of IO objects that wait for exceptions
      timeout:: a numeric value in second

      === Example

          rp, wp = IO.pipe
          mesg = "ping "
          100.times {
            # IO.select follows IO#read.  Not the best way to use IO.select.
            rs, ws, = IO.select([rp], [wp])
            if r = rs[0]
              ret = r.read(5)
              print ret
              case ret
              when /ping/
                mesg = "pong\n"
              when /pong/
                mesg = "ping "
              end
            end
            if w = ws[0]
              w.write(mesg)
            end
          }

      <em>produces:</em>

          ping pong
          ping pong
          ping pong
          (snipped)
          ping
    readlines: |2-

      Returns an array containing the lines returned by calling
      <code>Kernel.gets(<i>sep</i>)</code> until the end of file.
    "`": |2-

      Returns the standard output of running _cmd_ in a subshell.
      The built-in syntax <code>%x{...}</code> uses
      this method. Sets <code>$?</code> to the process status.

         `date`                   #=> "Wed Apr  9 08:56:30 CDT 2003\n"
         `ls testdir`.split[1]    #=> "main.rb"
         `echo oops && exit 99`   #=> "oops\n"
         $?.exitstatus            #=> 99
    p: |2-

      For each object, directly writes _obj_.+inspect+ followed by a
      newline to the program's standard output.

         S = Struct.new(:name, :state)
         s = S['dave', 'TX']
         p s

      <em>produces:</em>

         #<S name="dave", state="TX">
    load: |2-

      Loads and executes the Ruby
      program in the file _filename_. If the filename does not
      resolve to an absolute path, the file is searched for in the library
      directories listed in <code>$:</code>. If the optional _wrap_
      parameter is +true+, the loaded script will be executed
      under an anonymous module, protecting the calling program's global
      namespace. In no circumstance will any local variables in the loaded
      file be propagated to the loading environment.
    require: |2-

      Loads the given +name+, returning +true+ if successful and +false+ if the
      feature is already loaded.

      If the filename does not resolve to an absolute path, it will be searched
      for in the directories listed in <code>$LOAD_PATH</code> (<code>$:</code>).

      If the filename has the extension ".rb", it is loaded as a source file; if
      the extension is ".so", ".o", or ".dll", or the default shared library
      extension on the current platform, Ruby loads the shared library as a
      Ruby extension.  Otherwise, Ruby tries adding ".rb", ".so", and so on
      to the name until found.  If the file named cannot be found, a LoadError
      will be raised.

      For Ruby extensions the filename given may use any shared library
      extension.  For example, on Linux the socket extension is "socket.so" and
      <code>require 'socket.dll'</code> will load the socket extension.

      The absolute path of the loaded file is added to
      <code>$LOADED_FEATURES</code> (<code>$"</code>).  A file will not be
      loaded again if its path already appears in <code>$"</code>.  For example,
      <code>require 'a'; require './a'</code> will not load <code>a.rb</code>
      again.

        require "my-library.rb"
        require "db-driver"

      Any constants or globals within the loaded source file will be available
      in the calling program's global namespace. However, local variables will
      not be propagated to the loading environment.
    require_relative: |2-

      Ruby tries to load the library named _string_ relative to the requiring
      file's path.  If the file's path cannot be determined a LoadError is raised.
      If a file is loaded +true+ is returned and false otherwise.
    autoload: |2-

      Registers _filename_ to be loaded (using Kernel::require)
      the first time that _module_ (which may be a String or
      a symbol) is accessed.

         autoload(:MyModule, "/usr/local/lib/modules/my_module.rb")
    autoload?: |2-

      Returns _filename_ to be loaded if _name_ is registered as
      +autoload+.

         autoload(:B, "b")
         autoload?(:B)            #=> "b"
    sprintf: |2-

      Returns the string resulting from applying <i>format_string</i> to
      any additional arguments.  Within the format string, any characters
      other than format sequences are copied to the result.

      The syntax of a format sequence is as follows.

        %[flags][width][.precision]type

      A format
      sequence consists of a percent sign, followed by optional flags,
      width, and precision indicators, then terminated with a field type
      character.  The field type controls how the corresponding
      <code>sprintf</code> argument is to be interpreted, while the flags
      modify that interpretation.

      The field type characters are:

          Field |  Integer Format
          ------+--------------------------------------------------------------
            b   | Convert argument as a binary number.
                | Negative numbers will be displayed as a two's complement
                | prefixed with `..1'.
            B   | Equivalent to `b', but uses an uppercase 0B for prefix
                | in the alternative format by #.
            d   | Convert argument as a decimal number.
            i   | Identical to `d'.
            o   | Convert argument as an octal number.
                | Negative numbers will be displayed as a two's complement
                | prefixed with `..7'.
            u   | Identical to `d'.
            x   | Convert argument as a hexadecimal number.
                | Negative numbers will be displayed as a two's complement
                | prefixed with `..f' (representing an infinite string of
                | leading 'ff's).
            X   | Equivalent to `x', but uses uppercase letters.

          Field |  Float Format
          ------+--------------------------------------------------------------
            e   | Convert floating point argument into exponential notation
                | with one digit before the decimal point as [-]d.dddddde[+-]dd.
                | The precision specifies the number of digits after the decimal
                | point (defaulting to six).
            E   | Equivalent to `e', but uses an uppercase E to indicate
                | the exponent.
            f   | Convert floating point argument as [-]ddd.dddddd,
                | where the precision specifies the number of digits after
                | the decimal point.
            g   | Convert a floating point number using exponential form
                | if the exponent is less than -4 or greater than or
                | equal to the precision, or in dd.dddd form otherwise.
                | The precision specifies the number of significant digits.
            G   | Equivalent to `g', but use an uppercase `E' in exponent form.
            a   | Convert floating point argument as [-]0xh.hhhhp[+-]dd,
                | which is consisted from optional sign, "0x", fraction part
                | as hexadecimal, "p", and exponential part as decimal.
            A   | Equivalent to `a', but use uppercase `X' and `P'.

          Field |  Other Format
          ------+--------------------------------------------------------------
            c   | Argument is the numeric code for a single character or
                | a single character string itself.
            p   | The valuing of argument.inspect.
            s   | Argument is a string to be substituted.  If the format
                | sequence contains a precision, at most that many characters
                | will be copied.
            %   | A percent sign itself will be displayed.  No argument taken.

      The flags modifies the behavior of the formats.
      The flag characters are:

        Flag     | Applies to    | Meaning
        ---------+---------------+-----------------------------------------
        space    | bBdiouxX      | Leave a space at the start of
                 | aAeEfgG       | non-negative numbers.
                 | (numeric fmt) | For `o', `x', `X', `b' and `B', use
                 |               | a minus sign with absolute value for
                 |               | negative values.
        ---------+---------------+-----------------------------------------
        (digit)$ | all           | Specifies the absolute argument number
                 |               | for this field.  Absolute and relative
                 |               | argument numbers cannot be mixed in a
                 |               | sprintf string.
        ---------+---------------+-----------------------------------------
         #       | bBoxX         | Use an alternative format.
                 | aAeEfgG       | For the conversions `o', increase the precision
                 |               | until the first digit will be `0' if
                 |               | it is not formatted as complements.
                 |               | For the conversions `x', `X', `b' and `B'
                 |               | on non-zero, prefix the result with ``0x'',
                 |               | ``0X'', ``0b'' and ``0B'', respectively.
                 |               | For `a', `A', `e', `E', `f', `g', and 'G',
                 |               | force a decimal point to be added,
                 |               | even if no digits follow.
                 |               | For `g' and 'G', do not remove trailing zeros.
        ---------+---------------+-----------------------------------------
        +        | bBdiouxX      | Add a leading plus sign to non-negative
                 | aAeEfgG       | numbers.
                 | (numeric fmt) | For `o', `x', `X', `b' and `B', use
                 |               | a minus sign with absolute value for
                 |               | negative values.
        ---------+---------------+-----------------------------------------
        -        | all           | Left-justify the result of this conversion.
        ---------+---------------+-----------------------------------------
        0 (zero) | bBdiouxX      | Pad with zeros, not spaces.
                 | aAeEfgG       | For `o', `x', `X', `b' and `B', radix-1
                 | (numeric fmt) | is used for negative numbers formatted as
                 |               | complements.
        ---------+---------------+-----------------------------------------
        *        | all           | Use the next argument as the field width.
                 |               | If negative, left-justify the result. If the
                 |               | asterisk is followed by a number and a dollar
                 |               | sign, use the indicated argument as the width.

      Examples of flags:

       # `+' and space flag specifies the sign of non-negative numbers.
       sprintf("%d", 123)  #=> "123"
       sprintf("%+d", 123) #=> "+123"
       sprintf("% d", 123) #=> " 123"

       # `#' flag for `o' increases number of digits to show `0'.
       # `+' and space flag changes format of negative numbers.
       sprintf("%o", 123)   #=> "173"
       sprintf("%#o", 123)  #=> "0173"
       sprintf("%+o", -123) #=> "-173"
       sprintf("%o", -123)  #=> "..7605"
       sprintf("%#o", -123) #=> "..7605"

       # `#' flag for `x' add a prefix `0x' for non-zero numbers.
       # `+' and space flag disables complements for negative numbers.
       sprintf("%x", 123)   #=> "7b"
       sprintf("%#x", 123)  #=> "0x7b"
       sprintf("%+x", -123) #=> "-7b"
       sprintf("%x", -123)  #=> "..f85"
       sprintf("%#x", -123) #=> "0x..f85"
       sprintf("%#x", 0)    #=> "0"

       # `#' for `X' uses the prefix `0X'.
       sprintf("%X", 123)  #=> "7B"
       sprintf("%#X", 123) #=> "0X7B"

       # `#' flag for `b' add a prefix `0b' for non-zero numbers.
       # `+' and space flag disables complements for negative numbers.
       sprintf("%b", 123)   #=> "1111011"
       sprintf("%#b", 123)  #=> "0b1111011"
       sprintf("%+b", -123) #=> "-1111011"
       sprintf("%b", -123)  #=> "..10000101"
       sprintf("%#b", -123) #=> "0b..10000101"
       sprintf("%#b", 0)    #=> "0"

       # `#' for `B' uses the prefix `0B'.
       sprintf("%B", 123)  #=> "1111011"
       sprintf("%#B", 123) #=> "0B1111011"

       # `#' for `e' forces to show the decimal point.
       sprintf("%.0e", 1)  #=> "1e+00"
       sprintf("%#.0e", 1) #=> "1.e+00"

       # `#' for `f' forces to show the decimal point.
       sprintf("%.0f", 1234)  #=> "1234"
       sprintf("%#.0f", 1234) #=> "1234."

       # `#' for `g' forces to show the decimal point.
       # It also disables stripping lowest zeros.
       sprintf("%g", 123.4)   #=> "123.4"
       sprintf("%#g", 123.4)  #=> "123.400"
       sprintf("%g", 123456)  #=> "123456"
       sprintf("%#g", 123456) #=> "123456."

      The field width is an optional integer, followed optionally by a
      period and a precision.  The width specifies the minimum number of
      characters that will be written to the result for this field.

      Examples of width:

       # padding is done by spaces,       width=20
       # 0 or radix-1.             <------------------>
       sprintf("%20d", 123)   #=> "                 123"
       sprintf("%+20d", 123)  #=> "                +123"
       sprintf("%020d", 123)  #=> "00000000000000000123"
       sprintf("%+020d", 123) #=> "+0000000000000000123"
       sprintf("% 020d", 123) #=> " 0000000000000000123"
       sprintf("%-20d", 123)  #=> "123                 "
       sprintf("%-+20d", 123) #=> "+123                "
       sprintf("%- 20d", 123) #=> " 123                "
       sprintf("%020x", -123) #=> "..ffffffffffffffff85"

      For
      numeric fields, the precision controls the number of decimal places
      displayed.  For string fields, the precision determines the maximum
      number of characters to be copied from the string.  (Thus, the format
      sequence <code>%10.10s</code> will always contribute exactly ten
      characters to the result.)

      Examples of precisions:

       # precision for `d', 'o', 'x' and 'b' is
       # minimum number of digits               <------>
       sprintf("%20.8d", 123)  #=> "            00000123"
       sprintf("%20.8o", 123)  #=> "            00000173"
       sprintf("%20.8x", 123)  #=> "            0000007b"
       sprintf("%20.8b", 123)  #=> "            01111011"
       sprintf("%20.8d", -123) #=> "           -00000123"
       sprintf("%20.8o", -123) #=> "            ..777605"
       sprintf("%20.8x", -123) #=> "            ..ffff85"
       sprintf("%20.8b", -11)  #=> "            ..110101"

       # "0x" and "0b" for `#x' and `#b' is not counted for
       # precision but "0" for `#o' is counted.  <------>
       sprintf("%#20.8d", 123)  #=> "            00000123"
       sprintf("%#20.8o", 123)  #=> "            00000173"
       sprintf("%#20.8x", 123)  #=> "          0x0000007b"
       sprintf("%#20.8b", 123)  #=> "          0b01111011"
       sprintf("%#20.8d", -123) #=> "           -00000123"
       sprintf("%#20.8o", -123) #=> "            ..777605"
       sprintf("%#20.8x", -123) #=> "          0x..ffff85"
       sprintf("%#20.8b", -11)  #=> "          0b..110101"

       # precision for `e' is number of
       # digits after the decimal point           <------>
       sprintf("%20.8e", 1234.56789) #=> "      1.23456789e+03"

       # precision for `f' is number of
       # digits after the decimal point               <------>
       sprintf("%20.8f", 1234.56789) #=> "       1234.56789000"

       # precision for `g' is number of
       # significant digits                          <------->
       sprintf("%20.8g", 1234.56789) #=> "           1234.5679"

       #                                         <------->
       sprintf("%20.8g", 123456789)  #=> "       1.2345679e+08"

       # precision for `s' is
       # maximum number of characters                    <------>
       sprintf("%20.8s", "string test") #=> "            string t"

      Examples:

         sprintf("%d %04x", 123, 123)               #=> "123 007b"
         sprintf("%08b '%4s'", 123, 123)            #=> "01111011 ' 123'"
         sprintf("%1$*2$s %2$d %1$s", "hello", 8)   #=> "   hello 8 hello"
         sprintf("%1$*2$s %2$d", "hello", -8)       #=> "hello    -8"
         sprintf("%+g:% g:%-g", 1.23, 1.23, 1.23)   #=> "+1.23: 1.23:1.23"
         sprintf("%u", -123)                        #=> "-123"

      For more complex formatting, Ruby supports a reference by name.
      %<name>s style uses format style, but %{name} style doesn't.

      Examples:
        sprintf("%<foo>d : %<bar>f", { :foo => 1, :bar => 2 })
          #=> 1 : 2.000000
        sprintf("%{foo}f", { :foo => 1 })
          # => "1f"
    format: |2-

      Returns the string resulting from applying <i>format_string</i> to
      any additional arguments.  Within the format string, any characters
      other than format sequences are copied to the result.

      The syntax of a format sequence is as follows.

        %[flags][width][.precision]type

      A format
      sequence consists of a percent sign, followed by optional flags,
      width, and precision indicators, then terminated with a field type
      character.  The field type controls how the corresponding
      <code>sprintf</code> argument is to be interpreted, while the flags
      modify that interpretation.

      The field type characters are:

          Field |  Integer Format
          ------+--------------------------------------------------------------
            b   | Convert argument as a binary number.
                | Negative numbers will be displayed as a two's complement
                | prefixed with `..1'.
            B   | Equivalent to `b', but uses an uppercase 0B for prefix
                | in the alternative format by #.
            d   | Convert argument as a decimal number.
            i   | Identical to `d'.
            o   | Convert argument as an octal number.
                | Negative numbers will be displayed as a two's complement
                | prefixed with `..7'.
            u   | Identical to `d'.
            x   | Convert argument as a hexadecimal number.
                | Negative numbers will be displayed as a two's complement
                | prefixed with `..f' (representing an infinite string of
                | leading 'ff's).
            X   | Equivalent to `x', but uses uppercase letters.

          Field |  Float Format
          ------+--------------------------------------------------------------
            e   | Convert floating point argument into exponential notation
                | with one digit before the decimal point as [-]d.dddddde[+-]dd.
                | The precision specifies the number of digits after the decimal
                | point (defaulting to six).
            E   | Equivalent to `e', but uses an uppercase E to indicate
                | the exponent.
            f   | Convert floating point argument as [-]ddd.dddddd,
                | where the precision specifies the number of digits after
                | the decimal point.
            g   | Convert a floating point number using exponential form
                | if the exponent is less than -4 or greater than or
                | equal to the precision, or in dd.dddd form otherwise.
                | The precision specifies the number of significant digits.
            G   | Equivalent to `g', but use an uppercase `E' in exponent form.
            a   | Convert floating point argument as [-]0xh.hhhhp[+-]dd,
                | which is consisted from optional sign, "0x", fraction part
                | as hexadecimal, "p", and exponential part as decimal.
            A   | Equivalent to `a', but use uppercase `X' and `P'.

          Field |  Other Format
          ------+--------------------------------------------------------------
            c   | Argument is the numeric code for a single character or
                | a single character string itself.
            p   | The valuing of argument.inspect.
            s   | Argument is a string to be substituted.  If the format
                | sequence contains a precision, at most that many characters
                | will be copied.
            %   | A percent sign itself will be displayed.  No argument taken.

      The flags modifies the behavior of the formats.
      The flag characters are:

        Flag     | Applies to    | Meaning
        ---------+---------------+-----------------------------------------
        space    | bBdiouxX      | Leave a space at the start of
                 | aAeEfgG       | non-negative numbers.
                 | (numeric fmt) | For `o', `x', `X', `b' and `B', use
                 |               | a minus sign with absolute value for
                 |               | negative values.
        ---------+---------------+-----------------------------------------
        (digit)$ | all           | Specifies the absolute argument number
                 |               | for this field.  Absolute and relative
                 |               | argument numbers cannot be mixed in a
                 |               | sprintf string.
        ---------+---------------+-----------------------------------------
         #       | bBoxX         | Use an alternative format.
                 | aAeEfgG       | For the conversions `o', increase the precision
                 |               | until the first digit will be `0' if
                 |               | it is not formatted as complements.
                 |               | For the conversions `x', `X', `b' and `B'
                 |               | on non-zero, prefix the result with ``0x'',
                 |               | ``0X'', ``0b'' and ``0B'', respectively.
                 |               | For `a', `A', `e', `E', `f', `g', and 'G',
                 |               | force a decimal point to be added,
                 |               | even if no digits follow.
                 |               | For `g' and 'G', do not remove trailing zeros.
        ---------+---------------+-----------------------------------------
        +        | bBdiouxX      | Add a leading plus sign to non-negative
                 | aAeEfgG       | numbers.
                 | (numeric fmt) | For `o', `x', `X', `b' and `B', use
                 |               | a minus sign with absolute value for
                 |               | negative values.
        ---------+---------------+-----------------------------------------
        -        | all           | Left-justify the result of this conversion.
        ---------+---------------+-----------------------------------------
        0 (zero) | bBdiouxX      | Pad with zeros, not spaces.
                 | aAeEfgG       | For `o', `x', `X', `b' and `B', radix-1
                 | (numeric fmt) | is used for negative numbers formatted as
                 |               | complements.
        ---------+---------------+-----------------------------------------
        *        | all           | Use the next argument as the field width.
                 |               | If negative, left-justify the result. If the
                 |               | asterisk is followed by a number and a dollar
                 |               | sign, use the indicated argument as the width.

      Examples of flags:

       # `+' and space flag specifies the sign of non-negative numbers.
       sprintf("%d", 123)  #=> "123"
       sprintf("%+d", 123) #=> "+123"
       sprintf("% d", 123) #=> " 123"

       # `#' flag for `o' increases number of digits to show `0'.
       # `+' and space flag changes format of negative numbers.
       sprintf("%o", 123)   #=> "173"
       sprintf("%#o", 123)  #=> "0173"
       sprintf("%+o", -123) #=> "-173"
       sprintf("%o", -123)  #=> "..7605"
       sprintf("%#o", -123) #=> "..7605"

       # `#' flag for `x' add a prefix `0x' for non-zero numbers.
       # `+' and space flag disables complements for negative numbers.
       sprintf("%x", 123)   #=> "7b"
       sprintf("%#x", 123)  #=> "0x7b"
       sprintf("%+x", -123) #=> "-7b"
       sprintf("%x", -123)  #=> "..f85"
       sprintf("%#x", -123) #=> "0x..f85"
       sprintf("%#x", 0)    #=> "0"

       # `#' for `X' uses the prefix `0X'.
       sprintf("%X", 123)  #=> "7B"
       sprintf("%#X", 123) #=> "0X7B"

       # `#' flag for `b' add a prefix `0b' for non-zero numbers.
       # `+' and space flag disables complements for negative numbers.
       sprintf("%b", 123)   #=> "1111011"
       sprintf("%#b", 123)  #=> "0b1111011"
       sprintf("%+b", -123) #=> "-1111011"
       sprintf("%b", -123)  #=> "..10000101"
       sprintf("%#b", -123) #=> "0b..10000101"
       sprintf("%#b", 0)    #=> "0"

       # `#' for `B' uses the prefix `0B'.
       sprintf("%B", 123)  #=> "1111011"
       sprintf("%#B", 123) #=> "0B1111011"

       # `#' for `e' forces to show the decimal point.
       sprintf("%.0e", 1)  #=> "1e+00"
       sprintf("%#.0e", 1) #=> "1.e+00"

       # `#' for `f' forces to show the decimal point.
       sprintf("%.0f", 1234)  #=> "1234"
       sprintf("%#.0f", 1234) #=> "1234."

       # `#' for `g' forces to show the decimal point.
       # It also disables stripping lowest zeros.
       sprintf("%g", 123.4)   #=> "123.4"
       sprintf("%#g", 123.4)  #=> "123.400"
       sprintf("%g", 123456)  #=> "123456"
       sprintf("%#g", 123456) #=> "123456."

      The field width is an optional integer, followed optionally by a
      period and a precision.  The width specifies the minimum number of
      characters that will be written to the result for this field.

      Examples of width:

       # padding is done by spaces,       width=20
       # 0 or radix-1.             <------------------>
       sprintf("%20d", 123)   #=> "                 123"
       sprintf("%+20d", 123)  #=> "                +123"
       sprintf("%020d", 123)  #=> "00000000000000000123"
       sprintf("%+020d", 123) #=> "+0000000000000000123"
       sprintf("% 020d", 123) #=> " 0000000000000000123"
       sprintf("%-20d", 123)  #=> "123                 "
       sprintf("%-+20d", 123) #=> "+123                "
       sprintf("%- 20d", 123) #=> " 123                "
       sprintf("%020x", -123) #=> "..ffffffffffffffff85"

      For
      numeric fields, the precision controls the number of decimal places
      displayed.  For string fields, the precision determines the maximum
      number of characters to be copied from the string.  (Thus, the format
      sequence <code>%10.10s</code> will always contribute exactly ten
      characters to the result.)

      Examples of precisions:

       # precision for `d', 'o', 'x' and 'b' is
       # minimum number of digits               <------>
       sprintf("%20.8d", 123)  #=> "            00000123"
       sprintf("%20.8o", 123)  #=> "            00000173"
       sprintf("%20.8x", 123)  #=> "            0000007b"
       sprintf("%20.8b", 123)  #=> "            01111011"
       sprintf("%20.8d", -123) #=> "           -00000123"
       sprintf("%20.8o", -123) #=> "            ..777605"
       sprintf("%20.8x", -123) #=> "            ..ffff85"
       sprintf("%20.8b", -11)  #=> "            ..110101"

       # "0x" and "0b" for `#x' and `#b' is not counted for
       # precision but "0" for `#o' is counted.  <------>
       sprintf("%#20.8d", 123)  #=> "            00000123"
       sprintf("%#20.8o", 123)  #=> "            00000173"
       sprintf("%#20.8x", 123)  #=> "          0x0000007b"
       sprintf("%#20.8b", 123)  #=> "          0b01111011"
       sprintf("%#20.8d", -123) #=> "           -00000123"
       sprintf("%#20.8o", -123) #=> "            ..777605"
       sprintf("%#20.8x", -123) #=> "          0x..ffff85"
       sprintf("%#20.8b", -11)  #=> "          0b..110101"

       # precision for `e' is number of
       # digits after the decimal point           <------>
       sprintf("%20.8e", 1234.56789) #=> "      1.23456789e+03"

       # precision for `f' is number of
       # digits after the decimal point               <------>
       sprintf("%20.8f", 1234.56789) #=> "       1234.56789000"

       # precision for `g' is number of
       # significant digits                          <------->
       sprintf("%20.8g", 1234.56789) #=> "           1234.5679"

       #                                         <------->
       sprintf("%20.8g", 123456789)  #=> "       1.2345679e+08"

       # precision for `s' is
       # maximum number of characters                    <------>
       sprintf("%20.8s", "string test") #=> "            string t"

      Examples:

         sprintf("%d %04x", 123, 123)               #=> "123 007b"
         sprintf("%08b '%4s'", 123, 123)            #=> "01111011 ' 123'"
         sprintf("%1$*2$s %2$d %1$s", "hello", 8)   #=> "   hello 8 hello"
         sprintf("%1$*2$s %2$d", "hello", -8)       #=> "hello    -8"
         sprintf("%+g:% g:%-g", 1.23, 1.23, 1.23)   #=> "+1.23: 1.23:1.23"
         sprintf("%u", -123)                        #=> "-123"

      For more complex formatting, Ruby supports a reference by name.
      %<name>s style uses format style, but %{name} style doesn't.

      Examples:
        sprintf("%<foo>d : %<bar>f", { :foo => 1, :bar => 2 })
          #=> 1 : 2.000000
        sprintf("%{foo}f", { :foo => 1 })
          # => "1f"
    Integer: |2-

      Converts <i>arg</i> to an Integer.
      Numeric types are converted directly (with floating point numbers
      being truncated).  <i>base</i> (0, or between 2 and 36) is a base for
      integer string representation.  If <i>arg</i> is a String,
      when <i>base</i> is omitted or equals zero, radix indicators
      (<code>0</code>, <code>0b</code>, and <code>0x</code>) are honored.
      In any case, strings should be strictly conformed to numeric
      representation. This behavior is different from that of
      String#to_i.  Non string values will be converted by first
      trying <code>to_int</code>, then <code>to_i</code>.

      Passing <code>nil</code> raises a TypeError, while passing a String that
      does not conform with numeric representation raises an ArgumentError.
      This behavior can be altered by passing <code>exception: false</code>,
      in this case a not convertible value will return <code>nil</code>.

         Integer(123.999)    #=> 123
         Integer("0x1a")     #=> 26
         Integer(Time.new)   #=> 1204973019
         Integer("0930", 10) #=> 930
         Integer("111", 2)   #=> 7
         Integer(nil)        #=> TypeError: can't convert nil into Integer
         Integer("x")        #=> ArgumentError: invalid value for Integer(): "x"

         Integer("x", exception: false)        #=> nil
    Float: |2-

      Returns <i>arg</i> converted to a float. Numeric types are
      converted directly, and with exception to String and
      <code>nil</code> the rest are converted using
      <i>arg</i><code>.to_f</code>.  Converting a String with invalid
      characters will result in a ArgumentError.  Converting
      <code>nil</code> generates a TypeError.  Exceptions can be
      suppressed by passing <code>exception: false</code>.

         Float(1)                 #=> 1.0
         Float("123.456")         #=> 123.456
         Float("123.0_badstring") #=> ArgumentError: invalid value for Float(): "123.0_badstring"
         Float(nil)               #=> TypeError: can't convert nil into Float
         Float("123.0_badstring", exception: false)  #=> nil
    String: |2-

      Returns <i>arg</i> as a String.

      First tries to call its <code>to_str</code> method, then its <code>to_s</code> method.

         String(self)        #=> "main"
         String(self.class)  #=> "Object"
         String(123456)      #=> "123456"
    Array: |2-

      Returns +arg+ as an Array.

      First tries to call <code>to_ary</code> on +arg+, then <code>to_a</code>.
      If +arg+ does not respond to <code>to_ary</code> or <code>to_a</code>,
      returns an Array of length 1 containing +arg+.

      If <code>to_ary</code> or <code>to_a</code> returns something other than
      an Array, raises a TypeError.

         Array(["a", "b"])  #=> ["a", "b"]
         Array(1..5)        #=> [1, 2, 3, 4, 5]
         Array(key: :value) #=> [[:key, :value]]
         Array(nil)         #=> []
         Array(1)           #=> [1]
    Hash: |2-

      Converts <i>arg</i> to a Hash by calling
      <i>arg</i><code>.to_hash</code>. Returns an empty Hash when
      <i>arg</i> is <tt>nil</tt> or <tt>[]</tt>.

         Hash([])          #=> {}
         Hash(nil)         #=> {}
         Hash(key: :value) #=> {:key => :value}
         Hash([1, 2, 3])   #=> TypeError
    pp: suppress redefinition warning
    proc: |2-

      Equivalent to Proc.new.
    lambda: |2-

      Equivalent to Proc.new, except the resulting Proc objects check the
      number of parameters passed when called.
    binding: |2-

      Returns a +Binding+ object, describing the variable and
      method bindings at the point of call. This object can be used when
      calling +eval+ to execute the evaluated command in this
      environment. See also the description of class +Binding+.

         def get_binding(param)
           binding
         end
         b = get_binding("hello")
         eval("param", b)   #=> "hello"
    exec: |2-

      Replaces the current process by running the given external _command_, which
      can take one of the following forms:

      [<code>exec(commandline)</code>]
          command line string which is passed to the standard shell
      [<code>exec(cmdname, arg1, ...)</code>]
          command name and one or more arguments (no shell)
      [<code>exec([cmdname, argv0], arg1, ...)</code>]
          command name, argv[0] and zero or more arguments (no shell)

      In the first form, the string is taken as a command line that is subject to
      shell expansion before being executed.

      The standard shell always means <code>"/bin/sh"</code> on Unix-like systems,
      same as <code>ENV["RUBYSHELL"]</code>
      (or <code>ENV["COMSPEC"]</code> on Windows NT series), and similar.

      If the string from the first form (<code>exec("command")</code>) follows
      these simple rules:

      * no meta characters
      * no shell reserved word and no special built-in
      * Ruby invokes the command directly without shell

      You can force shell invocation by adding ";" to the string (because ";" is
      a meta character).

      Note that this behavior is observable by pid obtained
      (return value of spawn() and IO#pid for IO.popen) is the pid of the invoked
      command, not shell.

      In the second form (<code>exec("command1", "arg1", ...)</code>), the first
      is taken as a command name and the rest are passed as parameters to command
      with no shell expansion.

      In the third form (<code>exec(["command", "argv0"], "arg1", ...)</code>),
      starting a two-element array at the beginning of the command, the first
      element is the command to be executed, and the second argument is used as
      the <code>argv[0]</code> value, which may show up in process listings.

      In order to execute the command, one of the <code>exec(2)</code> system
      calls are used, so the running command may inherit some of the environment
      of the original program (including open file descriptors).

      This behavior is modified by the given +env+ and +options+ parameters. See
      ::spawn for details.

      If the command fails to execute (typically Errno::ENOENT when
      it was not found) a SystemCallError exception is raised.

      This method modifies process attributes according to given +options+ before
      <code>exec(2)</code> system call. See ::spawn for more details about the
      given +options+.

      The modified attributes may be retained when <code>exec(2)</code> system
      call fails.

      For example, hard resource limits are not restorable.

      Consider to create a child process using ::spawn or Kernel#system if this
      is not acceptable.

         exec "echo *"       # echoes list of files in current directory
         # never get here

         exec "echo", "*"    # echoes an asterisk
         # never get here
    fork: |2-

      Creates a subprocess. If a block is specified, that block is run
      in the subprocess, and the subprocess terminates with a status of
      zero. Otherwise, the +fork+ call returns twice, once in the
      parent, returning the process ID of the child, and once in the
      child, returning _nil_. The child process can exit using
      Kernel.exit! to avoid running any <code>at_exit</code>
      functions. The parent process should use Process.wait to collect
      the termination statuses of its children or use Process.detach to
      register disinterest in their status; otherwise, the operating
      system may accumulate zombie processes.

      The thread calling fork is the only thread in the created child process.
      fork doesn't copy other threads.

      If fork is not usable, Process.respond_to?(:fork) returns false.

      Note that fork(2) is not available on some platforms like Windows and NetBSD 4.
      Therefore you should use spawn() instead of fork().
    exit!: |2-

      Exits the process immediately. No exit handlers are
      run. <em>status</em> is returned to the underlying system as the
      exit status.

         Process.exit!(true)
    system: |2-

      Executes _command..._ in a subshell.
      _command..._ is one of following forms.

      [<code>commandline</code>]
        command line string which is passed to the standard shell
      [<code>cmdname, arg1, ...</code>]
        command name and one or more arguments (no shell)
      [<code>[cmdname, argv0], arg1, ...</code>]
        command name, <code>argv[0]</code> and zero or more arguments (no shell)

      system returns +true+ if the command gives zero exit status,
      +false+ for non zero exit status.
      Returns +nil+ if command execution fails.
      An error status is available in <code>$?</code>.

      If the <code>exception: true</code> argument is passed, the method
      raises an exception instead of returning +false+ or +nil+.

      The arguments are processed in the same way as
      for Kernel#spawn.

      The hash arguments, env and options, are same as #exec and #spawn.
      See Kernel#spawn for details.

         system("echo *")
         system("echo", "*")

      <em>produces:</em>

         config.h main.rb
         *

      Error handling:

         system("cat nonexistent.txt")
         # => false
         system("catt nonexistent.txt")
         # => nil

         system("cat nonexistent.txt", exception: true)
         # RuntimeError (Command failed with exit 1: cat)
         system("catt nonexistent.txt", exception: true)
         # Errno::ENOENT (No such file or directory - catt)

      See Kernel#exec for the standard shell.
    spawn: |2-

      spawn executes specified command and return its pid.

        pid = spawn("tar xf ruby-2.0.0-p195.tar.bz2")
        Process.wait pid

        pid = spawn(RbConfig.ruby, "-eputs'Hello, world!'")
        Process.wait pid

      This method is similar to Kernel#system but it doesn't wait for the command
      to finish.

      The parent process should
      use Process.wait to collect
      the termination status of its child or
      use Process.detach to register
      disinterest in their status;
      otherwise, the operating system may accumulate zombie processes.

      spawn has bunch of options to specify process attributes:

        env: hash
          name => val : set the environment variable
          name => nil : unset the environment variable

          the keys and the values except for +nil+ must be strings.
        command...:
          commandline                 : command line string which is passed to the standard shell
          cmdname, arg1, ...          : command name and one or more arguments (This form does not use the shell. See below for caveats.)
          [cmdname, argv0], arg1, ... : command name, argv[0] and zero or more arguments (no shell)
        options: hash
          clearing environment variables:
            :unsetenv_others => true   : clear environment variables except specified by env
            :unsetenv_others => false  : don't clear (default)
          process group:
            :pgroup => true or 0 : make a new process group
            :pgroup => pgid      : join the specified process group
            :pgroup => nil       : don't change the process group (default)
          create new process group: Windows only
            :new_pgroup => true  : the new process is the root process of a new process group
            :new_pgroup => false : don't create a new process group (default)
          resource limit: resourcename is core, cpu, data, etc.  See Process.setrlimit.
            :rlimit_resourcename => limit
            :rlimit_resourcename => [cur_limit, max_limit]
          umask:
            :umask => int
          redirection:
            key:
              FD              : single file descriptor in child process
              [FD, FD, ...]   : multiple file descriptor in child process
            value:
              FD                        : redirect to the file descriptor in parent process
              string                    : redirect to file with open(string, "r" or "w")
              [string]                  : redirect to file with open(string, File::RDONLY)
              [string, open_mode]       : redirect to file with open(string, open_mode, 0644)
              [string, open_mode, perm] : redirect to file with open(string, open_mode, perm)
              [:child, FD]              : redirect to the redirected file descriptor
              :close                    : close the file descriptor in child process
            FD is one of follows
              :in     : the file descriptor 0 which is the standard input
              :out    : the file descriptor 1 which is the standard output
              :err    : the file descriptor 2 which is the standard error
              integer : the file descriptor of specified the integer
              io      : the file descriptor specified as io.fileno
          file descriptor inheritance: close non-redirected non-standard fds (3, 4, 5, ...) or not
            :close_others => false  : inherit
          current directory:
            :chdir => str

      The <code>cmdname, arg1, ...</code> form does not use the shell.
      However, on different OSes, different things are provided as
      built-in commands. An example of this is +'echo'+, which is a
      built-in on Windows, but is a normal program on Linux and Mac OS X.
      This means that <code>Process.spawn 'echo', '%Path%'</code> will
      display the contents of the <tt>%Path%</tt> environment variable
      on Windows, but <code>Process.spawn 'echo', '$PATH'</code> prints
      the literal <tt>$PATH</tt>.

      If a hash is given as +env+, the environment is
      updated by +env+ before <code>exec(2)</code> in the child process.
      If a pair in +env+ has nil as the value, the variable is deleted.

        # set FOO as BAR and unset BAZ.
        pid = spawn({"FOO"=>"BAR", "BAZ"=>nil}, command)

      If a hash is given as +options+,
      it specifies
      process group,
      create new process group,
      resource limit,
      current directory,
      umask and
      redirects for the child process.
      Also, it can be specified to clear environment variables.

      The <code>:unsetenv_others</code> key in +options+ specifies
      to clear environment variables, other than specified by +env+.

        pid = spawn(command, :unsetenv_others=>true) # no environment variable
        pid = spawn({"FOO"=>"BAR"}, command, :unsetenv_others=>true) # FOO only

      The <code>:pgroup</code> key in +options+ specifies a process group.
      The corresponding value should be true, zero, a positive integer, or nil.
      true and zero cause the process to be a process leader of a new process group.
      A non-zero positive integer causes the process to join the provided process group.
      The default value, nil, causes the process to remain in the same process group.

        pid = spawn(command, :pgroup=>true) # process leader
        pid = spawn(command, :pgroup=>10) # belongs to the process group 10

      The <code>:new_pgroup</code> key in +options+ specifies to pass
      +CREATE_NEW_PROCESS_GROUP+ flag to <code>CreateProcessW()</code> that is
      Windows API. This option is only for Windows.
      true means the new process is the root process of the new process group.
      The new process has CTRL+C disabled. This flag is necessary for
      <code>Process.kill(:SIGINT, pid)</code> on the subprocess.
      :new_pgroup is false by default.

        pid = spawn(command, :new_pgroup=>true)  # new process group
        pid = spawn(command, :new_pgroup=>false) # same process group

      The <code>:rlimit_</code><em>foo</em> key specifies a resource limit.
      <em>foo</em> should be one of resource types such as <code>core</code>.
      The corresponding value should be an integer or an array which have one or
      two integers: same as cur_limit and max_limit arguments for
      Process.setrlimit.

        cur, max = Process.getrlimit(:CORE)
        pid = spawn(command, :rlimit_core=>[0,max]) # disable core temporary.
        pid = spawn(command, :rlimit_core=>max) # enable core dump
        pid = spawn(command, :rlimit_core=>0) # never dump core.

      The <code>:umask</code> key in +options+ specifies the umask.

        pid = spawn(command, :umask=>077)

      The :in, :out, :err, an integer, an IO and an array key specifies a redirection.
      The redirection maps a file descriptor in the child process.

      For example, stderr can be merged into stdout as follows:

        pid = spawn(command, :err=>:out)
        pid = spawn(command, 2=>1)
        pid = spawn(command, STDERR=>:out)
        pid = spawn(command, STDERR=>STDOUT)

      The hash keys specifies a file descriptor in the child process
      started by #spawn.
      :err, 2 and STDERR specifies the standard error stream (stderr).

      The hash values specifies a file descriptor in the parent process
      which invokes #spawn.
      :out, 1 and STDOUT specifies the standard output stream (stdout).

      In the above example,
      the standard output in the child process is not specified.
      So it is inherited from the parent process.

      The standard input stream (stdin) can be specified by :in, 0 and STDIN.

      A filename can be specified as a hash value.

        pid = spawn(command, :in=>"/dev/null") # read mode
        pid = spawn(command, :out=>"/dev/null") # write mode
        pid = spawn(command, :err=>"log") # write mode
        pid = spawn(command, [:out, :err]=>"/dev/null") # write mode
        pid = spawn(command, 3=>"/dev/null") # read mode

      For stdout and stderr (and combination of them),
      it is opened in write mode.
      Otherwise read mode is used.

      For specifying flags and permission of file creation explicitly,
      an array is used instead.

        pid = spawn(command, :in=>["file"]) # read mode is assumed
        pid = spawn(command, :in=>["file", "r"])
        pid = spawn(command, :out=>["log", "w"]) # 0644 assumed
        pid = spawn(command, :out=>["log", "w", 0600])
        pid = spawn(command, :out=>["log", File::WRONLY|File::EXCL|File::CREAT, 0600])

      The array specifies a filename, flags and permission.
      The flags can be a string or an integer.
      If the flags is omitted or nil, File::RDONLY is assumed.
      The permission should be an integer.
      If the permission is omitted or nil, 0644 is assumed.

      If an array of IOs and integers are specified as a hash key,
      all the elements are redirected.

        # stdout and stderr is redirected to log file.
        # The file "log" is opened just once.
        pid = spawn(command, [:out, :err]=>["log", "w"])

      Another way to merge multiple file descriptors is [:child, fd].
      \[:child, fd] means the file descriptor in the child process.
      This is different from fd.
      For example, :err=>:out means redirecting child stderr to parent stdout.
      But :err=>[:child, :out] means redirecting child stderr to child stdout.
      They differ if stdout is redirected in the child process as follows.

        # stdout and stderr is redirected to log file.
        # The file "log" is opened just once.
        pid = spawn(command, :out=>["log", "w"], :err=>[:child, :out])

      \[:child, :out] can be used to merge stderr into stdout in IO.popen.
      In this case, IO.popen redirects stdout to a pipe in the child process
      and [:child, :out] refers the redirected stdout.

        io = IO.popen(["sh", "-c", "echo out; echo err >&2", :err=>[:child, :out]])
        p io.read #=> "out\nerr\n"

      The <code>:chdir</code> key in +options+ specifies the current directory.

        pid = spawn(command, :chdir=>"/var/tmp")

      spawn closes all non-standard unspecified descriptors by default.
      The "standard" descriptors are 0, 1 and 2.
      This behavior is specified by :close_others option.
      :close_others doesn't affect the standard descriptors which are
      closed only if :close is specified explicitly.

        pid = spawn(command, :close_others=>true)  # close 3,4,5,... (default)
        pid = spawn(command, :close_others=>false) # don't close 3,4,5,...

      :close_others is false by default for spawn and IO.popen.

      Note that fds which close-on-exec flag is already set are closed
      regardless of :close_others option.

      So IO.pipe and spawn can be used as IO.popen.

        # similar to r = IO.popen(command)
        r, w = IO.pipe
        pid = spawn(command, :out=>w)   # r, w is closed in the child process.
        w.close

      :close is specified as a hash value to close a fd individually.

        f = open(foo)
        system(command, f=>:close)        # don't inherit f.

      If a file descriptor need to be inherited,
      io=>io can be used.

        # valgrind has --log-fd option for log destination.
        # log_w=>log_w indicates log_w.fileno inherits to child process.
        log_r, log_w = IO.pipe
        pid = spawn("valgrind", "--log-fd=#{log_w.fileno}", "echo", "a", log_w=>log_w)
        log_w.close
        p log_r.read

      It is also possible to exchange file descriptors.

        pid = spawn(command, :out=>:err, :err=>:out)

      The hash keys specify file descriptors in the child process.
      The hash values specifies file descriptors in the parent process.
      So the above specifies exchanging stdout and stderr.
      Internally, +spawn+ uses an extra file descriptor to resolve such cyclic
      file descriptor mapping.

      See Kernel.exec for the standard shell.
    sleep: |2-

      Suspends the current thread for _duration_ seconds (which may be any number,
      including a +Float+ with fractional seconds). Returns the actual number of
      seconds slept (rounded), which may be less than that asked for if another
      thread calls Thread#run. Called without an argument, sleep()
      will sleep forever.

         Time.new    #=> 2008-03-08 19:56:19 +0900
         sleep 1.2   #=> 1
         Time.new    #=> 2008-03-08 19:56:20 +0900
         sleep 1.9   #=> 2
         Time.new    #=> 2008-03-08 19:56:22 +0900
    exit: |2-

      Initiates the termination of the Ruby script by raising the
      SystemExit exception. This exception may be caught. The
      optional parameter is used to return a status code to the invoking
      environment.
      +true+ and +FALSE+ of _status_ means success and failure
      respectively.  The interpretation of other integer values are
      system dependent.

         begin
           exit
           puts "never get here"
         rescue SystemExit
           puts "rescued a SystemExit exception"
         end
         puts "after begin block"

      <em>produces:</em>

         rescued a SystemExit exception
         after begin block

      Just prior to termination, Ruby executes any <code>at_exit</code>
      functions (see Kernel::at_exit) and runs any object finalizers
      (see ObjectSpace::define_finalizer).

         at_exit { puts "at_exit function" }
         ObjectSpace.define_finalizer("string",  proc { puts "in finalizer" })
         exit

      <em>produces:</em>

         at_exit function
         in finalizer
    abort: ''
    srand: |2-

      Seeds the system pseudo-random number generator, Random::DEFAULT, with
      +number+.  The previous seed value is returned.

      If +number+ is omitted, seeds the generator using a source of entropy
      provided by the operating system, if available (/dev/urandom on Unix systems
      or the RSA cryptographic provider on Windows), which is then combined with
      the time, the process id, and a sequence number.

      srand may be used to ensure repeatable sequences of pseudo-random numbers
      between different runs of the program. By setting the seed to a known value,
      programs can be made deterministic during testing.

        srand 1234               # => 268519324636777531569100071560086917274
        [ rand, rand ]           # => [0.1915194503788923, 0.6221087710398319]
        [ rand(10), rand(1000) ] # => [4, 664]
        srand 1234               # => 1234
        [ rand, rand ]           # => [0.1915194503788923, 0.6221087710398319]
    rand: |2-

      If called without an argument, or if <tt>max.to_i.abs == 0</tt>, rand
      returns a pseudo-random floating point number between 0.0 and 1.0,
      including 0.0 and excluding 1.0.

        rand        #=> 0.2725926052826416

      When +max.abs+ is greater than or equal to 1, +rand+ returns a pseudo-random
      integer greater than or equal to 0 and less than +max.to_i.abs+.

        rand(100)   #=> 12

      When +max+ is a Range, +rand+ returns a random number where
      range.member?(number) == true.

      Negative or floating point values for +max+ are allowed, but may give
      surprising results.

        rand(-100) # => 87
        rand(-0.5) # => 0.8130921818028143
        rand(1.9)  # equivalent to rand(1), which is always 0

      Kernel.srand may be used to ensure that sequences of random numbers are
      reproducible between different runs of a program.

      See also Random.rand.
    Rational: |2-

      Returns +x/y+ or +arg+ as a Rational.

         Rational(2, 3)   #=> (2/3)
         Rational(5)      #=> (5/1)
         Rational(0.5)    #=> (1/2)
         Rational(0.3)    #=> (5404319552844595/18014398509481984)

         Rational("2/3")  #=> (2/3)
         Rational("0.3")  #=> (3/10)

         Rational("10 cents")  #=> ArgumentError
         Rational(nil)         #=> TypeError
         Rational(1, nil)      #=> TypeError

         Rational("10 cents", exception: false)  #=> nil

      Syntax of the string form:

        string form = extra spaces , rational , extra spaces ;
        rational = [ sign ] , unsigned rational ;
        unsigned rational = numerator | numerator , "/" , denominator ;
        numerator = integer part | fractional part | integer part , fractional part ;
        denominator = digits ;
        integer part = digits ;
        fractional part = "." , digits , [ ( "e" | "E" ) , [ sign ] , digits ] ;
        sign = "-" | "+" ;
        digits = digit , { digit | "_" , digit } ;
        digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;
        extra spaces = ? \s* ? ;

      See also String#to_r.
    sub: |2-

      Equivalent to <code>$_.sub(<i>args</i>)</code>, except that
      <code>$_</code> will be updated if substitution occurs.
      Available only when -p/-n command line option specified.
    gsub: |2-

      Equivalent to <code>$_.gsub...</code>, except that <code>$_</code>
      will be updated if substitution occurs.
      Available only when -p/-n command line option specified.
    chop: |2-

      Equivalent to <code>($_.dup).chop!</code>, except <code>nil</code>
      is never returned. See String#chop!.
      Available only when -p/-n command line option specified.
    chomp: |2-

      Equivalent to <code>$_ = $_.chomp(<em>string</em>)</code>. See
      String#chomp.
      Available only when -p/-n command line option specified.
    trap: |2-

      Specifies the handling of signals. The first parameter is a signal
      name (a string such as ``SIGALRM'', ``SIGUSR1'', and so on) or a
      signal number. The characters ``SIG'' may be omitted from the
      signal name. The command or block specifies code to be run when the
      signal is raised.
      If the command is the string ``IGNORE'' or ``SIG_IGN'', the signal
      will be ignored.
      If the command is ``DEFAULT'' or ``SIG_DFL'', the Ruby's default handler
      will be invoked.
      If the command is ``EXIT'', the script will be terminated by the signal.
      If the command is ``SYSTEM_DEFAULT'', the operating system's default
      handler will be invoked.
      Otherwise, the given command or block will be run.
      The special signal name ``EXIT'' or signal number zero will be
      invoked just prior to program termination.
      trap returns the previous handler for the given signal.

          Signal.trap(0, proc { puts "Terminating: #{$$}" })
          Signal.trap("CLD")  { puts "Child died" }
          fork && Process.wait

      produces:
          Terminating: 27461
          Child died
          Terminating: 27460
    caller: |2-

      Returns the current execution stack---an array containing strings in
      the form <code>file:line</code> or <code>file:line: in
      `method'</code>.

      The optional _start_ parameter determines the number of initial stack
      entries to omit from the top of the stack.

      A second optional +length+ parameter can be used to limit how many entries
      are returned from the stack.

      Returns +nil+ if _start_ is greater than the size of
      current execution stack.

      Optionally you can pass a range, which will return an array containing the
      entries within the specified range.

         def a(skip)
           caller(skip)
         end
         def b(skip)
           a(skip)
         end
         def c(skip)
           b(skip)
         end
         c(0)   #=> ["prog:2:in `a'", "prog:5:in `b'", "prog:8:in `c'", "prog:10:in `<main>'"]
         c(1)   #=> ["prog:5:in `b'", "prog:8:in `c'", "prog:11:in `<main>'"]
         c(2)   #=> ["prog:8:in `c'", "prog:12:in `<main>'"]
         c(3)   #=> ["prog:13:in `<main>'"]
         c(4)   #=> []
         c(5)   #=> nil
    caller_locations: |2-

      Returns the current execution stack---an array containing
      backtrace location objects.

      See Thread::Backtrace::Location for more information.

      The optional _start_ parameter determines the number of initial stack
      entries to omit from the top of the stack.

      A second optional +length+ parameter can be used to limit how many entries
      are returned from the stack.

      Returns +nil+ if _start_ is greater than the size of
      current execution stack.

      Optionally you can pass a range, which will return an array containing the
      entries within the specified range.
    eval: |2-

      Evaluates the Ruby expression(s) in <em>string</em>. If
      <em>binding</em> is given, which must be a Binding object, the
      evaluation is performed in its context. If the optional
      <em>filename</em> and <em>lineno</em> parameters are present, they
      will be used when reporting syntax errors.

         def get_binding(str)
           return binding
         end
         str = "hello"
         eval "str + ' Fred'"                      #=> "hello Fred"
         eval "str + ' Fred'", get_binding("bye")  #=> "bye Fred"
    local_variables: |2-

      Returns the names of the current local variables.

         fred = 1
         for i in 1..10
            # ...
         end
         local_variables   #=> [:fred, :i]
    iterator?: |2-

      Returns <code>true</code> if <code>yield</code> would execute a
      block in the current context. The <code>iterator?</code> form
      is mildly deprecated.

         def try
           if block_given?
             yield
           else
             "no block"
           end
         end
         try                  #=> "no block"
         try { "hello" }      #=> "hello"
         try do "hello" end   #=> "hello"
    block_given?: |2-

      Returns <code>true</code> if <code>yield</code> would execute a
      block in the current context. The <code>iterator?</code> form
      is mildly deprecated.

         def try
           if block_given?
             yield
           else
             "no block"
           end
         end
         try                  #=> "no block"
         try { "hello" }      #=> "hello"
         try do "hello" end   #=> "hello"
    catch: |2-

      +catch+ executes its block. If +throw+ is not called, the block executes
      normally, and +catch+ returns the value of the last expression evaluated.

         catch(1) { 123 }            # => 123

      If <code>throw(tag2, val)</code> is called, Ruby searches up its stack for
      a +catch+ block whose +tag+ has the same +object_id+ as _tag2_. When found,
      the block stops executing and returns _val_ (or +nil+ if no second argument
      was given to +throw+).

         catch(1) { throw(1, 456) }  # => 456
         catch(1) { throw(1) }       # => nil

      When +tag+ is passed as the first argument, +catch+ yields it as the
      parameter of the block.

         catch(1) {|x| x + 2 }       # => 3

      When no +tag+ is given, +catch+ yields a new unique object (as from
      +Object.new+) as the block parameter. This object can then be used as the
      argument to +throw+, and will match the correct +catch+ block.

         catch do |obj_A|
           catch do |obj_B|
             throw(obj_B, 123)
             puts "This puts is not reached"
           end

           puts "This puts is displayed"
           456
         end

         # => 456

         catch do |obj_A|
           catch do |obj_B|
             throw(obj_A, 123)
             puts "This puts is still not reached"
           end

           puts "Now this puts is also not reached"
           456
         end

         # => 123
    throw: |2-

      Transfers control to the end of the active +catch+ block
      waiting for _tag_. Raises +UncaughtThrowError+ if there
      is no +catch+ block for the _tag_. The optional second
      parameter supplies a return value for the +catch+ block,
      which otherwise defaults to +nil+. For examples, see
      Kernel::catch.
    loop: |2-

      Repeatedly executes the block.

      If no block is given, an enumerator is returned instead.

         loop do
           print "Input: "
           line = gets
           break if !line or line =~ /^qQ/
           # ...
         end

      StopIteration raised in the block breaks the loop.  In this case,
      loop returns the "result" value stored in the exception.

         enum = Enumerator.new { |y|
           y << "one"
           y << "two"
           :ok
         }

         result = loop {
           puts enum.next
         } #=> :ok
    set_trace_func: |2-

      Establishes _proc_ as the handler for tracing, or disables
      tracing if the parameter is +nil+.

      *Note:* this method is obsolete, please use TracePoint instead.

      _proc_ takes up to six parameters:

      *   an event name
      *   a filename
      *   a line number
      *   an object id
      *   a binding
      *   the name of a class

      _proc_ is invoked whenever an event occurs.

      Events are:

      +c-call+:: call a C-language routine
      +c-return+:: return from a C-language routine
      +call+:: call a Ruby method
      +class+:: start a class or module definition
      +end+:: finish a class or module definition
      +line+:: execute code on a new line
      +raise+:: raise an exception
      +return+:: return from a Ruby method

      Tracing is disabled within the context of _proc_.

          class Test
          def test
            a = 1
            b = 2
          end
          end

          set_trace_func proc { |event, file, line, id, binding, classname|
             printf "%8s %s:%-2d %10s %8s\n", event, file, line, id, classname
          }
          t = Test.new
          t.test

            line prog.rb:11               false
          c-call prog.rb:11        new    Class
          c-call prog.rb:11 initialize   Object
        c-return prog.rb:11 initialize   Object
        c-return prog.rb:11        new    Class
            line prog.rb:12               false
            call prog.rb:2        test     Test
            line prog.rb:3        test     Test
            line prog.rb:4        test     Test
          return prog.rb:4        test     Test
    warn: |2-

      If warnings have been disabled (for example with the
      <code>-W0</code> flag), does nothing.  Otherwise,
      converts each of the messages to strings, appends a newline
      character to the string if the string does not end in a newline,
      and calls Warning.warn with the string.

         warn("warning 1", "warning 2")

       <em>produces:</em>

         warning 1
         warning 2

      If the <code>uplevel</code> keyword argument is given, the string will
      be prepended with information for the given caller frame in
      the same format used by the <code>rb_warn</code> C function.

         # In baz.rb
         def foo
           warn("invalid call to foo", uplevel: 1)
         end

         def bar
           foo
         end

         bar

       <em>produces:</em>

         baz.rb:6: warning: invalid call to foo
KeyError:
  main: |-
    Raised when the specified key is not found. It is a subclass of
    IndexError.

       h = {"foo" => :bar}
       h.fetch("foo") #=> :bar
       h.fetch("baz") #=> KeyError: key not found: "baz"
LoadError:
  main: |-
    Raised when a file required (a Ruby script, extension library, ...)
    fails to load.

       require 'this/file/does/not/exist'

    <em>raises the exception:</em>

       LoadError: no such file to load -- this/file/does/not/exist
LocalJumpError:
  main: |-
    Raised when Ruby can't yield as requested.

    A typical scenario is attempting to yield when no block is given:

       def call_block
         yield 42
       end
       call_block

    <em>raises the exception:</em>

       LocalJumpError: no block given (yield)

    A more subtle example:

       def get_me_a_return
         Proc.new { return 42 }
       end
       get_me_a_return.call

    <em>raises the exception:</em>

       LocalJumpError: unexpected return
Marshal:
  main: |-
    The marshaling library converts collections of Ruby objects into a
    byte stream, allowing them to be stored outside the currently
    active script. This data may subsequently be read and the original
    objects reconstituted.

    Marshaled data has major and minor version numbers stored along
    with the object information. In normal use, marshaling can only
    load data written with the same major version number and an equal
    or lower minor version number. If Ruby's ``verbose'' flag is set
    (normally using -d, -v, -w, or --verbose) the major and minor
    numbers must match exactly. Marshal versioning is independent of
    Ruby's version numbers. You can extract the version by reading the
    first two bytes of marshaled data.

        str = Marshal.dump("thing")
        RUBY_VERSION   #=> "1.9.0"
        str[0].ord     #=> 4
        str[1].ord     #=> 8

    Some objects cannot be dumped: if the objects to be dumped include
    bindings, procedure or method objects, instances of class IO, or
    singleton objects, a TypeError will be raised.

    If your class has special serialization needs (for example, if you
    want to serialize in some specific format), or if it contains
    objects that would otherwise not be serializable, you can implement
    your own serialization strategy.

    There are two methods of doing this, your object can define either
    marshal_dump and marshal_load or _dump and _load.  marshal_dump will take
    precedence over _dump if both are defined.  marshal_dump may result in
    smaller Marshal strings.

    == Security considerations

    By design, Marshal.load can deserialize almost any class loaded into the
    Ruby process. In many cases this can lead to remote code execution if the
    Marshal data is loaded from an untrusted source.

    As a result, Marshal.load is not suitable as a general purpose serialization
    format and you should never unmarshal user supplied input or other untrusted
    data.

    If you need to deserialize untrusted data, use JSON or another serialization
    format that is only able to load simple, 'primitive' types such as String,
    Array, Hash, etc. Never allow user input to specify arbitrary types to
    deserialize into.

    == marshal_dump and marshal_load

    When dumping an object the method marshal_dump will be called.
    marshal_dump must return a result containing the information necessary for
    marshal_load to reconstitute the object.  The result can be any object.

    When loading an object dumped using marshal_dump the object is first
    allocated then marshal_load is called with the result from marshal_dump.
    marshal_load must recreate the object from the information in the result.

    Example:

      class MyObj
        def initialize name, version, data
          @name    = name
          @version = version
          @data    = data
        end

        def marshal_dump
          [@name, @version]
        end

        def marshal_load array
          @name, @version = array
        end
      end

    == _dump and _load

    Use _dump and _load when you need to allocate the object you're restoring
    yourself.

    When dumping an object the instance method _dump is called with an Integer
    which indicates the maximum depth of objects to dump (a value of -1 implies
    that you should disable depth checking).  _dump must return a String
    containing the information necessary to reconstitute the object.

    The class method _load should take a String and use it to return an object
    of the same class.

    Example:

      class MyObj
        def initialize name, version, data
          @name    = name
          @version = version
          @data    = data
        end

        def _dump level
          [@name, @version].join ':'
        end

        def self._load args
          new(*args.split(':'))
        end
      end

    Since Marshal.dump outputs a string you can have _dump return a Marshal
    string which is Marshal.loaded in _load for complex objects.
MatchData:
  main: |-
    MatchData encapsulates the result of matching a Regexp against
    string. It is returned by Regexp#match and String#match, and also
    stored in a global variable returned by Regexp.last_match.

    Usage:

        url = 'https://docs.ruby-lang.org/en/2.5.0/MatchData.html'
        m = url.match(/(\d\.?)+/)   # => #<MatchData "2.5.0" 1:"0">
        m.string                    # => "https://docs.ruby-lang.org/en/2.5.0/MatchData.html"
        m.regexp                    # => /(\d\.?)+/
        # entire matched substring:
        m[0]                        # => "2.5.0"

        # Working with unnamed captures
        m = url.match(%r{([^/]+)/([^/]+)\.html$})
        m.captures                  # => ["2.5.0", "MatchData"]
        m[1]                        # => "2.5.0"
        m.values_at(1, 2)           # => ["2.5.0", "MatchData"]

        # Working with named captures
        m = url.match(%r{(?<version>[^/]+)/(?<module>[^/]+)\.html$})
        m.captures                  # => ["2.5.0", "MatchData"]
        m.named_captures            # => {"version"=>"2.5.0", "module"=>"MatchData"}
        m[:version]                 # => "2.5.0"
        m.values_at(:version, :module)
                                    # => ["2.5.0", "MatchData"]
        # Numerical indexes are working, too
        m[1]                        # => "2.5.0"
        m.values_at(1, 2)           # => ["2.5.0", "MatchData"]

    == Global variables equivalence

    Parts of last MatchData (returned by Regexp.last_match) are also
    aliased as global variables:

    * <code>$~</code> is Regexp.last_match;
    * <code>$&</code> is Regexp.last_match<code>[0]</code>;
    * <code>$1</code>, <code>$2</code>, and so on are
      Regexp.last_match<code>[i]</code> (captures by number);
    * <code>$`</code> is Regexp.last_match<code>.pre_match</code>;
    * <code>$'</code> is Regexp.last_match<code>.post_match</code>;
    * <code>$+</code> is Regexp.last_match<code>[-1]</code> (the last capture).

    See also "Special global variables" section in Regexp documentation.
Math:
  main: |-
    The Math module contains module functions for basic
    trigonometric and transcendental functions. See class
    Float for a list of constants that
    define Ruby's floating point accuracy.

    Domains and codomains are given only for real (not complex) numbers.
Math::DomainError:
  main: |-
    Raised when a mathematical function is evaluated outside of its
    domain of definition.

    For example, since +cos+ returns values in the range -1..1,
    its inverse function +acos+ is only defined on that interval:

       Math.acos(42)

    <em>produces:</em>

       Math::DomainError: Numerical argument is out of domain - "acos"
Method:
  main: |-
    Method objects are created by Object#method, and are associated
    with a particular object (not just with a class).  They may be
    used to invoke the method within the object, and as a block
    associated with an iterator.  They may also be unbound from one
    object (creating an UnboundMethod) and bound to another.

       class Thing
         def square(n)
           n*n
         end
       end
       thing = Thing.new
       meth  = thing.method(:square)

       meth.call(9)                 #=> 81
       [ 1, 2, 3 ].collect(&meth)   #=> [1, 4, 9]

       [ 1, 2, 3 ].each(&method(:puts)) #=> prints 1, 2, 3

       require 'date'
       %w[2017-03-01 2017-03-02].collect(&Date.method(:parse))
       #=> [#<Date: 2017-03-01 ((2457814j,0s,0n),+0s,2299161j)>, #<Date: 2017-03-02 ((2457815j,0s,0n),+0s,2299161j)>]
Module:
  main: |-
    A Module is a collection of methods and constants. The
    methods in a module may be instance methods or module methods.
    Instance methods appear as methods in a class when the module is
    included, module methods do not. Conversely, module methods may be
    called without creating an encapsulating object, while instance
    methods may not. (See Module#module_function.)

    In the descriptions that follow, the parameter <i>sym</i> refers
    to a symbol, which is either a quoted string or a
    Symbol (such as <code>:name</code>).

       module Mod
         include Math
         CONST = 1
         def meth
           #  ...
         end
       end
       Mod.class              #=> Module
       Mod.constants          #=> [:CONST, :PI, :E]
       Mod.instance_methods   #=> [:meth]
Mutex:
  main: |-
    Mutex implements a simple semaphore that can be used to coordinate access to
    shared data from multiple concurrent threads.

    Example:

      semaphore = Mutex.new

      a = Thread.new {
        semaphore.synchronize {
          # access shared resource
        }
      }

      b = Thread.new {
        semaphore.synchronize {
          # access shared resource
        }
      }
NameError:
  main: |-
    Raised when a given name is invalid or undefined.

       puts foo

    <em>raises the exception:</em>

       NameError: undefined local variable or method `foo' for main:Object

    Since constant names must start with a capital:

       Integer.const_set :answer, 42

    <em>raises the exception:</em>

       NameError: wrong constant name answer
NilClass:
  main: The class of the singleton object <code>nil</code>.
NoMemoryError:
  main: Raised when memory allocation fails.
NoMethodError:
  main: |-
    Raised when a method is called on a receiver which doesn't have it
    defined and also fails to respond with +method_missing+.

       "hello".to_ary

    <em>raises the exception:</em>

       NoMethodError: undefined method `to_ary' for "hello":String
NotImplementedError:
  main: |-
    Raised when a feature is not implemented on the current platform. For
    example, methods depending on the +fsync+ or +fork+ system calls may
    raise this exception if the underlying operating system or Ruby
    runtime does not support them.

    Note that if +fork+ raises a +NotImplementedError+, then
    <code>respond_to?(:fork)</code> returns +false+.
Numeric:
  main: |-
    Numeric is the class from which all higher-level numeric classes should inherit.

    Numeric allows instantiation of heap-allocated objects. Other core numeric classes such as
    Integer are implemented as immediates, which means that each Integer is a single immutable
    object which is always passed by value.

      a = 1
      1.object_id == a.object_id   #=> true

    There can only ever be one instance of the integer +1+, for example. Ruby ensures this
    by preventing instantiation. If duplication is attempted, the same instance is returned.

      Integer.new(1)                   #=> NoMethodError: undefined method `new' for Integer:Class
      1.dup                            #=> 1
      1.object_id == 1.dup.object_id   #=> true

    For this reason, Numeric should be used when defining other numeric classes.

    Classes which inherit from Numeric must implement +coerce+, which returns a two-member
    Array containing an object that has been coerced into an instance of the new class
    and +self+ (see #coerce).

    Inheriting classes should also implement arithmetic operator methods (<code>+</code>,
    <code>-</code>, <code>*</code> and <code>/</code>) and the <code><=></code> operator (see
    Comparable). These methods may rely on +coerce+ to ensure interoperability with
    instances of other numeric classes.

      class Tally < Numeric
        def initialize(string)
          @string = string
        end

        def to_s
          @string
        end

        def to_i
          @string.size
        end

        def coerce(other)
          [self.class.new('|' * other.to_i), self]
        end

        def <=>(other)
          to_i <=> other.to_i
        end

        def +(other)
          self.class.new('|' * (to_i + other.to_i))
        end

        def -(other)
          self.class.new('|' * (to_i - other.to_i))
        end

        def *(other)
          self.class.new('|' * (to_i * other.to_i))
        end

        def /(other)
          self.class.new('|' * (to_i / other.to_i))
        end
      end

      tally = Tally.new('||')
      puts tally * 2            #=> "||||"
      puts tally > 1            #=> true
Object:
  main: |-
    Object is the default root of all Ruby objects.  Object inherits from
    BasicObject which allows creating alternate object hierarchies.  Methods
    on Object are available to all classes unless explicitly overridden.

    Object mixes in the Kernel module, making the built-in kernel functions
    globally accessible.  Although the instance methods of Object are defined
    by the Kernel module, we have chosen to document them here for clarity.

    When referencing constants in classes inheriting from Object you do not
    need to use the full namespace.  For example, referencing +File+ inside
    +YourClass+ will find the top-level File class.

    In the descriptions of Object's methods, the parameter <i>symbol</i> refers
    to a symbol, which is either a quoted string or a Symbol (such as
    <code>:name</code>).
ObjectSpace:
  main: |-
    The ObjectSpace module contains a number of routines
    that interact with the garbage collection facility and allow you to
    traverse all living objects with an iterator.

    ObjectSpace also provides support for object finalizers, procs that will be
    called when a specific object is about to be destroyed by garbage
    collection.

       require 'objspace'

       a = "A"
       b = "B"

       ObjectSpace.define_finalizer(a, proc {|id| puts "Finalizer one on #{id}" })
       ObjectSpace.define_finalizer(b, proc {|id| puts "Finalizer two on #{id}" })

    _produces:_

       Finalizer two on 537763470
       Finalizer one on 537763480
ObjectSpace::WeakMap:
  main: |-
    An ObjectSpace::WeakMap object holds references to
    any objects, but those objects can get garbage collected.

    This class is mostly used internally by WeakRef, please use
    +lib/weakref.rb+ for the public interface.
Proc:
  main: |-
    A +Proc+ object is an encapsulation of a block of code, which can be stored
    in a local variable, passed to a method or another Proc, and can be called.
    Proc is an essential concept in Ruby and a core of its functional
    programming features.

         square = Proc.new {|x| x**2 }

         square.call(3)  #=> 9
         # shorthands:
         square.(3)      #=> 9
         square[3]       #=> 9

    Proc objects are _closures_, meaning they remember and can use the entire
    context in which they were created.

        def gen_times(factor)
          Proc.new {|n| n*factor } # remembers the value of factor at the moment of creation
        end

        times3 = gen_times(3)
        times5 = gen_times(5)

        times3.call(12)               #=> 36
        times5.call(5)                #=> 25
        times3.call(times5.call(4))   #=> 60

    == Creation

    There are several methods to create a Proc

    * Use the Proc class constructor:

         proc1 = Proc.new {|x| x**2 }

    * Use the Kernel#proc method as a shorthand of Proc.new:

         proc2 = proc {|x| x**2 }

    * Receiving a block of code into proc argument (note the <code>&</code>):

         def make_proc(&block)
           block
         end

         proc3 = make_proc {|x| x**2 }

    * Construct a proc with lambda semantics using the Kernel#lambda method
      (see below for explanations about lambdas):

         lambda1 = lambda {|x| x**2 }

    * Use the Lambda literal syntax (also constructs a proc with lambda semantics):

         lambda2 = ->(x) { x**2 }

    == Lambda and non-lambda semantics

    Procs are coming in two flavors: lambda and non-lambda (regular procs).
    Differences are:

    * In lambdas, +return+ and +break+ means exit from this lambda;
    * In non-lambda procs, +return+ means exit from embracing method
      (and will throw +LocalJumpError+ if invoked outside the method);
    * In non-lambda procs, +break+ means exit from the method which the block given for.
      (and will throw +LocalJumpError+ if invoked after the method returns);
    * In lambdas, arguments are treated in the same way as in methods: strict,
      with +ArgumentError+ for mismatching argument number,
      and no additional argument processing;
    * Regular procs accept arguments more generously: missing arguments
      are filled with +nil+, single Array arguments are deconstructed if the
      proc has multiple arguments, and there is no error raised on extra
      arguments.

    Examples:

         # +return+ in non-lambda proc, +b+, exits +m2+.
         # (The block +{ return }+ is given for +m1+ and embraced by +m2+.)
         $a = []; def m1(&b) b.call; $a << :m1 end; def m2() m1 { return }; $a << :m2 end; m2; p $a
         #=> []

         # +break+ in non-lambda proc, +b+, exits +m1+.
         # (The block +{ break }+ is given for +m1+ and embraced by +m2+.)
         $a = []; def m1(&b) b.call; $a << :m1 end; def m2() m1 { break }; $a << :m2 end; m2; p $a
         #=> [:m2]

         # +next+ in non-lambda proc, +b+, exits the block.
         # (The block +{ next }+ is given for +m1+ and embraced by +m2+.)
         $a = []; def m1(&b) b.call; $a << :m1 end; def m2() m1 { next }; $a << :m2 end; m2; p $a
         #=> [:m1, :m2]

         # Using +proc+ method changes the behavior as follows because
         # The block is given for +proc+ method and embraced by +m2+.
         $a = []; def m1(&b) b.call; $a << :m1 end; def m2() m1(&proc { return }); $a << :m2 end; m2; p $a
         #=> []
         $a = []; def m1(&b) b.call; $a << :m1 end; def m2() m1(&proc { break }); $a << :m2 end; m2; p $a
         # break from proc-closure (LocalJumpError)
         $a = []; def m1(&b) b.call; $a << :m1 end; def m2() m1(&proc { next }); $a << :m2 end; m2; p $a
         #=> [:m1, :m2]

         # +return+, +break+ and +next+ in the stubby lambda exits the block.
         # (+lambda+ method behaves same.)
         # (The block is given for stubby lambda syntax and embraced by +m2+.)
         $a = []; def m1(&b) b.call; $a << :m1 end; def m2() m1(&-> { return }); $a << :m2 end; m2; p $a
         #=> [:m1, :m2]
         $a = []; def m1(&b) b.call; $a << :m1 end; def m2() m1(&-> { break }); $a << :m2 end; m2; p $a
         #=> [:m1, :m2]
         $a = []; def m1(&b) b.call; $a << :m1 end; def m2() m1(&-> { next }); $a << :m2 end; m2; p $a
         #=> [:m1, :m2]

         p = proc {|x, y| "x=#{x}, y=#{y}" }
         p.call(1, 2)      #=> "x=1, y=2"
         p.call([1, 2])    #=> "x=1, y=2", array deconstructed
         p.call(1, 2, 8)   #=> "x=1, y=2", extra argument discarded
         p.call(1)         #=> "x=1, y=", nil substituted instead of error

         l = lambda {|x, y| "x=#{x}, y=#{y}" }
         l.call(1, 2)      #=> "x=1, y=2"
         l.call([1, 2])    # ArgumentError: wrong number of arguments (given 1, expected 2)
         l.call(1, 2, 8)   # ArgumentError: wrong number of arguments (given 3, expected 2)
         l.call(1)         # ArgumentError: wrong number of arguments (given 1, expected 2)

         def test_return
           -> { return 3 }.call      # just returns from lambda into method body
           proc { return 4 }.call    # returns from method
           return 5
         end

         test_return # => 4, return from proc

    Lambdas are useful as self-sufficient functions, in particular useful as
    arguments to higher-order functions, behaving exactly like Ruby methods.

    Procs are useful for implementing iterators:

         def test
           [[1, 2], [3, 4], [5, 6]].map {|a, b| return a if a + b > 10 }
                                     #  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
         end

    Inside +map+, the block of code is treated as a regular (non-lambda) proc,
    which means that the internal arrays will be deconstructed to pairs of
    arguments, and +return+ will exit from the method +test+. That would
    not be possible with a stricter lambda.

    You can tell a lambda from a regular proc by using the #lambda? instance method.

    Lambda semantics is typically preserved during the proc lifetime, including
    <code>&</code>-deconstruction to a block of code:

         p = proc {|x, y| x }
         l = lambda {|x, y| x }
         [[1, 2], [3, 4]].map(&p) #=> [1, 2]
         [[1, 2], [3, 4]].map(&l) # ArgumentError: wrong number of arguments (given 1, expected 2)

    The only exception is dynamic method definition: even if defined by
    passing a non-lambda proc, methods still have normal semantics of argument
    checking.

      class C
        define_method(:e, &proc {})
      end
      C.new.e(1,2)       #=> ArgumentError
      C.new.method(:e).to_proc.lambda?   #=> true

    This exception ensures that methods never have unusual argument passing
    conventions, and makes it easy to have wrappers defining methods that
    behave as usual.

      class C
        def self.def2(name, &body)
          define_method(name, &body)
        end

        def2(:f) {}
      end
      C.new.f(1,2)       #=> ArgumentError

    The wrapper <code>def2</code> receives _body_ as a non-lambda proc,
    yet defines a method which has normal semantics.

    == Conversion of other objects to procs

    Any object that implements the +to_proc+ method can be converted into
    a proc by the <code>&</code> operator, and therefore con be
    consumed by iterators.

         class Greeter
           def initialize(greeting)
             @greeting = greeting
           end

           def to_proc
             proc {|name| "#{@greeting}, #{name}!" }
           end
         end

         hi = Greeter.new("Hi")
         hey = Greeter.new("Hey")
         ["Bob", "Jane"].map(&hi)    #=> ["Hi, Bob!", "Hi, Jane!"]
         ["Bob", "Jane"].map(&hey)   #=> ["Hey, Bob!", "Hey, Jane!"]

    Of the Ruby core classes, this method is implemented by Symbol,
    Method, and Hash.

         :to_s.to_proc.call(1)           #=> "1"
         [1, 2].map(&:to_s)              #=> ["1", "2"]

         method(:puts).to_proc.call(1)   # prints 1
         [1, 2].each(&method(:puts))     # prints 1, 2

         {test: 1}.to_proc.call(:test)       #=> 1
         %i[test many keys].map(&{test: 1})  #=> [1, nil, nil]

    == Orphaned Proc

    +return+ and +break+ in a block exit a method.
    If a Proc object is generated from the block and the Proc object
    survives until the method is returned, +return+ and +break+ cannot work.
    In such case, +return+ and +break+ raises LocalJumpError.
    A Proc object in such situation is called as orphaned Proc object.

    Note that the method to exit is different for +return+ and +break+.
    There is a situation that orphaned for +break+ but not orphaned for +return+.

        def m1(&b) b.call end; def m2(); m1 { return } end; m2 # ok
        def m1(&b) b.call end; def m2(); m1 { break } end; m2 # ok

        def m1(&b) b end; def m2(); m1 { return }.call end; m2 # ok
        def m1(&b) b end; def m2(); m1 { break }.call end; m2 # LocalJumpError

        def m1(&b) b end; def m2(); m1 { return } end; m2.call # LocalJumpError
        def m1(&b) b end; def m2(); m1 { break } end; m2.call # LocalJumpError

    Since +return+ and +break+ exits the block itself in lambdas,
    lambdas cannot be orphaned.

    == Numbered parameters

    Numbered parameters are implicitly defined block parameters intended to
    simplify writing short blocks:

        # Explicit parameter:
        %w[test me please].each { |str| puts str.upcase } # prints TEST, ME, PLEASE
        (1..5).map { |i| i**2 } # => [1, 4, 9, 16, 25]

        # Implicit parameter:
        %w[test me please].each { puts _1.upcase } # prints TEST, ME, PLEASE
        (1..5).map { _1**2 } # => [1, 4, 9, 16, 25]

    Parameter names from +_1+ to +_9+ are supported:

        [10, 20, 30].zip([40, 50, 60], [70, 80, 90]).map { _1 + _2 + _3 }
        # => [120, 150, 180]

    Though, it is advised to resort to them wisely, probably limiting
    yourself to +_1+ and +_2+, and to one-line blocks.

    Numbered parameters can't be used together with explicitly named
    ones:

        [10, 20, 30].map { |x| _1**2 }
        # SyntaxError (ordinary parameter is defined)

    To avoid conflicts, naming local variables or method
    arguments +_1+, +_2+ and so on, causes a warning.

        _1 = 'test'
        # warning: `_1' is reserved as numbered parameter

    Using implicit numbered parameters affects block's arity:

        p = proc { _1 + _2 }
        l = lambda { _1 + _2 }
        p.parameters     # => [[:opt, :_1], [:opt, :_2]]
        p.arity          # => 2
        l.parameters     # => [[:req, :_1], [:req, :_2]]
        l.arity          # => 2

    Blocks with numbered parameters can't be nested:

        %w[test me].each { _1.each_char { p _1 } }
        # SyntaxError (numbered parameter is already used in outer block here)
        # %w[test me].each { _1.each_char { p _1 } }
        #                    ^~

    Numbered parameters were introduced in Ruby 2.7.
Process:
  main: |-
    The module contains several groups of functionality for handling OS processes:

    * Low-level property introspection and management of the current process, like
      Process.argv0, Process.pid;
    * Low-level introspection of other processes, like Process.getpgid, Process.getpriority;
    * Management of the current process: Process.abort, Process.exit, Process.daemon, etc.
      (for convenience, most of those are also available as global functions
      and module functions of Kernel);
    * Creation and management of child processes: Process.fork, Process.spawn, and
      related methods;
    * Management of low-level system clock: Process.times and Process.clock_gettime,
      which could be important for proper benchmarking and other elapsed
      time measurement tasks.
Process::GID:
  main: |-
    The Process::GID module contains a collection of
    module functions which can be used to portably get, set, and
    switch the current process's real, effective, and saved group IDs.
Process::Status:
  main: |-
    Process::Status encapsulates the information on the
    status of a running or terminated system process. The built-in
    variable <code>$?</code> is either +nil+ or a
    Process::Status object.

       fork { exit 99 }   #=> 26557
       Process.wait       #=> 26557
       $?.class           #=> Process::Status
       $?.to_i            #=> 25344
       $? >> 8            #=> 99
       $?.stopped?        #=> false
       $?.exited?         #=> true
       $?.exitstatus      #=> 99

    Posix systems record information on processes using a 16-bit
    integer.  The lower bits record the process status (stopped,
    exited, signaled) and the upper bits possibly contain additional
    information (for example the program's return code in the case of
    exited processes). Pre Ruby 1.8, these bits were exposed directly
    to the Ruby program. Ruby now encapsulates these in a
    Process::Status object. To maximize compatibility,
    however, these objects retain a bit-oriented interface. In the
    descriptions that follow, when we talk about the integer value of
    _stat_, we're referring to this 16 bit value.
Process::Sys:
  main: |-
    The Process::Sys module contains UID and GID
    functions which provide direct bindings to the system calls of the
    same names instead of the more-portable versions of the same
    functionality found in the Process,
    Process::UID, and Process::GID modules.
Process::UID:
  main: |-
    The Process::UID module contains a collection of
    module functions which can be used to portably get, set, and
    switch the current process's real, effective, and saved user IDs.
Queue:
  main: |-
    The Queue class implements multi-producer, multi-consumer queues.
    It is especially useful in threaded programming when information
    must be exchanged safely between multiple threads. The Queue class
    implements all the required locking semantics.

    The class implements FIFO type of queue. In a FIFO queue, the first
    tasks added are the first retrieved.

    Example:

        queue = Queue.new

        producer = Thread.new do
          5.times do |i|
             sleep rand(i) # simulate expense
             queue << i
             puts "#{i} produced"
          end
        end

        consumer = Thread.new do
          5.times do |i|
             value = queue.pop
             sleep rand(i/2) # simulate expense
             puts "consumed #{value}"
          end
        end

        consumer.join
Random:
  main: |-
    Random provides an interface to Ruby's pseudo-random number generator, or
    PRNG.  The PRNG produces a deterministic sequence of bits which approximate
    true randomness. The sequence may be represented by integers, floats, or
    binary strings.

    The generator may be initialized with either a system-generated or
    user-supplied seed value by using Random.srand.

    The class method Random.rand provides the base functionality of Kernel.rand
    along with better handling of floating point values. These are both
    interfaces to Random::DEFAULT, the Ruby system PRNG.

    Random.new will create a new PRNG with a state independent of
    Random::DEFAULT, allowing multiple generators with different seed values or
    sequence positions to exist simultaneously. Random objects can be
    marshaled, allowing sequences to be saved and resumed.

    PRNGs are currently implemented as a modified Mersenne Twister with a period
    of 2**19937-1.
Random::Formatter:
  main: 'Format raw random number as Random does   '
Range:
  main: |-
    A Range represents an interval---a set of values with a
    beginning and an end. Ranges may be constructed using the
    <em>s</em><code>..</code><em>e</em> and
    <em>s</em><code>...</code><em>e</em> literals, or with
    Range::new. Ranges constructed using <code>..</code>
    run from the beginning to the end inclusively. Those created using
    <code>...</code> exclude the end value. When used as an iterator,
    ranges return each value in the sequence.

       (-1..-5).to_a      #=> []
       (-5..-1).to_a      #=> [-5, -4, -3, -2, -1]
       ('a'..'e').to_a    #=> ["a", "b", "c", "d", "e"]
       ('a'...'e').to_a   #=> ["a", "b", "c", "d"]

    == Beginless/Endless Ranges

    A "beginless range" and "endless range" represents a semi-infinite
    range.  Literal notation for a beginless range is:

       (..1)
       # or
       (...1)

    Literal notation for an endless range is:

       (1..)
       # or similarly
       (1...)

    Which is equivalent to

       (1..nil)  # or similarly (1...nil)
       Range.new(1, nil) # or Range.new(1, nil, true)

    Beginless/endless ranges are useful, for example, for idiomatic
    slicing of arrays:

      [1, 2, 3, 4, 5][...2]   # => [1, 2]
      [1, 2, 3, 4, 5][2...]   # => [3, 4, 5]

    Some implementation details:

    * +begin+ of beginless range and +end+ of endless range are +nil+;
    * +each+ of beginless range raises an exception;
    * +each+ of endless range enumerates infinite sequence (may be
      useful in combination with Enumerable#take_while or similar
      methods);
    * <code>(1..)</code> and <code>(1...)</code> are not equal,
      although technically representing the same sequence.

    == Custom Objects in Ranges

    Ranges can be constructed using any objects that can be compared
    using the <code><=></code> operator.
    Methods that treat the range as a sequence (#each and methods inherited
    from Enumerable) expect the begin object to implement a
    <code>succ</code> method to return the next object in sequence.
    The #step and #include? methods require the begin
    object to implement <code>succ</code> or to be numeric.

    In the <code>Xs</code> class below both <code><=></code> and
    <code>succ</code> are implemented so <code>Xs</code> can be used
    to construct ranges. Note that the Comparable module is included
    so the <code>==</code> method is defined in terms of <code><=></code>.

       class Xs                # represent a string of 'x's
         include Comparable
         attr :length
         def initialize(n)
           @length = n
         end
         def succ
           Xs.new(@length + 1)
         end
         def <=>(other)
           @length <=> other.length
         end
         def to_s
           sprintf "%2d #{inspect}", @length
         end
         def inspect
           'x' * @length
         end
       end

    An example of using <code>Xs</code> to construct a range:

       r = Xs.new(3)..Xs.new(6)   #=> xxx..xxxxxx
       r.to_a                     #=> [xxx, xxxx, xxxxx, xxxxxx]
       r.member?(Xs.new(5))       #=> true
RangeError:
  main: |-
    Raised when a given numerical value is out of range.

       [1, 2, 3].drop(1 << 100)

    <em>raises the exception:</em>

       RangeError: bignum too big to convert into `long'
Rational:
  main: |-
    A rational number can be represented as a pair of integer numbers:
    a/b (b>0), where a is the numerator and b is the denominator.
    Integer a equals rational a/1 mathematically.

    In Ruby, you can create rational objects with the Kernel#Rational,
    to_r, or rationalize methods or by suffixing +r+ to a literal.
    The return values will be irreducible fractions.

       Rational(1)      #=> (1/1)
       Rational(2, 3)   #=> (2/3)
       Rational(4, -6)  #=> (-2/3)
       3.to_r           #=> (3/1)
       2/3r             #=> (2/3)

    You can also create rational objects from floating-point numbers or
    strings.

       Rational(0.3)    #=> (5404319552844595/18014398509481984)
       Rational('0.3')  #=> (3/10)
       Rational('2/3')  #=> (2/3)

       0.3.to_r         #=> (5404319552844595/18014398509481984)
       '0.3'.to_r       #=> (3/10)
       '2/3'.to_r       #=> (2/3)
       0.3.rationalize  #=> (3/10)

    A rational object is an exact number, which helps you to write
    programs without any rounding errors.

       10.times.inject(0) {|t| t + 0.1 }              #=> 0.9999999999999999
       10.times.inject(0) {|t| t + Rational('0.1') }  #=> (1/1)

    However, when an expression includes an inexact component (numerical value
    or operation), it will produce an inexact result.

       Rational(10) / 3   #=> (10/3)
       Rational(10) / 3.0 #=> 3.3333333333333335

       Rational(-8) ** Rational(1, 3)
                          #=> (1.0000000000000002+1.7320508075688772i)
Regexp:
  main: |+
    A Regexp holds a regular expression, used to match a pattern
    against strings. Regexps are created using the <code>/.../</code>
    and <code>%r{...}</code> literals, and by the Regexp::new
    constructor.

    Regular expressions (<i>regexp</i>s) are patterns which describe the
    contents of a string. They're used for testing whether a string contains a
    given pattern, or extracting the portions that match. They are created
    with the <tt>/</tt><i>pat</i><tt>/</tt> and
    <tt>%r{</tt><i>pat</i><tt>}</tt> literals or the <tt>Regexp.new</tt>
    constructor.

    A regexp is usually delimited with forward slashes (<tt>/</tt>). For
    example:

        /hay/ =~ 'haystack'   #=> 0
        /y/.match('haystack') #=> #<MatchData "y">

    If a string contains the pattern it is said to <i>match</i>. A literal
    string matches itself.

    Here 'haystack' does not contain the pattern 'needle', so it doesn't match:

        /needle/.match('haystack') #=> nil

    Here 'haystack' contains the pattern 'hay', so it matches:

        /hay/.match('haystack')    #=> #<MatchData "hay">

    Specifically, <tt>/st/</tt> requires that the string contains the letter
    _s_ followed by the letter _t_, so it matches _haystack_, also.

    == <tt>=~</tt> and Regexp#match

    Pattern matching may be achieved by using <tt>=~</tt> operator or Regexp#match
    method.

    === <tt>=~</tt> operator

    <tt>=~</tt> is Ruby's basic pattern-matching operator.  When one operand is a
    regular expression and the other is a string then the regular expression is
    used as a pattern to match against the string.  (This operator is equivalently
    defined by Regexp and String so the order of String and Regexp do not matter.
    Other classes may have different implementations of <tt>=~</tt>.)  If a match
    is found, the operator returns index of first match in string, otherwise it
    returns +nil+.

        /hay/ =~ 'haystack'   #=> 0
        'haystack' =~ /hay/   #=> 0
        /a/   =~ 'haystack'   #=> 1
        /u/   =~ 'haystack'   #=> nil

    Using <tt>=~</tt> operator with a String and Regexp the <tt>$~</tt> global
    variable is set after a successful match.  <tt>$~</tt> holds a MatchData
    object. Regexp.last_match is equivalent to <tt>$~</tt>.

    === Regexp#match method

    The #match method returns a MatchData object:

        /st/.match('haystack')   #=> #<MatchData "st">

    == Metacharacters and Escapes

    The following are <i>metacharacters</i> <tt>(</tt>, <tt>)</tt>,
    <tt>[</tt>, <tt>]</tt>, <tt>{</tt>, <tt>}</tt>, <tt>.</tt>, <tt>?</tt>,
    <tt>+</tt>, <tt>*</tt>. They have a specific meaning when appearing in a
    pattern. To match them literally they must be backslash-escaped. To match
    a backslash literally, backslash-escape it: <tt>\\\\</tt>.

        /1 \+ 2 = 3\?/.match('Does 1 + 2 = 3?') #=> #<MatchData "1 + 2 = 3?">
        /a\\\\b/.match('a\\\\b')                    #=> #<MatchData "a\\b">

    Patterns behave like double-quoted strings and can contain the same
    backslash escapes (the meaning of <tt>\s</tt> is different, however,
    see below[#label-Character+Classes]).

        /\s\u{6771 4eac 90fd}/.match("Go to 東京都")
            #=> #<MatchData " 東京都">

    Arbitrary Ruby expressions can be embedded into patterns with the
    <tt>#{...}</tt> construct.

        place = "東京都"
        /#{place}/.match("Go to 東京都")
            #=> #<MatchData "東京都">

    == Character Classes

    A <i>character class</i> is delimited with square brackets (<tt>[</tt>,
    <tt>]</tt>) and lists characters that may appear at that point in the
    match. <tt>/[ab]/</tt> means _a_ or _b_, as opposed to <tt>/ab/</tt> which
    means _a_ followed by _b_.

        /W[aeiou]rd/.match("Word") #=> #<MatchData "Word">

    Within a character class the hyphen (<tt>-</tt>) is a metacharacter
    denoting an inclusive range of characters. <tt>[abcd]</tt> is equivalent
    to <tt>[a-d]</tt>. A range can be followed by another range, so
    <tt>[abcdwxyz]</tt> is equivalent to <tt>[a-dw-z]</tt>. The order in which
    ranges or individual characters appear inside a character class is
    irrelevant.

        /[0-9a-f]/.match('9f') #=> #<MatchData "9">
        /[9f]/.match('9f')     #=> #<MatchData "9">

    If the first character of a character class is a caret (<tt>^</tt>) the
    class is inverted: it matches any character _except_ those named.

        /[^a-eg-z]/.match('f') #=> #<MatchData "f">

    A character class may contain another character class. By itself this
    isn't useful because <tt>[a-z[0-9]]</tt> describes the same set as
    <tt>[a-z0-9]</tt>. However, character classes also support the <tt>&&</tt>
    operator which performs set intersection on its arguments. The two can be
    combined as follows:

        /[a-w&&[^c-g]z]/ # ([a-w] AND ([^c-g] OR z))

    This is equivalent to:

        /[abh-w]/

    The following metacharacters also behave like character classes:

    * <tt>/./</tt> - Any character except a newline.
    * <tt>/./m</tt> - Any character (the +m+ modifier enables multiline mode)
    * <tt>/\w/</tt> - A word character (<tt>[a-zA-Z0-9_]</tt>)
    * <tt>/\W/</tt> - A non-word character (<tt>[^a-zA-Z0-9_]</tt>).
      Please take a look at {Bug #4044}[https://bugs.ruby-lang.org/issues/4044] if
      using <tt>/\W/</tt> with the <tt>/i</tt> modifier.
    * <tt>/\d/</tt> - A digit character (<tt>[0-9]</tt>)
    * <tt>/\D/</tt> - A non-digit character (<tt>[^0-9]</tt>)
    * <tt>/\h/</tt> - A hexdigit character (<tt>[0-9a-fA-F]</tt>)
    * <tt>/\H/</tt> - A non-hexdigit character (<tt>[^0-9a-fA-F]</tt>)
    * <tt>/\s/</tt> - A whitespace character: <tt>/[ \t\r\n\f\v]/</tt>
    * <tt>/\S/</tt> - A non-whitespace character: <tt>/[^ \t\r\n\f\v]/</tt>
    * <tt>/\R/</tt> - A linebreak: <tt>\n</tt>, <tt>\v</tt>, <tt>\f</tt>, <tt>\r</tt>
      <tt>\u0085</tt> (NEXT LINE), <tt>\u2028</tt> (LINE SEPARATOR), <tt>\u2029</tt> (PARAGRAPH SEPARATOR)
      or <tt>\r\n</tt>.

    POSIX <i>bracket expressions</i> are also similar to character classes.
    They provide a portable alternative to the above, with the added benefit
    that they encompass non-ASCII characters. For instance, <tt>/\d/</tt>
    matches only the ASCII decimal digits (0-9); whereas <tt>/[[:digit:]]/</tt>
    matches any character in the Unicode _Nd_ category.

    * <tt>/[[:alnum:]]/</tt> - Alphabetic and numeric character
    * <tt>/[[:alpha:]]/</tt> - Alphabetic character
    * <tt>/[[:blank:]]/</tt> - Space or tab
    * <tt>/[[:cntrl:]]/</tt> - Control character
    * <tt>/[[:digit:]]/</tt> - Digit
    * <tt>/[[:graph:]]/</tt> - Non-blank character (excludes spaces, control
      characters, and similar)
    * <tt>/[[:lower:]]/</tt> - Lowercase alphabetical character
    * <tt>/[[:print:]]/</tt> - Like [:graph:], but includes the space character
    * <tt>/[[:punct:]]/</tt> - Punctuation character
    * <tt>/[[:space:]]/</tt> - Whitespace character (<tt>[:blank:]</tt>, newline,
      carriage return, etc.)
    * <tt>/[[:upper:]]/</tt> - Uppercase alphabetical
    * <tt>/[[:xdigit:]]/</tt> - Digit allowed in a hexadecimal number (i.e.,
      0-9a-fA-F)

    Ruby also supports the following non-POSIX character classes:

    * <tt>/[[:word:]]/</tt> - A character in one of the following Unicode
      general categories _Letter_, _Mark_, _Number_,
      <i>Connector_Punctuation</i>
    * <tt>/[[:ascii:]]/</tt> - A character in the ASCII character set

        # U+06F2 is "EXTENDED ARABIC-INDIC DIGIT TWO"
        /[[:digit:]]/.match("\u06F2")    #=> #<MatchData "\u{06F2}">
        /[[:upper:]][[:lower:]]/.match("Hello") #=> #<MatchData "He">
        /[[:xdigit:]][[:xdigit:]]/.match("A6")  #=> #<MatchData "A6">

    == Repetition

    The constructs described so far match a single character. They can be
    followed by a repetition metacharacter to specify how many times they need
    to occur. Such metacharacters are called <i>quantifiers</i>.

    * <tt>*</tt> - Zero or more times
    * <tt>+</tt> - One or more times
    * <tt>?</tt> - Zero or one times (optional)
    * <tt>{</tt><i>n</i><tt>}</tt> - Exactly <i>n</i> times
    * <tt>{</tt><i>n</i><tt>,}</tt> - <i>n</i> or more times
    * <tt>{,</tt><i>m</i><tt>}</tt> - <i>m</i> or less times
    * <tt>{</tt><i>n</i><tt>,</tt><i>m</i><tt>}</tt> - At least <i>n</i> and
      at most <i>m</i> times

    At least one uppercase character ('H'), at least one lowercase character
    ('e'), two 'l' characters, then one 'o':

        "Hello".match(/[[:upper:]]+[[:lower:]]+l{2}o/) #=> #<MatchData "Hello">

    Repetition is <i>greedy</i> by default: as many occurrences as possible
    are matched while still allowing the overall match to succeed. By
    contrast, <i>lazy</i> matching makes the minimal amount of matches
    necessary for overall success. Most greedy metacharacters can be made lazy
    by following them with <tt>?</tt>. For the <tt>{n}</tt> pattern, because
    it specifies an exact number of characters to match and not a variable
    number of characters, the <tt>?</tt> metacharacter instead makes the
    repeated pattern optional.

    Both patterns below match the string. The first uses a greedy quantifier so
    '.+' matches '<a><b>'; the second uses a lazy quantifier so '.+?' matches
    '<a>':

        /<.+>/.match("<a><b>")  #=> #<MatchData "<a><b>">
        /<.+?>/.match("<a><b>") #=> #<MatchData "<a>">

    A quantifier followed by <tt>+</tt> matches <i>possessively</i>: once it
    has matched it does not backtrack. They behave like greedy quantifiers,
    but having matched they refuse to "give up" their match even if this
    jeopardises the overall match.

    == Capturing

    Parentheses can be used for <i>capturing</i>. The text enclosed by the
    <i>n</i><sup>th</sup> group of parentheses can be subsequently referred to
    with <i>n</i>. Within a pattern use the <i>backreference</i>
    <tt>\n</tt>; outside of the pattern use
    <tt>MatchData[</tt><i>n</i><tt>]</tt>.

    'at' is captured by the first group of parentheses, then referred to later
    with <tt>\1</tt>:

        /[csh](..) [csh]\1 in/.match("The cat sat in the hat")
            #=> #<MatchData "cat sat in" 1:"at">

    Regexp#match returns a MatchData object which makes the captured text
    available with its #[] method:

        /[csh](..) [csh]\1 in/.match("The cat sat in the hat")[1] #=> 'at'

    Capture groups can be referred to by name when defined with the
    <tt>(?<</tt><i>name</i><tt>>)</tt> or <tt>(?'</tt><i>name</i><tt>')</tt>
    constructs.

        /\$(?<dollars>\d+)\.(?<cents>\d+)/.match("$3.67")
            #=> #<MatchData "$3.67" dollars:"3" cents:"67">
        /\$(?<dollars>\d+)\.(?<cents>\d+)/.match("$3.67")[:dollars] #=> "3"

    Named groups can be backreferenced with <tt>\k<</tt><i>name</i><tt>></tt>,
    where _name_ is the group name.

        /(?<vowel>[aeiou]).\k<vowel>.\k<vowel>/.match('ototomy')
            #=> #<MatchData "ototo" vowel:"o">

    *Note*: A regexp can't use named backreferences and numbered
    backreferences simultaneously. Also, if a named capture is used in a
    regexp, then parentheses used for grouping which would otherwise result
    in a unnamed capture are treated as non-capturing.

        /(\w)(\w)/.match("ab").captures # => ["a", "b"]
        /(\w)(\w)/.match("ab").named_captures # => {}

        /(?<c>\w)(\w)/.match("ab").captures # => ["a"]
        /(?<c>\w)(\w)/.match("ab").named_captures # => {"c"=>"a"}

    When named capture groups are used with a literal regexp on the left-hand
    side of an expression and the <tt>=~</tt> operator, the captured text is
    also assigned to local variables with corresponding names.

        /\$(?<dollars>\d+)\.(?<cents>\d+)/ =~ "$3.67" #=> 0
        dollars #=> "3"

    == Grouping

    Parentheses also <i>group</i> the terms they enclose, allowing them to be
    quantified as one <i>atomic</i> whole.

    The pattern below matches a vowel followed by 2 word characters:

        /[aeiou]\w{2}/.match("Caenorhabditis elegans") #=> #<MatchData "aen">

    Whereas the following pattern matches a vowel followed by a word character,
    twice, i.e. <tt>[aeiou]\w[aeiou]\w</tt>: 'enor'.

        /([aeiou]\w){2}/.match("Caenorhabditis elegans")
            #=> #<MatchData "enor" 1:"or">

    The <tt>(?:</tt>...<tt>)</tt> construct provides grouping without
    capturing. That is, it combines the terms it contains into an atomic whole
    without creating a backreference. This benefits performance at the slight
    expense of readability.

    The first group of parentheses captures 'n' and the second 'ti'. The second
    group is referred to later with the backreference <tt>\2</tt>:

        /I(n)ves(ti)ga\2ons/.match("Investigations")
            #=> #<MatchData "Investigations" 1:"n" 2:"ti">

    The first group of parentheses is now made non-capturing with '?:', so it
    still matches 'n', but doesn't create the backreference. Thus, the
    backreference <tt>\1</tt> now refers to 'ti'.

        /I(?:n)ves(ti)ga\1ons/.match("Investigations")
            #=> #<MatchData "Investigations" 1:"ti">

    === Atomic Grouping

    Grouping can be made <i>atomic</i> with
    <tt>(?></tt><i>pat</i><tt>)</tt>. This causes the subexpression <i>pat</i>
    to be matched independently of the rest of the expression such that what
    it matches becomes fixed for the remainder of the match, unless the entire
    subexpression must be abandoned and subsequently revisited. In this
    way <i>pat</i> is treated as a non-divisible whole. Atomic grouping is
    typically used to optimise patterns so as to prevent the regular
    expression engine from backtracking needlessly.

    The <tt>"</tt> in the pattern below matches the first character of the string,
    then <tt>.*</tt> matches <i>Quote"</i>. This causes the overall match to fail,
    so the text matched by <tt>.*</tt> is backtracked by one position, which
    leaves the final character of the string available to match <tt>"</tt>

              /".*"/.match('"Quote"')     #=> #<MatchData "\"Quote\"">

    If <tt>.*</tt> is grouped atomically, it refuses to backtrack <i>Quote"</i>,
    even though this means that the overall match fails

        /"(?>.*)"/.match('"Quote"') #=> nil

    == Subexpression Calls

    The <tt>\g<</tt><i>name</i><tt>></tt> syntax matches the previous
    subexpression named _name_, which can be a group name or number, again.
    This differs from backreferences in that it re-executes the group rather
    than simply trying to re-match the same text.

    This pattern matches a <i>(</i> character and assigns it to the <tt>paren</tt>
    group, tries to call that the <tt>paren</tt> sub-expression again but fails,
    then matches a literal <i>)</i>:

        /\A(?<paren>\(\g<paren>*\))*\z/ =~ '()'


        /\A(?<paren>\(\g<paren>*\))*\z/ =~ '(())' #=> 0
        # ^1
        #      ^2
        #           ^3
        #                 ^4
        #      ^5
        #           ^6
        #                      ^7
        #                       ^8
        #                       ^9
        #                           ^10

    1.  Matches at the beginning of the string, i.e. before the first
        character.
    2.  Enters a named capture group called <tt>paren</tt>
    3.  Matches a literal <i>(</i>, the first character in the string
    4.  Calls the <tt>paren</tt> group again, i.e. recurses back to the
        second step
    5.  Re-enters the <tt>paren</tt> group
    6.  Matches a literal <i>(</i>, the second character in the
        string
    7.  Try to call <tt>paren</tt> a third time, but fail because
        doing so would prevent an overall successful match
    8.  Match a literal <i>)</i>, the third character in the string.
        Marks the end of the second recursive call
    9.  Match a literal <i>)</i>, the fourth character in the string
    10. Match the end of the string

    == Alternation

    The vertical bar metacharacter (<tt>|</tt>) combines two expressions into
    a single one that matches either of the expressions. Each expression is an
    <i>alternative</i>.

        /\w(and|or)\w/.match("Feliformia") #=> #<MatchData "form" 1:"or">
        /\w(and|or)\w/.match("furandi")    #=> #<MatchData "randi" 1:"and">
        /\w(and|or)\w/.match("dissemblance") #=> nil

    == Character Properties

    The <tt>\p{}</tt> construct matches characters with the named property,
    much like POSIX bracket classes.

    * <tt>/\p{Alnum}/</tt> - Alphabetic and numeric character
    * <tt>/\p{Alpha}/</tt> - Alphabetic character
    * <tt>/\p{Blank}/</tt> - Space or tab
    * <tt>/\p{Cntrl}/</tt> - Control character
    * <tt>/\p{Digit}/</tt> - Digit
    * <tt>/\p{Graph}/</tt> - Non-blank character (excludes spaces, control
      characters, and similar)
    * <tt>/\p{Lower}/</tt> - Lowercase alphabetical character
    * <tt>/\p{Print}/</tt> - Like <tt>\p{Graph}</tt>, but includes the space character
    * <tt>/\p{Punct}/</tt> - Punctuation character
    * <tt>/\p{Space}/</tt> - Whitespace character (<tt>[:blank:]</tt>, newline,
      carriage return, etc.)
    * <tt>/\p{Upper}/</tt> - Uppercase alphabetical
    * <tt>/\p{XDigit}/</tt> - Digit allowed in a hexadecimal number (i.e., 0-9a-fA-F)
    * <tt>/\p{Word}/</tt> - A member of one of the following Unicode general
      category <i>Letter</i>, <i>Mark</i>, <i>Number</i>,
      <i>Connector\_Punctuation</i>
    * <tt>/\p{ASCII}/</tt> - A character in the ASCII character set
    * <tt>/\p{Any}/</tt> - Any Unicode character (including unassigned
      characters)
    * <tt>/\p{Assigned}/</tt> - An assigned character

    A Unicode character's <i>General Category</i> value can also be matched
    with <tt>\p{</tt><i>Ab</i><tt>}</tt> where <i>Ab</i> is the category's
    abbreviation as described below:

    * <tt>/\p{L}/</tt> - 'Letter'
    * <tt>/\p{Ll}/</tt> - 'Letter: Lowercase'
    * <tt>/\p{Lm}/</tt> - 'Letter: Mark'
    * <tt>/\p{Lo}/</tt> - 'Letter: Other'
    * <tt>/\p{Lt}/</tt> - 'Letter: Titlecase'
    * <tt>/\p{Lu}/</tt> - 'Letter: Uppercase
    * <tt>/\p{Lo}/</tt> - 'Letter: Other'
    * <tt>/\p{M}/</tt> - 'Mark'
    * <tt>/\p{Mn}/</tt> - 'Mark: Nonspacing'
    * <tt>/\p{Mc}/</tt> - 'Mark: Spacing Combining'
    * <tt>/\p{Me}/</tt> - 'Mark: Enclosing'
    * <tt>/\p{N}/</tt> - 'Number'
    * <tt>/\p{Nd}/</tt> - 'Number: Decimal Digit'
    * <tt>/\p{Nl}/</tt> - 'Number: Letter'
    * <tt>/\p{No}/</tt> - 'Number: Other'
    * <tt>/\p{P}/</tt> - 'Punctuation'
    * <tt>/\p{Pc}/</tt> - 'Punctuation: Connector'
    * <tt>/\p{Pd}/</tt> - 'Punctuation: Dash'
    * <tt>/\p{Ps}/</tt> - 'Punctuation: Open'
    * <tt>/\p{Pe}/</tt> - 'Punctuation: Close'
    * <tt>/\p{Pi}/</tt> - 'Punctuation: Initial Quote'
    * <tt>/\p{Pf}/</tt> - 'Punctuation: Final Quote'
    * <tt>/\p{Po}/</tt> - 'Punctuation: Other'
    * <tt>/\p{S}/</tt> - 'Symbol'
    * <tt>/\p{Sm}/</tt> - 'Symbol: Math'
    * <tt>/\p{Sc}/</tt> - 'Symbol: Currency'
    * <tt>/\p{Sc}/</tt> - 'Symbol: Currency'
    * <tt>/\p{Sk}/</tt> - 'Symbol: Modifier'
    * <tt>/\p{So}/</tt> - 'Symbol: Other'
    * <tt>/\p{Z}/</tt> - 'Separator'
    * <tt>/\p{Zs}/</tt> - 'Separator: Space'
    * <tt>/\p{Zl}/</tt> - 'Separator: Line'
    * <tt>/\p{Zp}/</tt> - 'Separator: Paragraph'
    * <tt>/\p{C}/</tt> - 'Other'
    * <tt>/\p{Cc}/</tt> - 'Other: Control'
    * <tt>/\p{Cf}/</tt> - 'Other: Format'
    * <tt>/\p{Cn}/</tt> - 'Other: Not Assigned'
    * <tt>/\p{Co}/</tt> - 'Other: Private Use'
    * <tt>/\p{Cs}/</tt> - 'Other: Surrogate'

    Lastly, <tt>\p{}</tt> matches a character's Unicode <i>script</i>. The
    following scripts are supported: <i>Arabic</i>, <i>Armenian</i>,
    <i>Balinese</i>, <i>Bengali</i>, <i>Bopomofo</i>, <i>Braille</i>,
    <i>Buginese</i>, <i>Buhid</i>, <i>Canadian_Aboriginal</i>, <i>Carian</i>,
    <i>Cham</i>, <i>Cherokee</i>, <i>Common</i>, <i>Coptic</i>,
    <i>Cuneiform</i>, <i>Cypriot</i>, <i>Cyrillic</i>, <i>Deseret</i>,
    <i>Devanagari</i>, <i>Ethiopic</i>, <i>Georgian</i>, <i>Glagolitic</i>,
    <i>Gothic</i>, <i>Greek</i>, <i>Gujarati</i>, <i>Gurmukhi</i>, <i>Han</i>,
    <i>Hangul</i>, <i>Hanunoo</i>, <i>Hebrew</i>, <i>Hiragana</i>,
    <i>Inherited</i>, <i>Kannada</i>, <i>Katakana</i>, <i>Kayah_Li</i>,
    <i>Kharoshthi</i>, <i>Khmer</i>, <i>Lao</i>, <i>Latin</i>, <i>Lepcha</i>,
    <i>Limbu</i>, <i>Linear_B</i>, <i>Lycian</i>, <i>Lydian</i>,
    <i>Malayalam</i>, <i>Mongolian</i>, <i>Myanmar</i>, <i>New_Tai_Lue</i>,
    <i>Nko</i>, <i>Ogham</i>, <i>Ol_Chiki</i>, <i>Old_Italic</i>,
    <i>Old_Persian</i>, <i>Oriya</i>, <i>Osmanya</i>, <i>Phags_Pa</i>,
    <i>Phoenician</i>, <i>Rejang</i>, <i>Runic</i>, <i>Saurashtra</i>,
    <i>Shavian</i>, <i>Sinhala</i>, <i>Sundanese</i>, <i>Syloti_Nagri</i>,
    <i>Syriac</i>, <i>Tagalog</i>, <i>Tagbanwa</i>, <i>Tai_Le</i>,
    <i>Tamil</i>, <i>Telugu</i>, <i>Thaana</i>, <i>Thai</i>, <i>Tibetan</i>,
    <i>Tifinagh</i>, <i>Ugaritic</i>, <i>Vai</i>, and <i>Yi</i>.

    Unicode codepoint U+06E9 is named "ARABIC PLACE OF SAJDAH" and belongs to the
    Arabic script:

        /\p{Arabic}/.match("\u06E9") #=> #<MatchData "\u06E9">

    All character properties can be inverted by prefixing their name with a
    caret (<tt>^</tt>).

    Letter 'A' is not in the Unicode Ll (Letter; Lowercase) category, so this
    match succeeds:

        /\p{^Ll}/.match("A") #=> #<MatchData "A">

    == Anchors

    Anchors are metacharacter that match the zero-width positions between
    characters, <i>anchoring</i> the match to a specific position.

    * <tt>^</tt> - Matches beginning of line
    * <tt>$</tt> - Matches end of line
    * <tt>\A</tt> - Matches beginning of string.
    * <tt>\Z</tt> - Matches end of string. If string ends with a newline,
      it matches just before newline
    * <tt>\z</tt> - Matches end of string
    * <tt>\G</tt> - Matches first matching position:

      In methods like <tt>String#gsub</tt> and <tt>String#scan</tt>, it changes on each iteration.
      It initially matches the beginning of subject, and in each following iteration it matches where the last match finished.

          "    a b c".gsub(/ /, '_')    #=> "____a_b_c"
          "    a b c".gsub(/\G /, '_')  #=> "____a b c"

      In methods like <tt>Regexp#match</tt> and <tt>String#match</tt> that take an (optional) offset, it matches where the search begins.

          "hello, world".match(/,/, 3)    #=> #<MatchData ",">
          "hello, world".match(/\G,/, 3)  #=> nil

    * <tt>\b</tt> - Matches word boundaries when outside brackets;
      backspace (0x08) when inside brackets
    * <tt>\B</tt> - Matches non-word boundaries
    * <tt>(?=</tt><i>pat</i><tt>)</tt> - <i>Positive lookahead</i> assertion:
      ensures that the following characters match <i>pat</i>, but doesn't
      include those characters in the matched text
    * <tt>(?!</tt><i>pat</i><tt>)</tt> - <i>Negative lookahead</i> assertion:
      ensures that the following characters do not match <i>pat</i>, but
      doesn't include those characters in the matched text
    * <tt>(?<=</tt><i>pat</i><tt>)</tt> - <i>Positive lookbehind</i>
      assertion: ensures that the preceding characters match <i>pat</i>, but
      doesn't include those characters in the matched text
    * <tt>(?<!</tt><i>pat</i><tt>)</tt> - <i>Negative lookbehind</i>
      assertion: ensures that the preceding characters do not match
      <i>pat</i>, but doesn't include those characters in the matched text

    If a pattern isn't anchored it can begin at any point in the string:

        /real/.match("surrealist") #=> #<MatchData "real">

    Anchoring the pattern to the beginning of the string forces the match to start
    there. 'real' doesn't occur at the beginning of the string, so now the match
    fails:

        /\Areal/.match("surrealist") #=> nil

    The match below fails because although 'Demand' contains 'and', the pattern
    does not occur at a word boundary.

        /\band/.match("Demand")

    Whereas in the following example 'and' has been anchored to a non-word
    boundary so instead of matching the first 'and' it matches from the fourth
    letter of 'demand' instead:

        /\Band.+/.match("Supply and demand curve") #=> #<MatchData "and curve">

    The pattern below uses positive lookahead and positive lookbehind to match
    text appearing in <b></b> tags without including the tags in the match:

        /(?<=<b>)\w+(?=<\/b>)/.match("Fortune favours the <b>bold</b>")
            #=> #<MatchData "bold">

    == Options

    The end delimiter for a regexp can be followed by one or more single-letter
    options which control how the pattern can match.

    * <tt>/pat/i</tt> - Ignore case
    * <tt>/pat/m</tt> - Treat a newline as a character matched by <tt>.</tt>
    * <tt>/pat/x</tt> - Ignore whitespace and comments in the pattern
    * <tt>/pat/o</tt> - Perform <tt>#{}</tt> interpolation only once

    <tt>i</tt>, <tt>m</tt>, and <tt>x</tt> can also be applied on the
    subexpression level with the
    <tt>(?</tt><i>on</i><tt>-</tt><i>off</i><tt>)</tt> construct, which
    enables options <i>on</i>, and disables options <i>off</i> for the
    expression enclosed by the parentheses:

        /a(?i:b)c/.match('aBc')   #=> #<MatchData "aBc">
        /a(?-i:b)c/i.match('ABC') #=> nil

    Additionally, these options can also be toggled for the remainder of the
    pattern:

        /a(?i)bc/.match('abC') #=> #<MatchData "abC">

    Options may also be used with <tt>Regexp.new</tt>:

        Regexp.new("abc", Regexp::IGNORECASE)                     #=> /abc/i
        Regexp.new("abc", Regexp::MULTILINE)                      #=> /abc/m
        Regexp.new("abc # Comment", Regexp::EXTENDED)             #=> /abc # Comment/x
        Regexp.new("abc", Regexp::IGNORECASE | Regexp::MULTILINE) #=> /abc/mi

    == Free-Spacing Mode and Comments

    As mentioned above, the <tt>x</tt> option enables <i>free-spacing</i>
    mode. Literal white space inside the pattern is ignored, and the
    octothorpe (<tt>#</tt>) character introduces a comment until the end of
    the line. This allows the components of the pattern to be organized in a
    potentially more readable fashion.

    A contrived pattern to match a number with optional decimal places:

        float_pat = /\A
            [[:digit:]]+ # 1 or more digits before the decimal point
            (\.          # Decimal point
                [[:digit:]]+ # 1 or more digits after the decimal point
            )? # The decimal point and following digits are optional
        \Z/x
        float_pat.match('3.14') #=> #<MatchData "3.14" 1:".14">

    There are a number of strategies for matching whitespace:

    * Use a pattern such as <tt>\s</tt> or <tt>\p{Space}</tt>.
    * Use escaped whitespace such as <tt>\ </tt>, i.e. a space preceded by a backslash.
    * Use a character class such as <tt>[ ]</tt>.

    Comments can be included in a non-<tt>x</tt> pattern with the
    <tt>(?#</tt><i>comment</i><tt>)</tt> construct, where <i>comment</i> is
    arbitrary text ignored by the regexp engine.

    Comments in regexp literals cannot include unescaped terminator
    characters.

    == Encoding

    Regular expressions are assumed to use the source encoding. This can be
    overridden with one of the following modifiers.

    * <tt>/</tt><i>pat</i><tt>/u</tt> - UTF-8
    * <tt>/</tt><i>pat</i><tt>/e</tt> - EUC-JP
    * <tt>/</tt><i>pat</i><tt>/s</tt> - Windows-31J
    * <tt>/</tt><i>pat</i><tt>/n</tt> - ASCII-8BIT

    A regexp can be matched against a string when they either share an
    encoding, or the regexp's encoding is _US-ASCII_ and the string's encoding
    is ASCII-compatible.

    If a match between incompatible encodings is attempted an
    <tt>Encoding::CompatibilityError</tt> exception is raised.

    The <tt>Regexp#fixed_encoding?</tt> predicate indicates whether the regexp
    has a <i>fixed</i> encoding, that is one incompatible with ASCII. A
    regexp's encoding can be explicitly fixed by supplying
    <tt>Regexp::FIXEDENCODING</tt> as the second argument of
    <tt>Regexp.new</tt>:

        r = Regexp.new("a".force_encoding("iso-8859-1"),Regexp::FIXEDENCODING)
        r =~ "a\u3042"
           # raises Encoding::CompatibilityError: incompatible encoding regexp match
           #         (ISO-8859-1 regexp with UTF-8 string)

    == Special global variables

    Pattern matching sets some global variables :
    * <tt>$~</tt> is equivalent to Regexp.last_match;
    * <tt>$&</tt> contains the complete matched text;
    * <tt>$`</tt> contains string before match;
    * <tt>$'</tt> contains string after match;
    * <tt>$1</tt>, <tt>$2</tt> and so on contain text matching first, second, etc
      capture group;
    * <tt>$+</tt> contains last capture group.

    Example:

        m = /s(\w{2}).*(c)/.match('haystack') #=> #<MatchData "stac" 1:"ta" 2:"c">
        $~                                    #=> #<MatchData "stac" 1:"ta" 2:"c">
        Regexp.last_match                     #=> #<MatchData "stac" 1:"ta" 2:"c">

        $&      #=> "stac"
                # same as m[0]
        $`      #=> "hay"
                # same as m.pre_match
        $'      #=> "k"
                # same as m.post_match
        $1      #=> "ta"
                # same as m[1]
        $2      #=> "c"
                # same as m[2]
        $3      #=> nil
                # no third group in pattern
        $+      #=> "c"
                # same as m[-1]

    These global variables are thread-local and method-local variables.

    == Performance

    Certain pathological combinations of constructs can lead to abysmally bad
    performance.

    Consider a string of 25 <i>a</i>s, a <i>d</i>, 4 <i>a</i>s, and a
    <i>c</i>.

        s = 'a' * 25 + 'd' + 'a' * 4 + 'c'
        #=> "aaaaaaaaaaaaaaaaaaaaaaaaadaaaac"

    The following patterns match instantly as you would expect:

        /(b|a)/ =~ s #=> 0
        /(b|a+)/ =~ s #=> 0
        /(b|a+)*/ =~ s #=> 0

    However, the following pattern takes appreciably longer:

        /(b|a+)*c/ =~ s #=> 26

    This happens because an atom in the regexp is quantified by both an
    immediate <tt>+</tt> and an enclosing <tt>*</tt> with nothing to
    differentiate which is in control of any particular character. The
    nondeterminism that results produces super-linear performance. (Consult
    <i>Mastering Regular Expressions</i> (3rd ed.), pp 222, by
    <i>Jeffery Friedl</i>, for an in-depth analysis). This particular case
    can be fixed by use of atomic grouping, which prevents the unnecessary
    backtracking:

        (start = Time.now) && /(b|a+)*c/ =~ s && (Time.now - start)
           #=> 24.702736882
        (start = Time.now) && /(?>b|a+)*c/ =~ s && (Time.now - start)
           #=> 0.000166571

    A similar case is typified by the following example, which takes
    approximately 60 seconds to execute for me:

    Match a string of 29 <i>a</i>s against a pattern of 29 optional <i>a</i>s
    followed by 29 mandatory <i>a</i>s:

        Regexp.new('a?' * 29 + 'a' * 29) =~ 'a' * 29

    The 29 optional <i>a</i>s match the string, but this prevents the 29
    mandatory <i>a</i>s that follow from matching. Ruby must then backtrack
    repeatedly so as to satisfy as many of the optional matches as it can
    while still matching the mandatory 29. It is plain to us that none of the
    optional matches can succeed, but this fact unfortunately eludes Ruby.

    The best way to improve performance is to significantly reduce the amount of
    backtracking needed.  For this case, instead of individually matching 29
    optional <i>a</i>s, a range of optional <i>a</i>s can be matched all at once
    with <i>a{0,29}</i>:

        Regexp.new('a{0,29}' + 'a' * 29) =~ 'a' * 29

RegexpError:
  main: |-
    Raised when given an invalid regexp expression.

       Regexp.new("?")

    <em>raises the exception:</em>

       RegexpError: target of repeat operator is not specified: /?/
RubyVM:
  main: |-
    The RubyVM module only exists on MRI. +RubyVM+ is not defined in
    other Ruby implementations such as JRuby and TruffleRuby.

    The RubyVM module provides some access to MRI internals.
    This module is for very limited purposes, such as debugging,
    prototyping, and research.  Normal users must not use it.
    This module is not portable between Ruby implementations.
RubyVM::AbstractSyntaxTree:
  main: |-
    AbstractSyntaxTree provides methods to parse Ruby code into
    abstract syntax trees. The nodes in the tree
    are instances of RubyVM::AbstractSyntaxTree::Node.

    This class is MRI specific as it exposes implementation details
    of the MRI abstract syntax tree.

    This class is experimental and its API is not stable, therefore it might
    change without notice. As examples, the order of children nodes is not
    guaranteed, the number of children nodes might change, there is no way to
    access children nodes by name, etc.

    If you are looking for a stable API or an API working under multiple Ruby
    implementations, consider using the _parser_ gem or Ripper. If you would
    like to make RubyVM::AbstractSyntaxTree stable, please join the discussion
    at https://bugs.ruby-lang.org/issues/14844.
RubyVM::AbstractSyntaxTree::Node:
  main: |-
    RubyVM::AbstractSyntaxTree::Node instances are created by parse methods in
    RubyVM::AbstractSyntaxTree.

    This class is MRI specific.
RubyVM::InstructionSequence:
  main: |-
    The InstructionSequence class represents a compiled sequence of
    instructions for the Virtual Machine used in MRI. Not all implementations of Ruby
    may implement this class, and for the implementations that implement it,
    the methods defined and behavior of the methods can change in any version.

    With it, you can get a handle to the instructions that make up a method or
    a proc, compile strings of Ruby code down to VM instructions, and
    disassemble instruction sequences to strings for easy inspection. It is
    mostly useful if you want to learn how YARV works, but it also lets
    you control various settings for the Ruby iseq compiler.

    You can find the source for the VM instructions in +insns.def+ in the Ruby
    source.

    The instruction sequence results will almost certainly change as Ruby
    changes, so example output in this documentation may be different from what
    you see.

    Of course, this class is MRI specific.
RubyVM::MJIT:
  main: |-
    ::RubyVM::MJIT
        Provides access to the Method JIT compiler of MRI.
        Of course, this module is MRI specific.
RuntimeError:
  main: |-
    A generic error class raised when an invalid operation is attempted.
    Kernel#raise will raise a RuntimeError if no Exception class is
    specified.

       raise "ouch"

    <em>raises the exception:</em>

       RuntimeError: ouch
ScriptError:
  main: |-
    ScriptError is the superclass for errors raised when a script
    can not be executed because of a +LoadError+,
    +NotImplementedError+ or a +SyntaxError+. Note these type of
    +ScriptErrors+ are not +StandardError+ and will not be
    rescued unless it is specified explicitly (or its ancestor
    +Exception+).
SecurityError:
  main: No longer used by internal code.
Signal:
  main: |-
    Many operating systems allow signals to be sent to running
    processes. Some signals have a defined effect on the process, while
    others may be trapped at the code level and acted upon. For
    example, your process may trap the USR1 signal and use it to toggle
    debugging, and may use TERM to initiate a controlled shutdown.

        pid = fork do
          Signal.trap("USR1") do
            $debug = !$debug
            puts "Debug now: #$debug"
          end
          Signal.trap("TERM") do
            puts "Terminating..."
            shutdown()
          end
          # . . . do some work . . .
        end

        Process.detach(pid)

        # Controlling program:
        Process.kill("USR1", pid)
        # ...
        Process.kill("USR1", pid)
        # ...
        Process.kill("TERM", pid)

    produces:
        Debug now: true
        Debug now: false
       Terminating...

    The list of available signal names and their interpretation is
    system dependent. Signal delivery semantics may also vary between
    systems; in particular signal delivery may not always be reliable.
SignalException:
  main: |-
    Raised when a signal is received.

       begin
         Process.kill('HUP',Process.pid)
         sleep # wait for receiver to handle signal sent by Process.kill
       rescue SignalException => e
         puts "received Exception #{e}"
       end

    <em>produces:</em>

       received Exception SIGHUP
SizedQueue:
  main: |-
    This class represents queues of specified size capacity.  The push operation
    may be blocked if the capacity is full.

    See Queue for an example of how a SizedQueue works.
StandardError:
  main: |-
    The most standard error types are subclasses of StandardError. A
    rescue clause without an explicit Exception class will rescue all
    StandardErrors (and only those).

       def foo
         raise "Oups"
       end
       foo rescue "Hello"   #=> "Hello"

    On the other hand:

       require 'does/not/exist' rescue "Hi"

    <em>raises the exception:</em>

       LoadError: no such file to load -- does/not/exist
StopIteration:
  main: |-
    Raised to stop the iteration, in particular by Enumerator#next. It is
    rescued by Kernel#loop.

      loop do
        puts "Hello"
        raise StopIteration
        puts "World"
      end
      puts "Done!"

    <em>produces:</em>

      Hello
      Done!
String:
  main: |-
    A String object holds and manipulates an arbitrary sequence of
    bytes, typically representing characters. String objects may be created
    using String::new or as literals.

    Because of aliasing issues, users of strings should be aware of the methods
    that modify the contents of a String object.  Typically,
    methods with names ending in ``!'' modify their receiver, while those
    without a ``!'' return a new String.  However, there are
    exceptions, such as String#[]=.
Struct:
  main: |-
    A Struct is a convenient way to bundle a number of attributes together,
    using accessor methods, without having to write an explicit class.

    The Struct class generates new subclasses that hold a set of members and
    their values.  For each member a reader and writer method is created
    similar to Module#attr_accessor.

       Customer = Struct.new(:name, :address) do
         def greeting
           "Hello #{name}!"
         end
       end

       dave = Customer.new("Dave", "123 Main")
       dave.name     #=> "Dave"
       dave.greeting #=> "Hello Dave!"

    See Struct::new for further examples of creating struct subclasses and
    instances.

    In the method descriptions that follow, a "member" parameter refers to a
    struct member which is either a quoted string (<code>"name"</code>) or a
    Symbol (<code>:name</code>).
Symbol:
  main: |-
    Symbol objects represent names inside the Ruby interpreter. They
    are generated using the <code>:name</code> and
    <code>:"string"</code> literals syntax, and by the various
    <code>to_sym</code> methods. The same Symbol object will be
    created for a given name or string for the duration of a program's
    execution, regardless of the context or meaning of that name. Thus
    if <code>Fred</code> is a constant in one context, a method in
    another, and a class in a third, the Symbol <code>:Fred</code>
    will be the same object in all three contexts.

       module One
         class Fred
         end
         $f1 = :Fred
       end
       module Two
         Fred = 1
         $f2 = :Fred
       end
       def Fred()
       end
       $f3 = :Fred
       $f1.object_id   #=> 2514190
       $f2.object_id   #=> 2514190
       $f3.object_id   #=> 2514190
SyntaxError:
  main: |-
    Raised when encountering Ruby code with an invalid syntax.

       eval("1+1=2")

    <em>raises the exception:</em>

       SyntaxError: (eval):1: syntax error, unexpected '=', expecting $end
SystemCallError:
  main: |-
    SystemCallError is the base class for all low-level
    platform-dependent errors.

    The errors available on the current platform are subclasses of
    SystemCallError and are defined in the Errno module.

       File.open("does/not/exist")

    <em>raises the exception:</em>

       Errno::ENOENT: No such file or directory - does/not/exist
SystemExit:
  main: Raised by +exit+ to initiate the termination of the script.
SystemStackError:
  main: |-
    Raised in case of a stack overflow.

       def me_myself_and_i
         me_myself_and_i
       end
       me_myself_and_i

    <em>raises the exception:</em>

      SystemStackError: stack level too deep
Thread:
  main: |-
    Threads are the Ruby implementation for a concurrent programming model.

    Programs that require multiple threads of execution are a perfect
    candidate for Ruby's Thread class.

    For example, we can create a new thread separate from the main thread's
    execution using ::new.

        thr = Thread.new { puts "What's the big deal" }

    Then we are able to pause the execution of the main thread and allow
    our new thread to finish, using #join:

        thr.join #=> "What's the big deal"

    If we don't call +thr.join+ before the main thread terminates, then all
    other threads including +thr+ will be killed.

    Alternatively, you can use an array for handling multiple threads at
    once, like in the following example:

        threads = []
        threads << Thread.new { puts "What's the big deal" }
        threads << Thread.new { 3.times { puts "Threads are fun!" } }

    After creating a few threads we wait for them all to finish
    consecutively.

        threads.each { |thr| thr.join }

    To retrieve the last value of a thread, use #value

        thr = Thread.new { sleep 1; "Useful value" }
        thr.value #=> "Useful value"

    === Thread initialization

    In order to create new threads, Ruby provides ::new, ::start, and
    ::fork. A block must be provided with each of these methods, otherwise
    a ThreadError will be raised.

    When subclassing the Thread class, the +initialize+ method of your
    subclass will be ignored by ::start and ::fork. Otherwise, be sure to
    call super in your +initialize+ method.

    === Thread termination

    For terminating threads, Ruby provides a variety of ways to do this.

    The class method ::kill, is meant to exit a given thread:

        thr = Thread.new { sleep }
        Thread.kill(thr) # sends exit() to thr

    Alternatively, you can use the instance method #exit, or any of its
    aliases #kill or #terminate.

        thr.exit

    === Thread status

    Ruby provides a few instance methods for querying the state of a given
    thread. To get a string with the current thread's state use #status

        thr = Thread.new { sleep }
        thr.status # => "sleep"
        thr.exit
        thr.status # => false

    You can also use #alive? to tell if the thread is running or sleeping,
    and #stop? if the thread is dead or sleeping.

    === Thread variables and scope

    Since threads are created with blocks, the same rules apply to other
    Ruby blocks for variable scope. Any local variables created within this
    block are accessible to only this thread.

    ==== Fiber-local vs. Thread-local

    Each fiber has its own bucket for Thread#[] storage. When you set a
    new fiber-local it is only accessible within this Fiber. To illustrate:

        Thread.new {
          Thread.current[:foo] = "bar"
          Fiber.new {
            p Thread.current[:foo] # => nil
          }.resume
        }.join

    This example uses #[] for getting and #[]= for setting fiber-locals,
    you can also use #keys to list the fiber-locals for a given
    thread and #key? to check if a fiber-local exists.

    When it comes to thread-locals, they are accessible within the entire
    scope of the thread. Given the following example:

        Thread.new{
          Thread.current.thread_variable_set(:foo, 1)
          p Thread.current.thread_variable_get(:foo) # => 1
          Fiber.new{
            Thread.current.thread_variable_set(:foo, 2)
            p Thread.current.thread_variable_get(:foo) # => 2
          }.resume
          p Thread.current.thread_variable_get(:foo)   # => 2
        }.join

    You can see that the thread-local +:foo+ carried over into the fiber
    and was changed to +2+ by the end of the thread.

    This example makes use of #thread_variable_set to create new
    thread-locals, and #thread_variable_get to reference them.

    There is also #thread_variables to list all thread-locals, and
    #thread_variable? to check if a given thread-local exists.

    === Exception handling

    When an unhandled exception is raised inside a thread, it will
    terminate. By default, this exception will not propagate to other
    threads. The exception is stored and when another thread calls #value
    or #join, the exception will be re-raised in that thread.

        t = Thread.new{ raise 'something went wrong' }
        t.value #=> RuntimeError: something went wrong

    An exception can be raised from outside the thread using the
    Thread#raise instance method, which takes the same parameters as
    Kernel#raise.

    Setting Thread.abort_on_exception = true, Thread#abort_on_exception =
    true, or $DEBUG = true will cause a subsequent unhandled exception
    raised in a thread to be automatically re-raised in the main thread.

    With the addition of the class method ::handle_interrupt, you can now
    handle exceptions asynchronously with threads.

    === Scheduling

    Ruby provides a few ways to support scheduling threads in your program.

    The first way is by using the class method ::stop, to put the current
    running thread to sleep and schedule the execution of another thread.

    Once a thread is asleep, you can use the instance method #wakeup to
    mark your thread as eligible for scheduling.

    You can also try ::pass, which attempts to pass execution to another
    thread but is dependent on the OS whether a running thread will switch
    or not. The same goes for #priority, which lets you hint to the thread
    scheduler which threads you want to take precedence when passing
    execution. This method is also dependent on the OS and may be ignored
    on some platforms.
Thread::Backtrace::Location:
  main: |-
    An object representation of a stack frame, initialized by
    Kernel#caller_locations.

    For example:

            # caller_locations.rb
            def a(skip)
              caller_locations(skip)
            end
            def b(skip)
              a(skip)
            end
            def c(skip)
              b(skip)
            end

            c(0..2).map do |call|
              puts call.to_s
            end

    Running <code>ruby caller_locations.rb</code> will produce:

            caller_locations.rb:2:in `a'
            caller_locations.rb:5:in `b'
            caller_locations.rb:8:in `c'

    Here's another example with a slightly different result:

            # foo.rb
            class Foo
              attr_accessor :locations
              def initialize(skip)
                @locations = caller_locations(skip)
              end
            end

            Foo.new(0..2).locations.map do |call|
              puts call.to_s
            end

    Now run <code>ruby foo.rb</code> and you should see:

            init.rb:4:in `initialize'
            init.rb:8:in `new'
            init.rb:8:in `<main>'
ThreadError:
  main: |-
    Raised when an invalid operation is attempted on a thread.

    For example, when no other thread has been started:

       Thread.stop

    This will raises the following exception:

       ThreadError: stopping only thread
       note: use sleep to stop forever
ThreadGroup:
  main: |-
    ThreadGroup provides a means of keeping track of a number of threads as a
    group.

    A given Thread object can only belong to one ThreadGroup at a time; adding
    a thread to a new group will remove it from any previous group.

    Newly created threads belong to the same group as the thread from which they
    were created.
Time:
  main: |-
    Time is an abstraction of dates and times. Time is stored internally as
    the number of seconds with fraction since the _Epoch_, January 1, 1970
    00:00 UTC. Also see the library module Date. The Time class treats GMT
    (Greenwich Mean Time) and UTC (Coordinated Universal Time) as equivalent.
    GMT is the older way of referring to these baseline times but persists in
    the names of calls on POSIX systems.

    All times may have fraction. Be aware of this fact when comparing times
    with each other -- times that are apparently equal when displayed may be
    different when compared.

    Since Ruby 1.9.2, Time implementation uses a signed 63 bit integer,
    Bignum or Rational.
    The integer is a number of nanoseconds since the _Epoch_ which can
    represent 1823-11-12 to 2116-02-20.
    When Bignum or Rational is used (before 1823, after 2116, under
    nanosecond), Time works slower as when integer is used.

    = Examples

    All of these examples were done using the EST timezone which is GMT-5.

    == Creating a new Time instance

    You can create a new instance of Time with Time::new. This will use the
    current system time. Time::now is an alias for this. You can also
    pass parts of the time to Time::new such as year, month, minute, etc. When
    you want to construct a time this way you must pass at least a year. If you
    pass the year with nothing else time will default to January 1 of that year
    at 00:00:00 with the current system timezone. Here are some examples:

      Time.new(2002)         #=> 2002-01-01 00:00:00 -0500
      Time.new(2002, 10)     #=> 2002-10-01 00:00:00 -0500
      Time.new(2002, 10, 31) #=> 2002-10-31 00:00:00 -0500

    You can pass a UTC offset:

      Time.new(2002, 10, 31, 2, 2, 2, "+02:00") #=> 2002-10-31 02:02:02 +0200

    Or a timezone object:

      tz = timezone("Europe/Athens") # Eastern European Time, UTC+2
      Time.new(2002, 10, 31, 2, 2, 2, tz) #=> 2002-10-31 02:02:02 +0200

    You can also use Time::gm, Time::local and Time::utc to infer GMT,
    local and UTC timezones instead of using the current system
    setting.

    You can also create a new time using Time::at which takes the number of
    seconds (or fraction of seconds) since the {Unix
    Epoch}[http://en.wikipedia.org/wiki/Unix_time].

      Time.at(628232400) #=> 1989-11-28 00:00:00 -0500

    == Working with an instance of Time

    Once you have an instance of Time there is a multitude of things you can
    do with it. Below are some examples. For all of the following examples, we
    will work on the assumption that you have done the following:

      t = Time.new(1993, 02, 24, 12, 0, 0, "+09:00")

    Was that a monday?

      t.monday? #=> false

    What year was that again?

      t.year #=> 1993

    Was it daylight savings at the time?

      t.dst? #=> false

    What's the day a year later?

      t + (60*60*24*365) #=> 1994-02-24 12:00:00 +0900

    How many seconds was that since the Unix Epoch?

      t.to_i #=> 730522800

    You can also do standard functions like compare two times.

      t1 = Time.new(2010)
      t2 = Time.new(2011)

      t1 == t2 #=> false
      t1 == t1 #=> true
      t1 <  t2 #=> true
      t1 >  t2 #=> false

      Time.new(2010,10,31).between?(t1, t2) #=> true

    == Timezone argument

    A timezone argument must have +local_to_utc+ and +utc_to_local+
    methods, and may have +name+, +abbr+, and +dst?+ methods.

    The +local_to_utc+ method should convert a Time-like object from
    the timezone to UTC, and +utc_to_local+ is the opposite.  The
    result also should be a Time or Time-like object (not necessary to
    be the same class).  The #zone of the result is just ignored.
    Time-like argument to these methods is similar to a Time object in
    UTC without sub-second; it has attribute readers for the parts,
    e.g. #year, #month, and so on, and epoch time readers, #to_i.  The
    sub-second attributes are fixed as 0, and #utc_offset, #zone,
    #isdst, and their aliases are same as a Time object in UTC.
    Also #to_time, #+, and #- methods are defined.

    The +name+ method is used for marshaling. If this method is not
    defined on a timezone object, Time objects using that timezone
    object can not be dumped by Marshal.

    The +abbr+ method is used by '%Z' in #strftime.

    The +dst?+ method is called with a +Time+ value and should return whether
    the +Time+ value is in daylight savings time in the zone.

    === Auto conversion to Timezone

    At loading marshaled data, a timezone name will be converted to a timezone
    object by +find_timezone+ class method, if the method is defined.

    Similarly, that class method will be called when a timezone argument does
    not have the necessary methods mentioned above.
TracePoint:
  main: |-
    Document-class: TracePoint

    A class that provides the functionality of Kernel#set_trace_func in a
    nice Object-Oriented API.

    == Example

    We can use TracePoint to gather information specifically for exceptions:

              trace = TracePoint.new(:raise) do |tp|
                  p [tp.lineno, tp.event, tp.raised_exception]
              end
              #=> #<TracePoint:disabled>

              trace.enable
              #=> false

              0 / 0
              #=> [5, :raise, #<ZeroDivisionError: divided by 0>]

    == Events

    If you don't specify the type of events you want to listen for,
    TracePoint will include all available events.

    *Note* do not depend on current event set, as this list is subject to
    change. Instead, it is recommended you specify the type of events you
    want to use.

    To filter what is traced, you can pass any of the following as +events+:

    +:line+:: execute code on a new line
    +:class+:: start a class or module definition
    +:end+:: finish a class or module definition
    +:call+:: call a Ruby method
    +:return+:: return from a Ruby method
    +:c_call+:: call a C-language routine
    +:c_return+:: return from a C-language routine
    +:raise+:: raise an exception
    +:b_call+:: event hook at block entry
    +:b_return+:: event hook at block ending
    +:thread_begin+:: event hook at thread beginning
    +:thread_end+:: event hook at thread ending
    +:fiber_switch+:: event hook at fiber switch
    +:script_compiled+:: new Ruby code compiled (with +eval+, +load+ or +require+)
TrueClass:
  main: |-
    The global value <code>true</code> is the only instance of class
    TrueClass and represents a logically true value in
    boolean expressions. The class provides operators allowing
    <code>true</code> to be used in logical expressions.
TypeError:
  main: |-
    Raised when encountering an object that is not of the expected type.

       [1, 2, 3].first("two")

    <em>raises the exception:</em>

       TypeError: no implicit conversion of String into Integer
UnboundMethod:
  main: |-
    Ruby supports two forms of objectified methods. Class Method is
    used to represent methods that are associated with a particular
    object: these method objects are bound to that object. Bound
    method objects for an object can be created using Object#method.

    Ruby also supports unbound methods; methods objects that are not
    associated with a particular object. These can be created either
    by calling Module#instance_method or by calling #unbind on a bound
    method object. The result of both of these is an UnboundMethod
    object.

    Unbound methods can only be called after they are bound to an
    object. That object must be a kind_of? the method's original
    class.

       class Square
         def area
           @side * @side
         end
         def initialize(side)
           @side = side
         end
       end

       area_un = Square.instance_method(:area)

       s = Square.new(12)
       area = area_un.bind(s)
       area.call   #=> 144

    Unbound methods are a reference to the method at the time it was
    objectified: subsequent changes to the underlying class will not
    affect the unbound method.

       class Test
         def test
           :original
         end
       end
       um = Test.instance_method(:test)
       class Test
         def test
           :modified
         end
       end
       t = Test.new
       t.test            #=> :modified
       um.bind(t).call   #=> :original
UncaughtThrowError:
  main: |-
    Raised when +throw+ is called with a _tag_ which does not have
    corresponding +catch+ block.

       throw "foo", "bar"

    <em>raises the exception:</em>

       UncaughtThrowError: uncaught throw "foo"
UnicodeNormalize:
  main: 'define UnicodeNormalize module here so that we don''t have to look it up   '
Warning:
  main: |-
    The Warning module contains a single method named #warn, and the
    module extends itself, making Warning.warn available.
    Warning.warn is called for all warnings issued by Ruby.
    By default, warnings are printed to $stderr.

    By overriding Warning.warn, you can change how warnings are
    handled by Ruby, either filtering some warnings, and/or outputting
    warnings somewhere other than $stderr.  When Warning.warn is
    overridden, super can be called to get the default behavior of
    printing the warning to $stderr.
ZeroDivisionError:
  main: |-
    Raised when attempting to divide an integer by 0.

       42 / 0   #=> ZeroDivisionError: divided by 0

    Note that only division by an exact 0 will raise the exception:

       42 /  0.0   #=> Float::INFINITY
       42 / -0.0   #=> -Float::INFINITY
       0  /  0.0   #=> NaN
fatal:
  main: |-
    fatal is an Exception that is raised when Ruby has encountered a fatal
    error and must exit.
